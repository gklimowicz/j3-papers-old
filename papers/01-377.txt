
                                                           J3/01-377
Date:     November 15, 2001
To:       J3
From:     Dick Hendrickson
Subject:  Chapter 7 comments, updated from meeting 158

This is an update of 283/R2 from meeting 158.  I deleted the items
that were taken care of at the last meeting to make it easier for the
B team to process.  I kept the same numbering scheme as in 283 so that
notes from last meeting should still be valid.

Page, etc., numbers have been updated to the current 007/R4 PDF version

14)  Page 121[11-12], first sentence after note 7.13.  Is this true for
polymorphic things?  Something like
   poly_1 .operator. poly_f(poly_2 .other_operator. poly_3)

15)  (Continuation of previous question) Doesn't the evaluation of the
argument to poly_f in general determine the type of poly_f and hence the
type of the final expression?

16)  Page 124, 7.1.8.5, sentence after note 7.23.  Don't we need words
here like in 7.1.8.3 about mathematical and computational equivalence?
Something like:       X*Z .GT. X*Y
Becomes               X*Y - X*Z  .LT. 0
Becomes               X*(Y-Z)    .LT. 0
and this might have different round off characteristics

19)  Page 132, 7.5.1.2  (2)  Should the first line say dynamic and the
last declared?  Doesn't that mix things?

20)  Page 132, 7.1.5.2.  The last sentence defining derived type
intrinsic assignment appears to be restating (1) and (2) above, but the
words are somewhat different.  For example is "accessible defined
assignment" in (2) different from "no accessible generic interface ..."
For example, (2) in 7.3.2 goes into detail about where an interface may
come from and its typeboundness.  Should that apply here?  Or does "not
polymorphic" cover it?

21)  Page 132, 7.5.1.3.  Do we need to distinguish details about where
the interface is at ala (2) in 7.3.2?

22)  Page 134[4-8], paragraph after note 7.40, the middle clause about
nonpointer, nonallocatable.  Does this mean that derived type assignment
that is NOT type bound to the host type isn't used for the innards?
Suppose I have a type PERSON with a component of type KIDS and with a
subroutine that meets the requirements for KID_1 = KID_2.  If I do
PERSON_1 = PERSON_2
does the generic subroutine every get invoked?  Does it depend on
whether or not there is a type-bound assignment interface/routine in
PERSON?  Or in KIDS?  I'm asking about an old fashioned generic
assignment and how that fits in with the new type bound stuff.
Same comment for the last couple of lines in (2) on the next page.  It
reads to me that we require "type bound procedures" when I thought
generic assignment could work.

23)  Page 134[7-10], 7.5.1.6 (2)   Says there can be a type bound assignment
procedure in EITHER X1 or X2.  What happens if there is one in both and
they are different?

24)  Page 135, 7.5.2 R736  Does the second line allow something like
A%B%pointer => P or only one %?  Same question for R740

25)  Page 136[25-26], 7.5.2.1  Second paragraph.  Does this mean a non-
polymorphic pointer can point to a polymorphic object if the types are OK?
Or
should dynamic type be declared type.

26)  Page 137[14-16], 7.5.2.2, paragraph after unresolved issue.  In the
last
two lines one of the proc-target terms should be proc-pointer-object.  I
think the second one.  Right now it says proc-target may be elemental
even if proc-target isn't.

27)  withdrawn

28)  Page 139[16], 7.5.3.2 (2).  This means that the elsewhere mask
expression is FULLY evaluated without being masked out.  I think this is
surprising and probably not what we intended.  In something like
      WHERE (X  == 0 )
             ...
      ELSEWHERE ( 1/X > 10)      ! evaluated for all of X
                ...
      ENDWHERE
The same comment applies to a nested WHERE.  This came up on (I think)
the comp-f90 e-mail reflector and probably should be an F95 interpretation.

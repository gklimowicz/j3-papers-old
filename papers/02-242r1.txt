
                                                              02-242r1

To: J3
From: John Reid
Subject: Edits for sections 4 to 6
Date: 6 August 2002

I would like to acknowledge the help of Malcolm Cohen, Richard Maine,
Van Snyder and Rob James with the construction of some of these edits.

31:6. Change 'by composition of other' to 'from the intrinsic'.
[See 41:6.]

31:7. Change '<<components>>. Each component' to 'data and procedure <<components>>. Each data component'.

31:8. Change 'types of its components' to 'attributes of its
components'.  [See 41:7.]

33:1+2.  Change 'including' to 'and' and delete both commas.

41:16+2. In the first line of NOTE 4.17, change 'name, age' to
'oldest_child%name, 'oldest_child%age'.

41:19+ Add
  A derived type may have procedures bound to it. A bound procedure is
  accessible from an object of the type by the same syntax as for a
  procedure component, accessible as a defined operation when the
  type is accessible, or is a final subroutine that is executed
  whenever a data object of the type is finalized.

42:7 (TECHNICAL CHANGE). Change 'extensible type' to 'extensible type
that has no type parameters'.
[This brings the constraint into line with the text in 4.6, which says
that an alias is not a new type.  If we were to allow extension of an
alias to a type with parameters, we would be treating it as a new type
that has lost its type parameters and there is no text that explains
this.  4.6 also says 'declaration of an entity or component using a
type alias name has the same effect as using the declaration-type-spec
for which it is an alias', but the syntax rules do not allow a
declaration-type-spec at 42:7 unless it is a name.]

43:10. After 'shall' add 'either be an initialization expression or be a
specification expression that does'.
[The wording in Corrigendum 1 to F95 allows for an initialization
expression here. I believe that the present wording will lead to an
inconsistency with f95. See also C550 on p. 79.]

43:14. Change 'colon or' to 'colon, be an initialization expression, or'.
[See previous edit.]

43:31 to 44:3. Replace C438 and C439 by

C438 (R436) If PASS appears, the procedure component shall have an
     explicit interface specified by <proc-interface>. A dummy argument
     of the interface shall meet the requirements for a passed-object
     dummy argument (4.5.1.6). It shall be named <arg-name> if
     <arg-name> appears; otherwise, it shall be the first dummy
     argument.  It shall be polymorphic if and only if type type-name
     is extensible.  All of its nonkind type parameters shall be
     assumed.
44:5. Delete.
[I think it is clearer not to repeat things that are the same. I think
it needs to be said that the interface is specified by
<proc-interface>.  Finally, I found it hard to interpret C441 until I
realized it was all part of this, so I have included it here,]

44:25&27 (TECHNICAL CHANGE). Replace '<abstract-interface-name>' by
'<abstract-interface-name-list>.
[There are usually many specific procedures associated with a single
generic. The present syntax is not wrong because you can write many
GENERIC statements, one for each specific. However, this is
unnecessarily clumsy. I at first thought that this constraint was
in error because it specifies only one specific.]

45:11-19. Replace C455, C456 by

C455 (R440) If PASS appears, a dummy argument of each interface
     specified by <abstract-interface-name> or <binding> shall meet the
     requirements for a passed-object dummy argument (4.5.1.6). It
     shall be named <arg-name> if <arg-name> appears; otherwise, it
     shall be the first dummy argument.  It shall be polymorphic if and
     only if type type-name is extensible.  All of its nonkind type
     parameters shall be assumed.
45:31. Delete.
[I think it is clearer not to repeat things that are the same. The bit
about the interface being explicit is a distraction since it is always
the case for bindings and is covered by other constraints.  Finally, I
found it hard to interpret C462 until I realized it was all part of
this, so I have included it here,]

46:8. Change 'below' to 'later in this subclause'. ['below' is ambiguous.]

46:9-10. Delete sentence 'It is not ...'. [Adds nothing.]

46:14. Change 'below' to 'in the next paragraph'. ['below' is ambiguous.]

46:15+9. Change 'it to' to 'this'.

47:19-22. Replace paragraph by
   A subcomponent (6.1.2) is said to be <<default-initialized>> if it
   will be initialized by default initialization.
[The old paragraph is wrong, since the first and second sentences are
inconsistent for sub-sub-components. It is also incomplete.  Why try
this, given that the concept has already been defined in the previous
paragraph? I have copied the words from the glossary.]

49:2. Change 'component' to 'data component' and '<component-def->' to
'<data-component-def->'.

50:4-5. Replace by

   The interface of a specific binding specified with <null-init> is
   that of <abstract-interface-name> if present or that of the binding
   to the parent type otherwise.  The interface of a specific binding
   specified with <procedure-name> is that of the procedure.

   The interface of a generic binding contains the interfaces of all
   the procedures in its <abstract-interface-name-list>s and
   <binding-list>s and all those of the parent type that have the same
   <generic-spec> and are not overridden.

51:2. Delete 'instead of a procedure name'. [Wrong in the generic case.]

51:4. After 'specific procedure' add 'that overrides (4.5.3.2) the
inherited binding'.
51:6. Delete '(4.5.3.2)'.
[We need to make it clear that the rules of overriding apply when the
inherited binding is deferred.]

51:23+6-8. Change the last sentence of NOTE 4.35 to
   The parent component is finalized by the finalization process of
   the parent type.
[Misleading to talk about final subroutines being called since usually
only one is actually called.]

52:15. Delete 'for the type definition in which it is declared'.
[This paragraph has been explained at length what the default is.
This clause makes it sound different.]

52:18. Before 'any' to 'an accessible type or an'.
[To allow for access through an operator.]

52:19. After 'accessible' add 'in these ways'.
[It might be accessible by other means outside the module.]

56:6. Change 'nongeneric' to 'specific'. [This is what is used in the bnf.]

56:20. Change 'binding' to 'specific binding'.

57:1-3. Change to
  A <binding> in a <generic-binding> overrides an inherited binding if
  it has the same <generic-spec> as the inherited one and it satisfies
  the conditions for overriding specified earlier in this subclause.
  Otherwise, it extends the generic interface and shall satisfy the
  requirements specified in 16.2.3.

57:14. Change 'components' to  'non-parent components'.
57:14. Add 'Parent components are excluded from the component order of
   an extensible type.'

58:7. Delete 'and the type parameters'.
[This makes it correct if rather bland. Otherwise, we need to say
something like 'The set of values of a particular derived type with
a particular set of type parameter values is ...']

58:37-39. Change to
C471 At most one <component-spec> shall be provided for a component.
C471a If a <component-spec> is provided for a component, no
   <component-spec> shall be provided for any component with which it
   is inheritance associated.
C472 A <component-spec> shall be provided for a component unless it is
     default initialized or is inheritance-associated with another
     component for which a <component-spec> is provided or which is
     default initialized.
59:20-21. Delete.
[We need to allow for explicit and default initialization of parent
components. The restriction at 59:20-21 is now covered by the constraints.]

60:4. Change 'target' to '<data-target> or <proc-target>' and delete
the internal note. [Reasons are in the internal note.]

61:16. Delete sentence 'Otherwise, ...' [Adds nothing.]

61:24+. Add para:
    Finalization of a nonfinalizable entity has no effect.
61:33. Delete 'whose result is finalizable'.
61:35. Delete 'for a finalizable type'.
61:38. Delete 'whose result is finalizable'.
[The paragraphs of 4.5.10.1 are inconsistent. This seems the easiest fix.]

69:3 Embolden and index "attributes" [since this is the definition].

70:18. Change 'an <entity-decl>' to 'a <char-length>'. [Clearer, since
I think this is what is meant.]

72:26-28. Move the sentence to 72:23+ and change it to
  If it is not an initialization expression, the array bound or type
  parameter value is that of the expression at entry to the procedure and
  is not affected by any redefinition or undefinition of the variables in
  the expression during execution of the procedure.
73:0. Delete internal note.
[See the note for rationalization. By moving the sentence, we catch
the required context without repeating text.]

76:20. After the first sentence add 'For a polymorphic entity, type
compatibility is based on its declared type.'
[I completely misinterpreted this at first, thinking it was based
on the dynamic type.]

81:28. Start a new paragraph after 'pointer.' and change the sentence
that follows to 'If a name that has the EXTERNAL attribute is the name
of a dummy argument, it is a dummy procedure.' [This change is also
needed for the sake of the sentence that follows.]

81:37. Change first 'the' to 'a' and add comma after '<external-stmt>'.

81:39. Delete. [This is very ambiguous. What does 'above' mean (how far
up should I go)? What does 'it' refer to?]

85:6. Before 'in the scoping unit' add 'declared'.
[Note that 'declared' includes implicit declarations, see 94:30-32:
'The data entity is treated as if it were declared in an explicit type
declaration in the outermost scoping unit in which it appears'.]

85:9-10. Make the sentence 'An object ...' into a separate new paragraph.
[Applies to module objects, too.]

85:15. Add 'If declared in the scoping unit of a subprogram, it is shared by
all instances of the subprogram.'.

106:7. Before 'object' add 'declared type of the'.
[Or should it be any accessible type with which the declared
type is compatible?]

111:15. Replace 'those' by 'the corresponding type parameter values'.
[The sets of kind type values can differ.]

111:40. Add 'If it is an expression, subsequent redefinition or
undefinition of any entity in the expression does not affect the type
parameter value.'

114:0+2. Change 'not saved' to 'unsaved'. [Term used at 113:13.]

116:4. Add 'either' before 'allocatable'.  [At first, I read the
sentence as if 'either' appeared before 'a function'.]

116:8. Add 'either' before 'allocatable'.

116:12-13. Change 'actual argument or ... dummy argument' to 'actual
argument associated with an INTENT(OUT) allocatable dummy argument or a
subobject of such an actual argument'.

116:20. Change '<dealloc-opt>' to '<dealloc-opt-list>'.

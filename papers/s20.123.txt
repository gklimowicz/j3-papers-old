#############################################################################
#                                                                           #
#                                X3J3/S20.123                               #
#                                                                           #
#                              20 November 1992                             #
#                                                                           #
#############################################################################

Number Title                                                           Status
------ -----                                                           ------
000000 Minor edits and corrections to ISO/IEC 1539:1991 (E)           2: 3, 21
                                                                   3: 1,2,4-20
000001 Equivalence of Expression Evaluations                              3
000002 Default Main Program Name                                          2
000003 Preconnected Units and UNIT=*                                      2
000004 Blanks in Format Specifications in Free Form Source                2
000005 Namelist Output of Zero Length Character Strings                   3
000006 Procedure Specifications in a Scoping Unit                         2
000007 Duplicate module procedures in interface blocks                    2
000008  - subsumed by 7 -
000009 Generic Interfaces with the Same Name in a Program                 3
000010 Generic Interfaces with the Same Name in a Scoping Unit            3
000011 Multiple Accessible Defined Assignment Interfaces                  1
000012 Type of a Named Constant                                           2
000013 Implicit Environment of an Interface Block                         3
000014 Interface for a Character Function with a Variable Length Result   3
000015 Error in Fourth Constraint for R429                                2
000016 Character Length Specification                                     3
000017 Creation of Entities by Local Names in rename-list                 2
000018 Valid Characters for Indicating Fixed Form Statement Continuation  3
000019 Correctness of Last Example in Section 4.5                         2
000020 References to the Same Derived Type by Different Names             3
000021 References to Different Derived Types with the Same Name           3
000022 Use of Derived Type Name in Host Scoping Unit                      3
000023 Type of a Named Constant in an Internal Procedure                  2
000024 IMPLICIT NONE and the Type of an Internal Procedure Result         3
000025 Resolution of Internal Procedure References                        3
000026 Bounds of Array Expressions                                        2
000027 Requirements for Pointers and Target Association                   1
000028 Precedence of Use or Host Association                              2
000029 Class of a Defined Operator                                        2
000030 Length of Character Literals in Array Constructors                 1
000031 Scope and Type of an implied-DO Variable                           2
000032 Implicit Declaration of a Derived Type                             2
000033 Interface Blocks with the Same Name in a Program                   2
000034  - subsumed by 33 -
000035  - subsumed by 33 -
000036 Pointer to an Assumed-size Array                                   3
000037 Use of Array Sections in Pointer Assignment Statements             3
000038 Same Interface Body in Multiple Generic Interface Blocks           3
000039 Association of a Pointer Actual Argument with a Dummy Argument     2
000040 Allocation of Arrays of Pointers                                   3
000041 Procedure with Target Dummy Argument Requires Explicit Interface   1
000042 KIND parameter value                                               3
000043 List-directed character input                                      3
000044 END Statement and Fixed Form Source                                3
000045 Array Intrinsics with Arrays of Derived-type Arguments             3
000046 RESULT clause for RECURSIVE functions                              3
000047 Automatic data object in initialization expressions                3
000048 Pointer-valued statement functions                                 3
000049 Characteristics of Function Results                                2
000050 Repeat counts on edit descriptors                                  3
000051 On Unambiguous generic procedure references                        2
000052 Expressions in Statement Function Definitions                      2
000053 Optional Intrinsic Function Arguments                              2
000054 Resolving Generic Procedure References                             2
000055 Characteristics of character function results                      2
000056 TRANSFER intrinsic function description                            2
000057 Prohibition against multiple explicit specific interfaces          2
000058 Ambiguous use of "keyword"                                         1
000059 SEQUENCE derived type and component bounds                         3
000060 Statement function argument references                             2
000061 G edit descriptor with "d" = 0                                     3
000062 Statement function constraints                                     3
000063 Interfaces and dummy procedure arguments                           3
000064 SPACING result for 0.0                                             3
000065 Block and Nonblock DO Construct                                    3
000066 Declaration of FUNCTION type                                       3
000067 Output of negative signed zero                                     3
000068 Pointer association status                                         2
000069 I/O implied DO variable                                            2
000070 Characteristics specified by interface bodies                      2
000071 USE association and COMMON block name                              2
000072 Missing constraint for SIZE=                                       2
000073 Description of the MERGE intrinsic function                        1
000074 Meaning of "referenced" in 11.3.2                                  2
000075 Interface blocks in block data                                     1
000076 Attributes, Properties, Characteristics                            1
000077 Misc. questions                                                    1
000078 Intrinsic functions in MODULE specification statements             2
000079 Automatic character and ALLOCATABLE, ... attributes                1
000080 Vector subscripts in masked array assignment statements            2
000081 Pointer actual argument overlap                                    1
000082 Host association, generic name                                     1
000083 Generic Override of Intrinsic Procedure                            1
000084 Change masked array assignment constraint to prose                 2
000085 Nondefault Integer Data Type for UNIT=, ... Specifiers             2
000086 USE and Host Association                                           1
000087    - not assigned -
000088 Common block names and local names                                 1
000089 Errors in the DATA statement description                           1
000090 Subroutine and Function names in nested scopes                     1
000091 Constraint diagnosis for SEQUENCE attribute                        1
000092 Pointer and Storage Association                                    1
000093 Scalar Pointer Function Results                                    1
000094 Varying length function result, implied-DO loop                    2
000095 Varying length function result, implied-DO loop                    2
000096 Definition of "Declaration"                                        1
000097 Specification Expression                                           2
000098 KIND param and list directed I/O                                   2
000099 Generic interfaces                                                 1
000100 ASSOCIATED intrinsic and zero sized objects                        1
000101 Specification statements                                           1
000102 Returned value for INQUIRE POSITION= on an empty file              2
000103 Statement Function with unreferenced dummy argument                2
000104 rounding formatted output                                          2
000105 Parallel Evaluation of Operands and Arguments                      1
000106 Multiple USE of modules; renaming rules                            1
000107 USE renaming of generic and specific interfaces                    2
000108 Referencing disassociated pointers                                 1
000109 Intrinsic Function ASSOCIATED                                      2
000110 Named Constant Shape Specification                                 2
000111 Array constructors in masked assignment statements                 1
000112 Sequence Derived Type External Functions                           1
000113 Ordering of Array Specification and Initialization                 1
000114 Named Constant Attribute Specification                             2
000115 Multiple dummy arguments                                           2
000116 Scoping Units and statement labels                                 2
000117 A clarification request on generic interfaces                      1
000118 Named constructs and host association                              2
000119 Rank of assumed-shape array                                        2
000120 PRESENT intrinsic and host association                             2
000121 ";" As a Statement Separator                                       1


INTRODUCTION

This document is an internal working document of X3J3, the Fortran Technical 
Committee of the American National Standards Association, and contains the 
committee's responses to the defect reports received against ISO/IEC 
1539:1991 (E).

The status of each item in this document is tracked with the STATUS field, 
the six values of which are:

   1. X3J3 consideration in progress

   Submitted via the hardcopy route or via the RFI or RFC email route and
   being processed by X3J3, but as yet no response has been adopted by an
   X3J3 formal vote.

   2. X3J3 draft response

   A response (ANSWER field) has been approved by a formal X3J3 vote but
   not yet approved by subsequent letter ballot.

   3. X3J3 approved; ready for WG5

   Approved by an X3J3 letter ballot. This vote will be taken only on
   items having a STATUS of "X3J3 draft response".

   4. WG5 approved; ready for SC22

   Approved by WG5 for further processing within ISO as a corrigendum
   item. WG5 will advise X3J3 when an item reaches this status.

   5. Returned by WG5 for X3J3 reconsideration

   Returned to X3J3 after the item had been forwarded to WG5 but failed to  
   gain WG5 approval. This status is equivalent to "X3J3 consideration in  
   progress".

   6. Published

   Published as an item in an approved corrigenda report, or incorporated
   into the next draft revision of the standard. In either case the item
   must have previously attained the status of "WG5 approved; ready for
   SC22".

Each entry is categorized by its defect type of which there are three
kinds (these definitions are taken from the X3/SD-2 of February 1992):

   1. Erratum

   The standard may be modified with corrigenda to:

     a) Correct a typographical error.

    b) Insert a missing word, sentence, paragraph, figure, example,
       table, or clause.

     c) Delete a extraneous word, sentence, paragraph, figure, example,
        table, or clause.

   Any such modification of the standard shall not introduce technical
   changes or changes in what it means to conform to the standard.

   2. Amendment

   Any modification of the standard that introduces technical changes or
   changes in what it means to conform to the standard shall be treated as
   an amendment to the standard.

   3. Interpretation

   An interpretation is a clarifying commentary on the standard that does
   not introduce either a technical change or a change in what it means to
   conform to the standard.

The first entry, which has the number 000000, contains details of minor
edits and corrections to the standard. It is updated as required and the
updates are tracked in the HISTORY section.

==============================================================

NUMBER: 000000
TITLE: Minor edits and corrections to ISO/IEC 1539:1991 (E)
KEYWORDS: edits, typos, typographical errors
DEFECT TYPE: Erratum
STATUS: X3J3 draft response: edits 3 (not a minor edit), 21 (new at meeting 
123)
               X3J3 approved; ready for WG5: edits 1, 2, 4-20 (but add 
section numbers)

QUESTION: None.

ANSWER: None.

REFERENCES: ISO/IEC 1539:1991 (E)

EDIT(S): (section numbers to be added to each item)

   1. xvi/1-2 Delete the sentence "The section concludes ... names."

   2. 15/25 Change "of" to "or".

   3. 177/29 Add new sentence "When a statement function is invoked, an
             instance of that statement function is created."

   4. 203/23 Change "1,sh" to "sh,1".

   5. 220/25 Change",[" to "[" (i.e. delete comma).

   6. 255/27 Change "2.4.7" to "2.4.5".

   7. 255/38 Change "2.4.4" to "2.4.3.1.2".

   8. 256/23 Change "2," to "2)".

   9. 257/8 Change "2.4.7" to " 2.4.5".

  10. 258/19 Change "2.4.4" to "2.4.3.1.2".

  11. 258/22 Change "2," to "2)".

  12. 258/25 Change "4," to "4)".

  13. 258/34 Change "2.4.4" to "2.4.3.1.2".

  14. 259/19 Change "3," to "3)".

  15. 259/31 Change "2.4.7" to "2.4.5".

  16. 260/12 Change "2.4.7" to "2.4.5".

  17. 260/14 Change "2.4.7" to "2.4.5".

  18. 260/35 Change "2.4.3.2" to "2.4.3.1".

  19. 261/9  Change "specified in a" to "specified in a TARGET statement or".

  20. 261/30 Change "2.4.5" to "2.4.3.1.1".

  21. 172/41 Change "of the the dummy" to "of the dummy"

SUBMITTED BY: WG5 (Victoria, BC) items 1 through 20.
HISTORY: Items 1 through 20 approved as X3J3/92-152A at meeting 122 by
                                 unanimous consent
                   Indicated items in STATUS approved in ballot 92-182
                   Item 21 added at meeting 123 (92-303, unanimous consent)

--------------------------------------------------------------------------

NUMBER: 000001
TITLE: Equivalence of Expression Evaluations
KEYWORDS: arithmetic expressions, mathematical equivalence, numeric
operations
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: In the following code fragments must the values of D be the same
for all legal values of A, B, and C?

          TEMP=A+B
          D=C+TEMP
and
          D=C+(A+B)

ANSWER: No.

Discussion: Section 7.1.7.3 "Evaluation of numeric operations", specifies
that processors may evaluate any mathematically equivalent expression and
notes, for example, that X+Y can be evaluated as Y+X.  Thus, the
statements in the question could legitimately be evaluated as:

          TEMP=A+B
          D=C+TEMP
and
          D=C+(B+A)

Consequently, there is no requirement that the computational result be the
same.

REFERENCE: ISO/IEC 1539:1991 (E) section 7.1.7.3

EDIT(S): None.

SUBMITTED BY: J.C.Adams 119-JCA-2 (119.002)

HISTORY: 119-RL-1 (119.047)
         92-044   (S20.120A)
         92-104   (Interpretation)
         Approved as 92-147 at meeting 122 by a vote of 21-1
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000002
TITLE: Default Main Program Name 
KEYWORDS: main program, default name
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Some implementations of Fortran supply a default PROGRAM 
statement and program name when it is omitted from the main program. If
the default program name conflicts with a global name  in the program is
the processor standard conforming or not? For example:

          COMMON /MAIN/ A(1000)
          READ *,N
          CALL SUB(N)
          END

          SUBROUTINE SUB(N)
          COMMON /MAIN/ A(1000)
          DO 100 I=1,N
            A(I)=0.0
   100    CONTINUE
          END

If a processor supplies a PROGRAM statement with a default name MAIN, 
this will conflict with the common block name MAIN. Is such a processor 
standard conforming?

If the processor supplied a name which could never conflict with a 
Fortran name, would it be standard conforming? Would the processor in 
the example above be standard conforming if it used $MAIN, for 
example, instead of MAIN?

ANSWER: This situation is covered by the third paragraph of both section 
1.4 of ANSI X3.9-1978 and section C.11.1 of  ISO/IEC 1539:1991. 
Specifically, section 1.4, item (1), of ISO/IEC 1539:1991 states:

     A processor conforms to this International Standard if: 
(1) It executes any standard-conforming  program in a manner that fulfills
     the interpretations prescribed herein, subject to any limits that the  
     processor may impose on the size and complexity of the program.

If, as in the example provided, the processor supplies a PROGRAM 
statement with a symbolic name that conflicts with 
another global name in the program such that the program fails to 
execute, then the processor does not conform to the standard. The 
processor may supply a default name which does not conflict with another 
global name and be standard conforming.

REFERENCES: ISO/IEC 1539:1991 (E) section C.11.1
            ANSI X3.9-1978 section 1.4 (page 1-2, lines 25-27)

EDIT(S): None.

SUBMITTED BY: A. D. Tait, 117-ADT-5 (117.035), 118-ADT-3 (118.045)
HISTORY: 119-ADT-1 (119.012), 119-RL-2 (119.048)
         X3J3 draft response at meeting 120

-----------------------------------------------------------------------

NUMBER: 000003
TITLE: Preconnected Units and UNIT=* 
KEYWORDS: preconnected units, identifying a unit, UNIT=*
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is a processor which associates preconnected units with the 
files identified by the * in READ and WRITE statements standard 
conforming?

ANSWER: Yes.

Discussion: This situation is covered by both section 12.9.2 of ANSI X3.9-
1978 and section 9.3 of ISO/IEC 1539:1991. These sections state that the 
asterisk identifies a particular processor-determined unit which is the same 
for a PRINT statement and a WRITE statement which contains an asterisk. The 
processor-determined unit is different for a READ statement which 
contains an asterisk.

REFERENCES: ISO/IEC 1539:1991 (E) sections 9.3 & 9.4.4.2 
            ANSI X3.9-1978 section 12.9.2

EDIT(S): None.

SUBMITTED BY: A. D. Tait, 118-ADT-2 (118.024)
HISTORY: Approved as 119-ADT-2 (119.013)

-----------------------------------------------------------------------

NUMBER: 000004
TITLE: Blanks in Format Specifications in Free Form Source
KEYWORDS: free form source, format specification, blanks
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Is the following format specification valid in free form source?

                 FORMAT (B  N)

ANSWER: Yes.

Discussion: Sections of Fortran 90 are not consistent.

   3.3.1: In free form, blank characters must not appear within lexical
          tokens other than in a character context.

      and

          A blank must be used to separate names, constants, or labels
          from adjacent keywords, names, constants, ...

  10.1.1: Additional blank characters may appear at any point within the
          format specification, with no effect on the interpretation of
          the format specification, except within a character string
          edit descriptor.

It can be seen that the text in chapter 3 does not consider edit
descriptors.  The text will be revised so that:

     -- edit descriptors are not in the category "keywords"
        and need not be delimited by blanks.

     -- blanks are allowed in edit descriptors.

Note that the first edit below depends on a change made in 
S20 item 58 which moves the line from section 3.2.1 to 2.5.2

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.3.1, 10.1.1

EDIT(S): 

   1. Section 2.5.2 following the sentence "Keywords appear ... through
      12." add the following:

      "Note that in addition to keywords, upper-case letters may also
       appear in various other lexical tokens.  Examples include operators
       such as .EQ., edit descriptors such as BN or Iw[.m],
       and literal constants such as B'digit[digit]...'."

   2. Section 3.2 page 19 last sentence [19:35-36]
      insert ", edit descriptors" following "... , labels".

   3. Section 3.3.1 p22 2nd pp [22:6]
      change "... character context."
      to "... character context or in a format specification."

SUBMITTED BY: J.T. Martin 119-JTM-2 (119.015)

HISTORY: 119-JTM-2
         119-RPK-1
         X3J3/92-044               S20.120, number 4
         X3J3/92-075
         X3J3/92-145               Draft Interpretation by CIO, withdrawn
         Approved as X3J3/92-176 at meeting 122 by unanimous consent

--------------------------------------------------------------------------

NUMBER: 000005
TITLE: Namelist Output of Zero Length Character Strings 
KEYWORDS: namelist output, zero length, character string
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Given the program:

          PROGRAM P
            CHARACTER*0 CH
            NAMELIST/OUT/CH
            OPEN(UNIT=8,DELIM='NONE')
            WRITE(UNIT=8,NML=OUT)
          END

The namelist output record would be:

          &OUT CH= /

Does not this conflict with the statement in section 10.9.2.2 that:

          A null value is not produced by namelist formatting.

ANSWER: No.

Discussion: Although the output produced by this program appears to 
contain a null value (to namelist input), actually a zero-length 
character string was written by the namelist output statement. Note that 
this is different from a null value (section 10.9.1.4) which has no 
meaning on output. The statement:

          A null value is not produced by namelist formatting.

indicates that since all namelist group objects have a value, that value 
(in this case a zero-length string) is output.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.9.1.4, & 10.9.2.2,

EDIT(S): None.

SUBMITTED BY: J. T. Martin, 119-JTM-3 (119.016)
HISTORY: 119-RPK-2 (119.064), & 119-JTM-6 (119.041)
                   Approved in ballot 92-182

-----------------------------------------------------------------------

NUMBER: 000006
TITLE: Procedure Specifications in a Scoping Unit 
KEYWORDS: procedure specification, scoping unit, interface body
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Which of the following procedure related specifications may
jointly occur within a scoping unit?

 a. An interface body for the procedure and the appearance of the
    procedure name in a type statement
 b. A module procedure definition and the appearance of the procedure
    name in a type statement
 c. A module procedure definition and an interface body for the
    procedure
 d. An interface body for the procedure and the appearance of the
    procedure name in an EXTERNAL statement

ANSWER: None of the above.

Discussion: Section 5.1 states the generally applicable constraint:

     An entity must not be given explicitly any attribute more than
     once in a scoping unit.

An interface body provides an explicit interface to the procedure. This
interface includes the characteristics of the procedure: these
characteristics include, for a function, the type of the value returned.
Thus, the interface body is an explicit declaration of the function
result type, and this must not also be declared in a type statement (a).

Similarly, a module procedure definition includes a declaration of its
interface, so its presence precludes the presence of either a type
statement declaring function result (b) or an interface body declaring its
characteristics (c). The case of the module procedure definition and
interface body is also covered by the statement in 12.3.2.1 that

     A procedure must not have more than one explicit specific interface
     in a given scoping unit.

and by the fact that the statement (also in 12.3.2.1):

     An interface body in an interface block specifies an explicit
     interface for an existing external procedure or a dummy
     procedure,

does not include module procedures.

The latter statement in conjunction with the sentence which follows it
also shows that the interface body declares the same attributes as the
EXTERNAL statement, so this combination is similarly prohibited (d).

This last case may be less than obvious. This deficiency is remedied by an
edit to provide an explicit prohibition to cover this case.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1, & 12.3.2.1

EDIT(S): At the end of the fourth paragraph following R1207 in 12.3.2.2,
add

     A name that appears in an EXTERNAL statement must not also appear as
     a specific procedure name in an interface block in the scoping unit.

SUBMITTED BY: S. M. Lammers, 119-SML-1 (119.019) items 1 through 4

HISTORY: Approved as X3J3/92-170 at meeting 122 by unanimous consent
	Revised following letter ballot at meeting 123, in 92-312.
	Revision approved by unanimous consent at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000007
TITLE: Duplicate module procedures in interface blocks
KEYWORDS: module procedure name, interface block, generic
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: May a module procedure name be referenced on more than one
MODULE PROCEDURE statement for a given generic name in a scoping unit,
either in a single interface block or in multiple interface blocks
specifying that generic name?

ANSWER: No.

Discussion: The standard routinely disallows such redundant specifications
within a scoping unit.  The prohibition for this case was inadvertently
overlooked. This deficiency is remedied by the supplied edit.

Example:
          INTERFACE INT_1
            MODULE PROCEDURE FOO, FOO ! second FOO is illegal
            MODULE PROCEDURE FOO1
            MODULE PROCEDURE FOO1     ! FOO1 is illegal here
          END INTERFACE INT_1

          INTERFACE INT_2
            MODULE PROCEDURE FOO2A, FOO2B
          END INTERFACE INT_2

          INTERFACE INT_2
            MODULE PROCEDURE FOO2B, FOO2C !FOO2B is illegal here
          END INTERFACE INT_2

Note, however, that if the two interface blocks for INT_2 were placed in
separate modules, the second appearance of FOO2B would have been
permitted, as would a scoping unit which used both modules.

For example:

        MODULE MOD1
          USE SOME_OTHER_MODULE    ! the source of FOO2B
            INTERFACE INT_2
              MODULE PROCEDURE FOO2A, FOO2B
            END INTERFACE INT_2
           ...
        END MODULE MOD1

        MODULE MOD2
          USE SOME_OTHER_MODULE    ! the source of FOO2B
            INTERFACE INT_2
              MODULE PROCEDURE FOO2B, FOO2C !FOO2B is legal here
            END INTERFACE INT_2
           ...
        END MODULE MOD2

The following USE statements would be allowed:

                            USE MOD1
                            USE MOD2    ! no problem using both modules here

EDIT(S): The following additional constraint should be added to section
12.3.2.1:

     Constraint: A <procedure-name> in a <module-procedure-stmt>
     must not be one which previously had been established to be
     associated with the <generic-spec> of the <interface-block>
     in which it appears, either by a previous appearance in an
     <interface-block> or by use or host association.

REFERENCES: ISO/IEC 1539:1991(E) Section 12.3.2.1

SUBMITTED BY: S.M.Lammers, 119-SML-1 (119.019)

HISTORY: Original interpretation was 120-MBSH-4A (120.096A)

         Modified based on X3J3/92-039 arguments. Adopted because
         this interpretation is more consistent with requirements
         concerning duplication of other specification statements in
         a given scoping unit.

         Interpretation modification presented in X3J3/92-095
         Commented on by N786A from WG5 Victoria meeting in item
         marked 1167/36+.

         Approved as X3J3/92-155A at meeting 122 by unanimous consent.

--------------------------------------------------------------------------

NUMBER: 000008
TITLE: Module Procedure Name in Multiple Interface Blocks 
KEYWORDS: module procedure name, interface block
DEFECT TYPE: Interpretation
STATUS: deleted; subsumed by item 7

QUESTION: May a module procedure name be referred to on more than one 
MODULE PROCEDURE statement in multiple interface blocks specifying the 
same generic name?

ANSWER: 

REFERENCES: 120-MBSH-4A (120.096A)

EDIT(S): None.

SUBMITTED BY: S. M. Lammers, 119-SML-1 (119.019) item 5, question 4

HISTORY: Interpretation questioned in X3J3/92-039
         Resolved by X3J3/92-155A (approved by unanimous consent as the
         response to NUMBER 000007)

-----------------------------------------------------------------------

NUMBER: 000009
TITLE: Generic Interfaces with the Same Name in a Program 
KEYWORDS: generic, interface
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: May two generic interfaces of the same name be accessed by use 
association in the same scoping unit?

Discussion: Can the following program fragment be part of a standard 
conforming program?

          MODULE MOD1
            INTERFACE INT1
              ...
            END INTERFACE
          END MODULE MOD1
          MODULE MOD2
            INTERFACE INT1
              ...
            END INTERFACE
            ...
          END MODULE MOD2
          PROGRAM EXAMPLE_1
            USE MOD1
            USE MOD2

ANSWER: Yes.  As can be seen in section 11.3.2:

If two or more generic interfaces that are accessible in a scoping 
unit ... they are interpreted as a single generic interface.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2 (paragraph 5 after last
            constraint).

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 1

HISTORY: Proposed as 120-MBSH-1A (120.084A) at meeting 120
	 Questioned in X3J3/92-040 (121-JKR-8)
	 Approved as X3J3/92-099
                           Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000010
TITLE: Generic Interfaces with the Same Name in a Scoping Unit 
KEYWORDS: generic, interface, scoping unit
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Are two generic interfaces with the same name allowed in the 
same scoping unit?

Discussion: For example can this program fragment be part of a standard 
conforming program?

          PROGRAM EXAMPLE_1
            INTERFACE INT1
            ...
            END INTERFACE
            ...
            INTERFACE INT1
            ...
            END INTERFACE

ANSWER: Yes.  As can be seen in section 11.3.2:

If two or more generic interfaces that are accessible in a scoping 
unit ... they are interpreted as a single generic interface.


REFERENCES: 120-MBSH-1A (120.084A)

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 2

HISTORY: Proposed as 120-MBSH-1A (120.084A) at meeting 120
	 Questioned in X3J3/92-040 (121-JKR-8)
	 Approved as X3J3/92-100
                           Edit approved in 92-267r at meeting 123

----------------------------------------------------------------------

NUMBER: 000011
TITLE: Multiple Accessible Defined Assignment Interfaces 
KEYWORDS: interfaces, defined assignment
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: Consider the following excerpts from section 14.1.2 [241]:

Excerpt (a): Within a scoping unit, entities in the following classes:

       (1) Named variables that are not statement entities (14.1.3),...,
       generic identifiers, derived types, and namelist group names
       ...
       are local entities of that scoping unit.

Excerpt (b):  Within a scoping unit, a name that identifies a local entity of
	one class must not be used to identify another local entity of
	the same class, except in the case of generic names (12.3.2.1). A
	name that identifies a local entity of one class may be used to
	identify a local entity of another class.

The standard defines both the terms "generic identifier" and "generic
name" in section 12.3.2.1 [168]. "Generic identifier" is defined to
encompass the three concepts of a generic name, a defined operator, r an
equals symbol on a generic specification.  "Generic name" harkens back to
the BNF term for the name that may appear on an interface specification.

The text from section 14 cited in (a) uses the term "Generic identifier"
but the text cited in (b) uses the term "generic name".  Is the intent of
choosing the different words in section 14 to prohibit a program from
containing multiple interface blocks for the same operator and multiple
accessible defined assignment interfaces?

ANSWER: No.

Discussion:  Section 11.3.2 states:

"If two or more generic interfaces that are accessible in a scoping unit
have the same name, the same operator, or are both assignments, they
are interpreted as a single generic interface" 

Thus, two or more interfaces that have the same name, the same operator,
or are assignment interfaces are not only permitted but the interfaces
are considered to be a single generic interface.  The text cited in (b)
above was specifically discussing "names" and hence "generic names" were
singled out.

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.3.2, 12.3.2.1, & 14.1.2

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 3

LAST SIGNIFICANT CHANGE: before meeting 123

HISTORY: 120-MBSH-1A (120.084A)
	revised in response to ballot comments at meeting 123, 
	but no vote taken - withheld for further consideration

-----------------------------------------------------------------------

NUMBER: 000012
TITLE: Type of a Named Constant 
KEYWORDS: named constant, parameter statement
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is the following code fragment valid Fortran 90?
     
          PARAMETER (A=1)
          IMPLICIT INTEGER (A)
     
ANSWER: No.
     
Discussion: In any scoping unit there is only one (possibly null) 
implicit typing map (5.3).  Thus, in the statement (5.2.10),
     
     The named constant must have its type, shape, and any type
     parameters specified either by a previous occurrence in a type
     declaration statement in the same scoping unit, or by the
     implicit typing rules currently in effect for the scoping unit.

the implicit mapping currently in effect for a scoping unit is affected by 
all IMPLICIT statements in the scoping unit even those appearing subsequent 
to PARAMETER statements. A subsequent IMPLICIT statement may specify the 
type of a named constant appearing in a PARAMETER statement, but in that 
case, it must confirm the type of the named constant.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.2.10 & 5.3

EDIT(S): None.

SUBMITTED BY: J. T. Martin, 120-JTM-9 (120.046), question 3 

HISTORY: 120-LJM-5 (120-098)
         Response in X3J3/92-172, must be identical to response to
         NUMBER 000023
	X3J3/92-172, as modified, passed at meeting 122

-----------------------------------------------------------------------

NUMBER: 000013
TITLE: Implicit Mapping of an Interface Block 
KEYWORDS: implicit mapping, interface block
DEFECT TYPE: Amendment
STATUS: X3J3 approved; ready for WG5

QUESTION: Is the implicit mapping of the host inherited by an
interface block?

ANSWER: No.

Discussion:  Unlike other scoping units that are contained within a host
scoping unit, an interface body does not access entities from its host by
host association.  This was intended to allow the initial statements of an
external procedure to be used without modification in an interface body
describing that procedure.  The possibility of there being different
implicit mappings was inadvertently overlooked.  If not corrected, this
would mean that:

          FUNCTION F(X,I)
            F = X**I/I
          END FUNCTION F

would be properly described by:

	INTERFACE
	    	FUNCTION F(X,I)
	    	END FUNCTION F
	END INTERFACE

if the interface block is contained in a host with default implicit
mapping, but not in one containing the statement:

          IMPLICIT INTEGER (A-Z)

The default implicit mapping in an interface body is made consistent with
that in an external procedure by the supplied edit. 

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2 & 5.3

EDIT(S):

   1. In Section 5.3 in the second paragraph after the constraints, in the
      phrase: "the default is the mapping ...", after "default" add "for a
      program unit or an interface body is default integer if the letter
      is I,J, ... , or N and default real otherwise, and the default for
      an internal or module procedure".

      Delete "A program ... O-Z)"

   2. In the example in section 5.3 for FUNCTION FUN in the interface
      block the comment should be changed from:

		! All data entities must
		! be declared explicitly

		to

		! Not all entities need be
		! declared explicitly

   3. In the first example in section 5.3, change "INTEGER FUN, I" to
      be "INTEGER FUN".

SUBMITTED BY: L.R.Rolison 120-LRR-3 (120.028)

HISTORY: Draft response in 92-102A, questioned in N786A of the Victoria
WG5 meeting. Revised edit approved as 92-154A at meeting 122 by a vote of
21-1.  Edit approved in 92-267r at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000014
TITLE: Interface for a Character Function with a Variable Length Result 
KEYWORDS: character function, variable length, interface
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Given a definition of an external function such as the 
following where the function result is variable length, must the 
characteristics of the function be described by an interface block 
accessible to the calling scoping unit?
 
          FUNCTION F(I)
            INTEGER I,N
            CHARACTER*(N) F
            COMMON /B/ N
            ...
          END

ANSWER: Yes.

Discussion: Section 12.3.1.1 states:

     A procedure must have an explicit interface if ... (2) The
     procedure has ... (d) A result whose length type parameter
     value is neither assumed nor constant."

That provision applies to this function. Section 12.3.1 indicates that 
an external procedure has an explicit interface only if an interface
block is provided.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.1 & 12.3.1.1

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 119-LRR-1, part II

HISTORY: 119-KWH-3A (119-70A)
                   Approved in ballot 92-182

-----------------------------------------------------------------------

NUMBER: 000015
TITLE: Error in Fourth Constraint for R429 
KEYWORDS: constraints, R429, <component-decl>
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Should the fourth constraint for R429 also apply to a <char-
selector> in the <type-spec>?

ANSWER: Yes. 

Discussion: A nonconstant specification expression specifies an 
automatic character object that may be declared only in a procedure or 
procedure interface. It was never the intention to permit the 
specification of automatic objects in type definitions. The fifth constraint 
for R429 prohibits the only other automatic object, an automatic array. 
The length specified in a character <type-spec> should be similarly 
restricted.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1, 5.1, 5.1.1.5, & 7.1.6.2

EDIT(S): Replace the fourth constraint after R429 with:

     The character length specified by the <char-length> in a
     <component-decl> or the <char-selector> in a <type-spec> (5.1,
     5.1.1.5) must be a constant specification expression (7.1.6.2)

SUBMITTED BY: J. T. Martin, 119-JTM-7 (119.042) part 1

HISTORY: 119-JTM-11 (119.054)

-----------------------------------------------------------------------

NUMBER: 000016
TITLE: Character Length Specification
KEYWORDS: character length specification, <char-length>, R508
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Is there a similar interaction between a <char-length> 
specified in both a <component-decl> and a <char-selector> as there is 
between a <char-length> specified in both an <entity-decl> and a <char-
selector>?

ANSWER: Yes.

Discussion: It was intended that character declarations in type 
definitions be symmetrical with character object declarations.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1, 5.1, & 5.1.1.5

EDIT(S): Replace the text following the constraints for R508 with:

     The <char-selector> in a CHARACTER <type-spec> and the * <char-
     length> in an <entity-decl> or in a <component-decl> of a type
     definition specify character length. The * <char-length> in an
     <entity-decl> or <component-decl> specifies an individual length
     and overrides the length specified in the <char-selector>, if any.
     If a * <char-length> is not specified in an <entity-decl> or
     <component-decl>, the <length-selector> or <type-param-value>
     specified in the <char-selector> is the character length. If the
     length is not specified in a <char-selector> or a * <char-length>,
     the length is 1.

SUBMITTED BY: J. T. Martin, 119-JTM-7 (119.042) part 2

HISTORY: 119-JTM-12A (119.055A)
                   Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000017
TITLE: Creation of Entities by Local Names in rename-list 
KEYWORDS: local names, data entity
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: 

Does a local-name on a rename-list create a new data-entity?
For example, is the local name Q a new data entity or is Q a rename of
the entity P in the following example?


          MODULE UTIL
            PUBLIC P
            CONTAINS
                 SUBROUTINE P
                 END
          END MODULE UTIL

          MODULE MID1
            USE UTIL, Q=>P  ! is Q a new data entity or 
                                       ! is Q merely a renaming of P
            PUBLIC Q
          END MODULE MID1

          MODULE MID2
            USE UTIL, Q=>P  !another renaming of the same entity P?
            PUBLIC Q
          END MODULE MID2

          SUBROUTINE ENDUSER
            USE MID1
            USE MID2
            CALL Q             !Is this legal? Does it refer to P?
          END SUBROUTINE ENDUSER

ANSWER: 

Multiple renames of the same <use-name> do not constitute 
separate entities. Subsequent appearances of the <local-name> refer to 
the single entity. In the example, Q does not create a new entity.
Thus "CALL Q" in the subroutine is legal.

Discussion:
In section 11.3.2 [158:15-16], the standard states that a local name in
the rename list is a "local name for the entity"  which is intended to mean 
that a new entity is not created.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDIT(S):   None.

SUBMITTED BY: E. A. Johnson, 119-EAJ-1 (119.057)

HISTORY: 120-LF-1 (120.089)
         Response proposed in 92-296, 
         approved by unanimous consent at meeting 123

-----------------------------------------------------------------------

NUMBER: 000018
TITLE: Valid Characters for Indicating Fixed Form Statement Continuation 
KEYWORDS: fixed form source, statement continuation, character set
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Line 3 of the first paragraph of 3.3.2.3 states:

     If character position 6 contains any character other than 
     blank or zero, character positions 7-72 of this line constitute
     a continuation of the preceding noncomment line.

Can the character in character position 6 be a character outside the
Fortran character set (for example, newline)?

ANSWER: No.  Section 3.1.5 specifies where additional characters not in 
the Fortran character set may be used.

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.1 & 3.3.2.3

EDIT(S): None.

SUBMITTED BY: J. C. Adams, 120-JCA-13 (120.013)

HISTORY: Originally proposed as 120-RL-1 (120.058)
	 Approved as X3J3/92-105 at meeting 121 by a vote of 20-0
                           Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000019
TITLE: Correctness of Last Example in Section 4.5 
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is the order of the coordinates correct in the last example of
4.5, considering the type definition of LINE in 4.4.1?

ANSWER: Yes.

Discussion: The line is drawn between points X and Y where the
coordinates of X are X1 and X2 and the coordinates of Y are Y1 and Y2.
Admittedly, this is not the traditional naming scheme for the coordinates
of two points that determine a line. Traditionally, a line would be drawn
between points 1 and 2 where each point had an X and Y coordinate, but  it
is merely a matter of naming. 

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1 & 4.5

EDIT(S): None.

SUBMITTED BY: J. C. Adams, 120-JCA-14 (120.014)

HISTORY: 120-JTM-10 (120.057)

-----------------------------------------------------------------------

NUMBER: 000020
TITLE: References to the Same Derived Type by Different Names 
KEYWORDS: derived types, derived type definition
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: How does changing the name by which a derived type is
referenced affect its use? For example, is the code below standard
conforming and, if so, which specific procedure is invoked by the
reference to GEN?

          MODULE MOD
            TYPE T1
              SEQUENCE
              INTEGER I,J
            END TYPE T1
          END MODULE MOD

          USE MOD, T2=>T1

          TYPE (T2) X

          INTERFACE GEN
            SUBROUTINE SPEC1(A1)
              TYPE T1
                SEQUENCE
                INTEGER I,J
              END TYPE T1
              TYPE (T1) A1
            END SUBROUTINE SPEC1

            SUBROUTINE SPEC2(A2)
              TYPE T2
                SEQUENCE
                INTEGER I,J
              END TYPE T2
              TYPE (T2) A2
            END SUBROUTINE SPEC2
          END INTERFACE GEN

          INTERFACE
            SUBROUTINE SPEC3(A3)
              USE MOD
              TYPE (T1) A3
            END SUBROUTINE SPEC3
          END INTERFACE
          ...
          CALL SPEC3(X)
          CALL GEN(X)
          END

ANSWER: Yes, the code is standard conforming. The reference to GEN 
should invoke the specific procedure SPEC1.

Discussion: The rules governing these questions are stated in 4.4.2. Two
alternatives are provide for entities to have the same type. The first 
alternative applies to the reference to SPEC3:

     Two data entities have the same type if they are declared with
     reference to the same derived-type definition.

In this case, both the actual argument X and the dummy argument A3 are 
declared with reference to the type definition T1 in MOD.

The second alternative applies to the analysis of the procedures in 
generic interface GEN:

     Data entities in different scoping units also have the same type
     if they are declared with reference to different derived-type
     definitions that have the same name, have the SEQUENCE property,
     and have structure components that do not have PRIVATE
     accessibility and agree in order, name, and attributes.

The type definition in SPEC1 agrees in all these respects with the type 
definition in MOD, so X and A1 have the same type. The definition in SPEC2 
has a different name, so X and A2 have different types. Thus the reference to 
GEN invokes SPEC1.

Note the fact that type T1 in MOD was accessible using a different name 
in the main program was irrelevant in both these analyses.

REFERENCES: ISO/IEC 1539:1991 (E) section 4.4.2

EDIT(S): None.

SUBMITTED BY: J. C. Adams, 120-JCA-15 (120.015), 120-JLS-5 (120.023)

HISTORY: 120-KWH-1 (120.078)
                   Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000021
TITLE: References to Different Derived Types with the Same Name 
KEYWORDS: derived type definition
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: In the following example, to which type T1 does the FUNCTION 
statement refer?

          SUBROUTINE FRED
            TYPE T1
              REAL :: X,Y
            END TYPE
            ...
            CONTAINS
              TYPE (T1) FUNCTION WILMA()
                TYPE T1
                  INTEGER I,J
                END TYPE
                ...
              END FUNCTION WILMA
          END SUBROUTINE FRED

ANSWER: It is the type T1 defined in WILMA.

Discussion: Section 12.1.2.2.1 states:

     A name that appears in the scoping unit as (1) a <type-name> in a
     <derived-type-stmt> ... is the name of a local entity and any
     entity of the host that has this as its nongeneric name is
     inaccessible.

Therefore, the type T1 defined in FRED is not accessible in WILMA and 
cannot be the type referenced in the function statement.

Note that it is impossible to reference WILMA because its type T1 is not 
known outside WILMA.  Were the SEQUENCE attribute added to the 
definition of T1 and the component types of the two T1 declarations the 
same so that the two T1 declarations met the requirements of being the 
"same derived types" (4.4.2), then a reference to WILMA would be 
possible.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.2, 5.3, 12.1.2.2.1, &
            12.5.2.2

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-1 (120.019)

HISTORY: Originally answered in 120-KWH-2A (120.083A)
	 Modification requested by X3J3/92-037 (121-JKR-5)
	 Discussed in X3J3/92-049 (121-ADT-9) p7 &
	 X3J3/92-050 (121-ADT-10) p4
	 Approved as X3J3/92-080 at meeting 121 by a vote of 20-0
                           Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000022
TITLE: Use of Derived Type Name in Host Scoping Unit 
KEYWORDS: derived type, <type-name>, host scoping unit, internal procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Consider the following code fragment:

          SUBROUTINE HOST
            TYPE T1
              INTEGER I,J
            END TYPE
            ...
            CONTAINS
              FUNCTION CONTAINED ()
                IMPLICIT TYPE (T1) C
                TYPE T1
                  INTEGER I,J
                END TYPE
              END FUNCTION CONTAINED
          END SUBROUTINE HOST

Is it standard conforming to redefine T1 following the IMPLICIT 
statement that maps to T1?  Does the fact that the function name begins 
with the letter being mapped have any significance in that 
determination?  If an argument named C were added to the dummy argument 
list of CONTAINED, would that have any effect?

ANSWER: The redefinition is permitted.  The fact that the type of 
CONTAINED is implicitly mapped has no significance.  The inclusion of an 
argument named C would have no significance in the redefinition of T1, 
but would render the program unit nonstandard conforming for other
reasons.

Discussion: Section 12.1.2.2.1 states:

     A name that appears in the scoping unit as (1) a <type-name> in a
     <derived-type-stmt> ... is the name of a local entity and any
     entity of the host that has this as its nongeneric name is
     inaccessible.

Therefore the type T1 of HOST is inaccessible in the scoping unit of 
CONTAINED.

The function statement is part of the scoping unit of CONTAINED since 
R1215 says that a function statement is part of its subprogram and it is 
not excluded in item (3) of the definition of a scoping unit in section 
2.2.

It follows that the type must be the local type.

Note that although this is legal, it is not very useful.  Since the type 
of CONTAINED is local to CONTAINED, CONTAINED cannot be referenced.  To 
be useful, when the type of a procedure is of  nonsequence derived type, 
the derived-type definition must be accessible in the scoping unit of 
the procedure by either host association or use association.

If a dummy argument is of nonsequence derived type, this principle is 
mandated in 5.1.1.7:

     A declaration for a nonsequence derived-type dummy argument
     must specify a derived type that is accessed by use association or
     host association because the same definition must be used to
     declare both the actual and dummy arguments to ensure that both
     are of the same derived type.  This restriction does not apply to
     arguments of sequence type (4.4.2).

If the SEQUENCE attribute were present, and the types were the same as
mandated by 4.4.2, then the program would be legal and the 
function with the dummy argument could be referenced in the host.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2, 4.4.2, 12.1.2.2.1, & 
            12.5.2.2

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) cases 1 and 2

HISTORY: Proposed as 120-RPK-1A (120.092A)
	 Questioned by X3J3/92-038 (121-JKR-6)
	 Approved as X3J3/92-097 at meeting 121 by a vote of 20-0
                           Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000023
TITLE: Type of a Named Constant in an Internal Procedure 
KEYWORDS: named constant, internal procedure, parameter statement, host
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Given that an implicit mapping is established for a letter in 
a host scoping unit. An internal procedure of that host scoping unit 
contains a PARAMETER statement which defines a named constant whose name 
begins with the letter in question. This is followed by an IMPLICIT 
statement which defines a different mapping for this letter. Is this 
legal?

ANSWER: No.
     
Discussion: In any scoping unit there is only one (possibly null) 
implicit typing map (5.3).  Thus, in the statement (5.2.10),
     
     The named constant must have its type, shape, and any type
     parameters specified either by a previous occurrence in a type
     declaration statement in the same scoping unit, or by the
     implicit typing rules currently in effect for the scoping unit.

the implicit mapping currently in effect for a scoping unit is affected by 
all IMPLICIT statements in the scoping unit even those appearing subsequent 
to PARAMETER statements. A subsequent IMPLICIT statement may specify the 
type of a named constant appearing in a PARAMETER statement, but in that 
case, it must confirm the type of the named constant.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.3

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 3

HISTORY: 120-LJM-5 (120-093)
         Response in X3J3/92-172, must be identical to response to
         NUMBER 000012

-----------------------------------------------------------------------

NUMBER: 000024
TITLE: IMPLICIT NONE and the Type of a Function Result 
KEYWORDS: IMPLICIT NONE, internal procedure, function result type
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: An internal function contains an IMPLICIT NONE statement and 
does not contain a type specification for the function result. Is this legal?

ANSWER: No.

Discussion: 12.5.2.2 states if the type of the function result is not 
explicitly specified:

     ... it is determined by the implicit typing rules in force within
     the function subprogram.

As the null mapping has been specified for all letters within the 
internal function, the type of the result must be explicitly specified 
within the function.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.2

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 4

HISTORY: 120-RPK-3A (120-094A)
                   Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000025
TITLE: Resolution of Internal Procedure References 
KEYWORDS: host, internal procedure, IMPLICIT NONE, procedure references
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: A host scoping unit contains two internal functions, F1 and 
F2.  If F1 contains an IMPLICIT NONE and references F2, must F1 contain 
an explicit type declaration for F2?

ANSWER: No. In fact if it did contain an explicit type specification for 
F2, F1 would be referencing an external function F2 and not the internal 
one contained in its host scoping unit.

Discussion: 12.3.1 states:

     If a procedure is accessible in a scoping unit, its interface is
     either explicit or implicit in that scoping unit. The interface of
     an internal procedure ... is always explicit in such a scoping unit.

Therefore, the interface of F2 is explicit in the host scoping unit.

The function F2 is established to be specific in the host scoping unit 
by (2)(b) of 14.1.2.4 which states that a procedure name is specific:

     if that scoping unit contains a ... an internal procedure ... with
     that name;

Furthermore, the function name F2 is established to be specific in the 
internal procedure F1 by (2)(f) of 14.1.2.4 which states that a name is
specific:

     if that scoping unit contains no declarations of that name, that
     scoping unit is contained in the host scoping unit, and that name
     is established to be specific in the host scoping unit.

As F2 is established to be specific within F1 by the above, 14.1.2.4.2 
indicates that the F2 referenced by F1 is to the internal function F2 
contained in the host scoping unit.

Note that if F1 contains an explicit declaration for F2, by the rules of 
14.1.2.4, F2 is not established to be either generic or specific in F1.  
Therefore, to resolve the procedure reference, the rules in 14.1.2.4.3 
apply and the reference to F2 within F1 is to an external procedure with 
the name F2.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.1, 14.1.2.4, 14.1.2.4.2 &
            14.1.2.4.3

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 5

HISTORY: Proposed meeting 120 120-RPK-4 (120-095)
                           Questioned X3J3/92-050 (121-ADT-10) page 4
                           X3J3 draft response at meeting 121
                           Approved in ballot 92-182

-----------------------------------------------------------------------

NUMBER: 000026
TITLE: Bounds of Array Expressions 
KEYWORDS: lower bound, upper bound, array expression
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is it the intent of the standard to state that the lower 
bound of an array expression is always 1, and the upper bound is equal 
to the number of elements in a given dimension, for all dimensions?
That is, given:

          REAL,TARGET,DIMENSION(5:10) :: A
          REAL,DIMENSION(:),POINTER :: P

          P => A(5:10)
          PRINT *, LBOUND (P)

the print statement results in the value 1 being written. Previous 
versions of the draft state lower bounds of array expressions were 1.  
Where are those words in the current draft?  

Reading chapter 7 indicates that an expression may be simply 
a primary, and a primary may be an array variable.

Question 1:  Does this mean, given the above declarations that

          P => A
          PRINT *, LBOUND (P)

would also result in the value 1 being written (since A is an array 
expression), or should this print the value 5?

Question 2: Is the intent of the standard that given an array with a 
declared  lower bound other than one, the following relational 
expressions are false?  

            REAL,TARGET,DIMENSION(5:10) :: A
            REAL,DIMENSION(:),POINTER :: P1, P2
            INTERFACE
              SUBROUTINE FRED (X, Y)
                REAL,INTENT (IN),DIMENSION(:) :: X, Y
              END SUBROUTINE
            END INTERFACE
            P1 => A
            P2 => A(:)
            PRINT *, LBOUND (A) .EQ. LBOUND (A(:))
            PRINT *, LBOUND (P1).EQ. LBOUND (P2)
            CALL FRED (A, A(:))
          END

          SUBROUTINE FRED (X, Y)
            REAL,INTENT(IN),DIMENSION(:) :: X, Y
            PRINT *, LBOUND (X) .EQ. LBOUND (Y)
          END SUBROUTINE

Question 3: If the above three print statements result in the values 
.FALSE.,  in what cases does the appearance of an array name constitute 
an array  (carrying with it its dimension attributes), and in what cases 
does it  constitute an expression (implying the lower bound is one)?  
That is, in cases where bounds information may be transmitted (pointer 
assignment and actual argument association at subprogram calls), does 
the appearance of an   array or pointer name *without* a subscript 
following cause the bounds of  the array or pointer to be transmitted, 
and does the appearance of the same array or pointer name followed by a 
subscript triplet with no lower or  upper bound or stride (i.e. (:,:)) 
constitute an expression with a lower  bound of one transmitted?

In summary:

 (a) What are the bounds of an array pointer which has been pointer
     assigned to an array section?
 (b) What are the bounds of an array pointer which has been pointer
     assigned to a whole array?
 (c) What are the bounds of an assumed shape array?
 (d) What are the bounds of a pointer dummy argument?
     
ANSWER: The output of the three example programs would be:
     1) 1
     2) 5
     3) F
        F
        T

 (a) Each lower bound is 1, and each upper bound is the size of the
     corresponding dimension of the array section.
 (b) The declared bounds of the whole array.
 (c) Each lower bound is the declared lower bound of the assumed
     shape array, or, if omitted, 1, and each upper bound is the size
     of the corresponding dimension of the array section plus the
     lower bound minus one.
 (d) The bounds of the target associated with the pointer actual
     argument.
     
Discussion: Cases (a) and (b) are determined from the statements
(5.1.2.4.3),
     
     ...The lower bound of each dimension is the result of the
     LBOUND function (13.13.52) applied to the corresponding
     dimension of the target.  The upper bound of each dimension
     is the result of the UBOUND function (13.13.111) applied to
     the corresponding dimension of the target.
     
Case (d) is determined from these statements in conjunction with the
statement, "If the actual argument is currently associated, the dummy
argument becomes associated with the same target" (12.4.1.1).
     
Case (c) is described in section 5.1.2.4.2.
     
REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1.2.4.2, 5.1.2.4.3, 12.4.1.1,
            13.13.52, & 13.13.111

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-3 (120.021)

HISTORY: 120-LJM-4A (120.088A)

-----------------------------------------------------------------------

NUMBER: 000027
TITLE: Requirements for Pointers and Target Association 
KEYWORDS: POINTER attribute, TARGET attribute, pointer association
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: If PTR has the POINTER attribute and TGT has the TARGET or 
POINTER attribute, under which of the following other conditions are PTR 
and TGT considered to be pointer associated, i.e., under which of the 
following conditions does ASSOCIATED(PTR,TGT) return .TRUE.:
     
   a) PTR and TGT have different types?
   b) PTR and TGT have different type parameters?
   c) PTR and TGT have different ranks?
   d) PTR and TGT have different sizes?
   e) PTR and TGT have different shapes?
   f) PTR and TGT have different bounds?
   g) PTR and TGT refer to the same set of array elements/storage units,
      but not in the same array element order?
   h) PTR and TGT have array elements/storage units whose range of
      memory addresses overlap, but they have no identical array
      elements/storage units?
   i) PTR and TGT have at least one but not all identical array
      elements/storage units and all the identical elements have the
      same subscript order value in both PTR and TGT?
   j) PTR and TGT have at least one but not all identical array
      elements/storage units but not all the identical elements have
      the same subscript order value in both PTR and TGT?
     
ANSWER: ASSOCIATED(PTR,TGT) returns false under any of the above 
conditions except, possibly, (f).  In determining whether a pointer and 
a target are associated, the bounds are not relevant, but the extents 
are.  The extents of each dimension of PTR and TGT must be the same, 
thus their shapes must match which is covered by condition (e).
     
Discussion: There are only three means by which a pointer may become 
pointer associated: via the ALLOCATE statement (6.3.1), via pointer 
assignment (7.5.2), or via argument association (12.4.1.1).  In an 
ALLOCATE statement, the object created inherits its type, type 
parameters, rank, shape, size and bounds from those declared for, or 
specified with, the pointer name.  In a pointer assignment, the type, 
type parameters, and rank of the pointer and target must conform, and 
the shape and size of the target determine those of the pointer.  When a 
pointer actual argument is passed to a pointer dummy argument, the 
pointer dummy argument becomes pointer associated with the same target 
as the pointer actual argument.  In all three of these cases, array 
elements of the pointer and the target correspond with one another in 
array element order.  Thus, since there is no other way for two objects 
to become pointer associated, all these properties must be the same.
     
Note that other forms of association (name association and storage 
association) are distinct from, and orthogonal to, pointer association 
(14.6).
     
REFERENCES: ISO/IEC 1539:1991 (E) 5.1.2.4.3, 6.3.1, 7.5.2, 12.4.1.1, &
            14.6

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-4 (120.022)

LAST SIGNIFICANT CHANGE: Approval rescinded at meeting 123 
		(unanimous consent)

HISTORY: 120-LJM-3A (120.081A)
         Original response proposed at meeting 121
	 Questioned in X3J3/92-061 (121-ADT-9) p9 &
	 X3J3/92-061 (121-ADT-13) item 27
	 Approved as X3J3/92-093A at meeting 121
         Approval rescinded at meeting 123 (unanimous consent)

-----------------------------------------------------------------------

NUMBER: 000028
TITLE: Precedence of Use or Host Association 
KEYWORDS: use association, host association
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is an implicitly typed entity with the same name as a host or 
use associated entity a reference to a local entity or the host or use 
associated entity?

ANSWER: It is a reference to the host or use associated entity. 5.3, 
in the fourth paragraph beginning "Any data entity ...", states that
use or host association takes precedence over implicit typing.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.3

EDIT(S): None.

SUBMITTED BY: J. L. Steidel, 120-JLS-6 (120.024))

HISTORY: 120-RL-3 (120.060)

-----------------------------------------------------------------------

NUMBER: 000029
TITLE: Class of a Defined Operator
KEYWORDS: defined operator, generic identifier, classes of local entities
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Is a defined operator name a generic identifier?  Thus is it
illegal for a defined operator name to be the same as another class 1
entity within the same scoping unit (as defined in 14.1.2)?

ANSWER: "defined operator name" is not a Fortran 90 concept.  
Perhaps the question can be rewritten as:

     Is a defined operator a generic identifier? Thus is it illegal
     for a defined operator to be the same as another class 1 entity
     within the same scoping unit (As defined in 14.1.2)?

Note that Section 14 uses the undefined term "generic operator" and 
therefore the three occurrences are changed to "defined operator".

With these changes:

For the first part of the question:

     Is a defined operator a generic identifier?

the answer is "Yes".  12.3.2.1, page 168, in the paragraph beginning 
"A procedure" states:

     The generic name, defined operator, or ... is a generic identifier.

For the 2nd part of the question:

     Thus is it illegal for a defined operator to be the same as
     another class 1 entity within the same scoping unit (as defined
     in 14.1.2)?

if the entities in 14.1.2 class 1 are divided into two categories and, at
the same time, "generic identifiers" is replaced with "generic name, defined
operator, and equals symbol" (from the definition of generic identifier,
12.3.2.1).  The two categories of interest are then:

 1. named variables that are not statement entities, named constants,
     named constructs, statement functions, internal procedures,
     module procedures, dummy procedures, intrinsic procedures,
     generic names, equals symbols, derived types, and namelist group
     names, and 

 2. defined operators

Note that defined operators (R704 and R724) are syntactically disjoint from 
names (R304) and equals symbols and thus cannot be the same as any entity 
in the first category.  For example, given the expression:

          (.SAM.SAM)

".SAM." is a defined unary operator and "SAM" is a name. That both share
the letters "SAM" has no effect on their interpretations.

The answer, then, for this category, is that it is not possible to
construct a defined operator that is the same as a member of this
category.

For the second category, "defined operators", note that 12.3.2.1.1 states:

      A given defined operator may, as with generic names, apply
      to more than one function, in which case it is generic in exact
      analogy to generic procedure names.

Unfortunately, section 14 contains an error and is not consistent with
section 12.  According to section 14.1.2, in the paragraph 
beginning "Within a scoping unit, a name that":

      Within a scoping unit, a name that identifies a local entity
      of one class must not be used to identify another local entity
      of the same class, except in the case of generic names (12.3.2.1).

This text fails to consider defined operators; an edit is specified,
below, to make defined operators an exact analogy to generic names as
stated in 12.3.2.1.1.

With this correction, the answer for this category is "No".

The term "generic procedure names" in 12.3.2.1.1, above, 
is not consistent with the many references to "generic names". 
This is corrected by edit 2 below.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.3.2.1 & 14.1.2

EDIT(S):
  1. In the last sentence of the next to last section of the Foreword, 
      entitled "Program Units", last line:
      change "generic procedure names" to "generic names"

  2. section 12.3.2.1.1:
      change "A given defined operator may,... generic procedure names."
          to "A given defined operator may,... generic names."

  3. section 14.1.2:
      replace first sentence of third paragraph (beginning "Within a
      scoping unit, a name...) with
          "Within a scoping unit, a generic name or defined operator may
           identify one or more interface blocks (12.3.2.1).  Otherwise,
           within a scoping unit, a name that identifies a local entity
           of one class must not be used to identify another local entity
           of the same class."

   4. section 14.1.2.3:
      in the first sentence of first paragraph change "generic operator"
      to "defined operator"

   5. section 14.1.2.3:
      in the first sentence of second paragraph change "generic operator"
      to "defined operator"

   6. section 14.4
      in the first paragraph change "generic operator" to "defined
      operator"

SUBMITTED BY: J. L. Steidel, 120-JLS-7 (120.025)

HISTORY: 120-RL-2A (120.059A)
         121-LRR-8 Opposed to 121-JKR-2
         121-JKR-2 Opposed to S20/29 (120-59a)
         X3J3/92-106 Interpretation based on 121-JKR-2
         Approved as X3J3/92-148A at meeting 122 by unanimous consent

--------------------------------------------------------------------------

NUMBER: 000030
TITLE: Length of Character Literals in Array Constructors 
KEYWORDS: array constructors, character literals, character length
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: Consider the following example:

          CHARACTER :: NAMES(3)*20
          NAMES = (/'TOM','DICK','HARRY'/)

This is believed to be illegal. From section 4.5, "Construction of array 
values":

Constraint: Each <ac-value> expression in the <array-constructor> 
must have the same type and type parameters.

The length of the string is a type parameter. Thus the array constructor
sample above is illegal because the strings have different lengths.

Consider another example:

          CALL SUB (/TOM,DICK,HARRY/)
          ...
          SUBROUTINE SUB(NAMES)
            CHARACTER :: NAMES(:)*(*)
            WRITE(*,*) LEN(NAMES)
            ...

This also looks illegal.

 1. Must each character string literal constant in an array constructor
    be the same length?
 2. If the answer to 1 is "No", what values are printed by the second
    example?

ANSWER: Each character literal constant in an array constructor must be 
the same length.  Both examples are nonstandard conforming.

Discussion: The reasoning is correct. The length of a character constant 
is a type parameter. Therefore, by the cited constraint, all character 
literal constants in an array constructor must have the same length.

This awkwardness was noted by X3J3, but the committee could not reach 
agreement on an acceptable way to allow character literal constants of 
differing lengths in an array constructor.

REFERENCES: ISO/IEC 1539:1991 (E) section 4.5

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-1 (120.026)

HISTORY: 120-LJO-1 (120.074)

-----------------------------------------------------------------------

 NUMBER: 000031
 TITLE: Overloaded Implied-DO Variable Names
 KEYWORD: implied-Do variable, DATA statement
 DEFECT TYPE: Erratum
 STATUS: X3J3 draft response

 QUESTION: Section 14.1.3. states:

      The name of the variable that appears as the DO variable
      of an implied-DO in a DATA statement or an array
      constructor has a scope of the implied-DO list.  It has
      the type and type parameter that it would have if it were
      the name of a variable in the scoping unit that includes
      the DATA statement or array constructor and this type must
      be integer.

 Is the following in error since J has type character and therefore
 does not have type integer?

       CHARACTER J
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

 Is the following valid because, although J is a named constant, it
 has type integer?

       INTEGER J
       PARAMETER (J=5)
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

 Is the following valid?

       TYPE (ITYPE)
         CHARACTER FIELD1
         INTEGER   FIELD2
       END TYPE
       INTEGER A(10)
       DATA (A(ITYPE), ITYPE=1,10) /10*5/

 If ITYPE were a variable it would have type integer and this would
 be valid.  Does the fact that it is the name of a derived type cause
 a conflict?

 The second sentence cited above appears to allow

       EXTERNAL J
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

 The EXTERNAL statement declares J to be a global name.  If J is a
 subroutine it has no type, so the presence of the EXTERNAL statement
 is irrelevant.  If J were a function, then it must be type integer
 for the presence of J in the DATA statement to be valid.

 Question 1: Is the Fortran 90 standard intentionally extending the
 FORTRAN 77 standard with respect to implied-DO variables in DATA
 statements?  Did the Fortran 90 standard intentionally delete the
 material about COMMON block names in section 18.2.7 of X3.9-1978?

 Question 2: Are the conclusions and interpretations above correct or
 incorrect?  If incorrect, for what specific reasons are they
 incorrect?

 Question 3: Are the examples above standard conforming program
 fragments?  If not, what are the specific reasons?

 Question 4: Are the rules for implied-DO variables in DATA
 statements and array constructors the same?  If they are not exactly
 the same, provide examples which illustrate the differences.

 ANSWER: It was intended that the rules for implied-DO variables be
 similar to those in X3.9-1978.  An edit to section 14.1.3 of
 ISO/IEC 1539:1991 clarifies these rules.

 The answers to your questions are:

  1. Fortran 90 extended the rules for implied-DO variables in
     DATA statements in two ways:

      a) The type of an implied-DO variable must be integer but
         need not be default integer.

      b) FORTRAN 77 allowed the name of the statement entity also
         to be the name of a (scalar) variable or COMMON block 
         (X3.9-1978, section 18.2.7) in (i.e., appearing in) the 
         program unit containing the DATA statement or statement
         function statement.  Fortran 90 allows the name of the 
         statement entity also to be the name of a scalar variable 
         or COMMON block appearing in or accessible from the 
         enclosing scope (section 14.1.3 of ISO/IEC 1539-1991, with
         the changes in the EDITS section, below).

  2. The detailing of the conclusions and justifications given below
     in (3) answer this.

  3. The first example is in error because J is of type character and
     R537 requires integer type.

     The second example is in error.  J is of type integer as
     required by R537, but the edit to section 14.1.3 prohibits the
     name of a statement entity also being the name of a constant in
     the same scoping unit.

     The third example is in error.  The edit to section 14.1.3
     prohibits the name of a of a statement entity also being the
     name of a derived type.

     The fourth example is in error.  The edit to section 14.1.3
     prohibits the name of a statement entity also being the name of
     an external function or subroutine.

  4. The rules for implied-DO variables in DATA statements and in
     array constructors, with respect to typing and scope, are the
     same.

 REFERENCES: ISO/IEC 1539:1991, sections 5.2.9, 6.2.1, 14.1.2, 14.1.3.
             X3.9-1978, section 18.2.7

 EDITS: Replace the last paragraph of section 14.1.3 with the
 following two paragraphs:

      Except for a common block name or a scalar variable name,
      a name that identifies a global entity or local entity of
      class 1 (14.1.2) accessible in the scoping unit of a
      statement must not be the name of a statement entity of
      that statement.  Within the scope of a statement entity,
      another statement entity must not have the same name.

      If the name of a global or local entity accessible in the
      scoping unit of a statement is the same as the name of a
      statement entity in that statement, the name is
      interpreted within the scope of the statement entity as
      that of the statement entity.  Elsewhere in the scoping
      unit, including parts of the statement outside the scope
      of the statement entity, the name is interpreted as that
      of the global or local entity.

 SUBMITTED BY: L. R. ROLISON, 120-LRR-2 (120.027)
 LAST SIGNIFICANT CHANGE: 92-11-10, new response approved at meeting 123
 HISTORY: 1st response - 120-RRR-1A (92.069a) -- all prohibited
          Griffiths' complaint (92.49, p. 11ff)
          2nd response (92.112) -- all allowed
          Email discussion (92.132, #4, 5, 32, 33, 38, 39, 49)
          WG5 suggests F77 restrictions (92.136, N815-7)
          3rd response (92.167a) drafted by DATA subgroup at
            meeting 122; final action deferred due to 2 week rule
          Improved edits suggested by Janice Shepherd (private
            communication)
          4th response (92-229b) approved at meeting 123 (22-1)

-----------------------------------------------------------------------

NUMBER: 000032
TITLE: Implicit Declaration of a Derived Type 
KEYWORDS: derived type, IMPLICIT statement
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is the following program standard conforming?

          IMPLICIT TYPE(T1) (A-D)   ! Note IMPLICIT range is A-D.
          TYPE T1
            SEQUENCE
            CHARACTER*10 NAME
            INTEGER      EMP_NUMBER
          END TYPE T1
          A1%NAME='FRED'            ! A1 is implicitly declared to be
                                                        ! of type T1.
          ...
          CONTAINS
            SUBROUTINE INNER
              IMPLICIT TYPE(T1) (D) ! D now overrides IMPLICIT for D
                                                        ! in host.
              TYPE T1
                INTEGER WIDTH
                INTEGER HEIGHT
              END TYPE T1
              D%WIDTH = 10                 ! No problem here, D is implicitly
                                           ! declared with the T1 that is
                                           ! defined in INNER.
              CALL OUTSIDE(C)              ! Is this an error?
              ...

Is a reference to A1 (declared in the host) from inside INNER permitted 
in this example?

ANSWER:  Yes, the example is standard conforming.

Discussion:  Components of A1 can also be referred to from inside INNER.
While the derived type T1 from the host scoping unit is inaccessible
inside the internal routine INNER, there is no reason why data entities
of this derived type that are accessible cannot be referred to.  The
implicit mapping for the letter C is not specified within the internal
routine INNER.  So, the implicit mapping is that of the host routine.  In
the host routine the letter C is mapped to derived type T1 of the host.
Therefore the variable C is implicitly declared to be of type T1 from the 
host.  The components of the variable C, C%NAME and C%EMP_NUMBER, 
can also be referred to in INNER.  The following edits clarify the standard 
with regard to these questions.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.1.1.7, 5.3, 12.1.2.2.1

EDIT(S):
  1. In the first paragraph of 5.1.1.7, change "is specified" to
     "is explicitly declared".
  2. In paragraph 5 of 5.3 after "provided the mapping is not null.",
     insert the new sentence:
     "Note that the mapping can be to a derived type that is
     inaccessible in the local scope if the derived type is accessible
     to the host scope."
  3. In paragraph 3 of 12.1.2.2.1 after "prior to the DATA statement.",
     insert a new paragraph:
       "If a derived type name of a host is inaccessible, data entities
       of that type or subobjects of such data entities still can be
       accessible."

SUBMITTED BY: L. R. Rolison, 120-LRR-5 (120.030)

LAST SIGNIFICANT CHANGE: 1992 11 10, revised content

HISTORY: 120-TMRE-2 (120.075)
  Questioned by 92-035, 92-049(p14), 92-050(p4)
  Revised at meeting 121 but rejected
  Revised response proposed in 92-280,
  approved by unanimous consent at meeting 123

-----------------------------------------------------------------------

NUMBER: 000033
TITLE: Interface Blocks with the Same Name in a Program
KEYWORDS: generic interface blocks, module, USE statement
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: 
Question 1: In the following program, both interface blocks 
have the same generic name and thus might be considered to be merged 
into a  single generic interface block. Is function F1 (from 
MODULE MOD_1) accessible to the program but FUNCTION F2 (from 
MODULE MOD_2) hidden?

          MODULE MOD_1
             PUBLIC INT_1
             INTERFACE INT_1       ! Generic interface - PUBLIC.
                INTEGER FUNCTION F1(K)
                   INTEGER K
                END FUNCTION
             END INTERFACE 
            ...
          END MODULE MOD_1

          MODULE MOD_2
             PRIVATE INT_1
             INTERFACE INT_1       ! Generic interface, same name - PRIVATE
               INTEGER FUNCTION F2(L)
                 LOGICAL L
               END FUNCTION
             END INTERFACE
          ...
          END MODULE MOD_2
        
          PROGRAM EXAMPLE_1
            USE MOD_1; USE MOD_2      ! Program accesses both modules.
            ...
          END

Question 2: If the following module is added to the above example
and the USE statement in the main program is changed to
"USE MOD_1; USE MOD_2; USE MOD_3", is the resulting program standard 
conforming?

          MODULE MOD_3
            PUBLIC INT_1
            INTERFACE INT_1     ! Generic interface, same name - PUBLIC.
              INTEGER FUNCTION F3(L)
                LOGICAL L
              END FUNCTION
            END INTERFACE
            ...
          END MODULE MOD_3


Question 3: If the program and modules shown above are
altered so that module MOD_2 USEs MOD_1 and the program EXAMPLE_1 only 
USEs MOD_2 directly, is this an example of a standard conforming 
program? If it is standard conforming, does the program have access to 
function F1 but not F2?


ANSWER 1: No, the program is not standard conforming.

ANSWER 2: Yes, the program is standard conforming.

ANSWER 3: Yes, the program is standard conforming.
                   Both F1 and F2 are accessible.

Discussion: Because the name INT_1 is private in the module MOD_2, the 
interface for the function F2 is accessible in the program EXAMPLE_1, 
but NOT the generic name INT_1. Therefore, the two interface blocks are 
NOT merged into a single generic interface block.

The function F1 is, therefore, accessible in the program EXAMPLE_1 by 
either its specific name F1 or the generic name INT_1; the function F2, 
on the other hand is accessible only by its specific name F2.

This shows that the function F2 (from MODULE MOD_2) does not share 
the same generic name, INT_1, as the function F1 (from MODULE MOD_1).

When the example is modified as specified by Question 2, the new module 
MOD_3 defines a new interface block INT_1, which will be 
combined with the identically named interface block from module MOD_1. 
In the program EXAMPLE_1 the generic name INT_1 has the two specific 
names F1 and F3. However, since F2 is not part of the combined generic 
interface block the fact that F2 and F3 have the same dummy argument and 
result characteristics is of no significance, and the program is 
standard conforming.

When the example is modified as specified by Question 3, within module 
MOD_2 the two generic interface blocks are combined
into a single interface block. However, since INT_1 is declared 
to be private within module MOD_2 only the specific names of the 
functions F1 and F2 are accessible to program units using MOD_2.

Therefore, both the function F1 and F2 are accessible within the 
program  EXAMPLE_1, but only by their specific names.


REFERENCES:

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031) 

HISTORY: 120-TMRE-3 (120.076)
         Included into S20 as three items (33-35).  
         Recombined in 92-308.
         Approved by unanimous consent at meeting 123.

-----------------------------------------------------------------------

NUMBER: 000034
TITLE: Interface Blocks with the Same Name in a Program - II
KEYWORDS: generic interface blocks, module, USE statement
DEFECT TYPE: Interpretation
STATUS:  - subsumed by item 33 -

QUESTION: If the following module is added to the example given in 
NUMBER 000033, and the USE statement in the main program is changed to
"USE MOD_1, MOD_2, MOD_3", is the resulting program standard  conforming?

          MODULE MOD_3
            PUBLIC INT_1
            INTERFACE INT_1     ! Generic interface, same name - PUBLIC.
              INTEGER FUNCTION F3(L)
                LOGICAL L
              END FUNCTION
            END INTERFACE
            ...
          END MODULE MOD_3

ANSWER: Yes, but not for the reason implied by the question.

Discussion: The answer in NUMBER 000033 shows that the function
F2 (from MODULE MOD_2) does not share the same generic name, INT_1, as
the function F1 (from MODULE MOD_1).

The new module MOD_3 defines a new interface block INT_1, which will be 
combined with the identically named interface block from module MOD_1. 
In the program EXAMPLE_1 the generic name INT_1 has the two specific 
names F1 and F3. However, since F2 is not part of the combined generic 
interface block the fact that F2 and F3 have the same dummy argument and 
result characteristics is of no significance, and the program is 
standard conforming.

REFERENCES:

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031) Part 2

HISTORY: 120-TMRE-3 (120.076)

-----------------------------------------------------------------------

NUMBER: 000035
TITLE: Interface Blocks with the Same Name in a Program - III
KEYWORDS: generic interface block, module, USE statement
DEFECT TYPE: Interpretation
STATUS:  - subsumed by item 33 -

QUESTION: If the program and modules shown in NUMBER 000033 are
altered so that module MOD_2 USEs MOD_1 and the program EXAMPLE_1 only 
USEs MOD_2 directly, is this an example of a standard conforming 
program? If it is standard conforming, does the program have access to 
function F1 but not F2?

ANSWER: Yes, the program is standard conforming.

Discussion: Within module MOD_2 the two generic interface blocks are 
combined into a single interface block. However, since INT_1 is declared 
to be private within module MOD_2 only the specific names of the 
functions F1 and F2 are accessible to program units using MOD_2 (c.f. 
NUMBER 000033).

Therefore, both the function F1 and F2 are accessible within the program 
EXAMPLE_1, but only by their specific names.

REFERENCES:

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031) Part 3

HISTORY: 120-TMRE-3 (120.076)

-----------------------------------------------------------------------

NUMBER: 000036
TITLE: Pointer to an Assumed-size Array 
KEYWORDS: pointer, assumed-size array, pointer assignment statement
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Is a pointer assignment statement of the form:
     
          PTR => A
     
where A is an assumed-size array, standard conforming?
     
ANSWER: No.  This is prohibited by section 6.2.1, second paragraph, 
second sentence.

REFERENCES: ISO/IEC 1539:1991 (E) section 6.2.1

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-7 (120.032)

HISTORY: 120-RRR-2A (120.087A)
                   Approved in ballot 92-182

-----------------------------------------------------------------------

NUMBER: 000037
TITLE: Use of Array Sections in Pointer Assignment Statements 
KEYWORDS: pointer assignment statement, array sections, pointer
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: If A is an assumed-size array:
     
   Is "PTR => A(:N)" standard conforming?
   Are "PTR => A(:)" and "PTR => A(N:)" standard conforming?
     
ANSWER: "PTR => A(:N)" is standard conforming because A(:N) is a valid 
array section.
     
Forms "PTR => A(:)" and "PTR => A(N:)" are not standard conforming 
because the array sections are prohibited by the second constraint after 
R621.

REFERENCES: ISO/IEC 1539:1991 (E) section 6.2.2

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-7 (120.032)

HISTORY: 120-RRR-2A (120.087A)
                   Approved in ballot 92-182

-----------------------------------------------------------------------

NUMBER: 000038
TITLE: Same Interface Body in Multiple Generic Interface Blocks 
KEYWORDS: interface body, generic interface blocks, scoping unit
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

Part 1. Is the following example standard conforming? That is,
can the same interface body exist in multiple generic interface blocks
that are all accessible from a single scoping unit?

         MODULE MOD_1
           INTERFACE RED
              SUBROUTINE CMN(K)
                INTEGER K
              END SUBROUTINE
              SUBROUTINE S(X)
                REAL X
              END SUBROUTINE
            END INTERFACE
          END MODULE

          MODULE MOD_2
            INTERFACE BLUE
              SUBROUTINE SS(Y)
                REAL Y
              END SUBROUTINE
              SUBROUTINE CMN(K)
                INTEGER K
              END SUBROUTINE
            END INTERFACE
          END MODULE

          PROGRAM EXAMPLE_1
            USE MOD_1;  USE MOD_2
            INTEGER M
            ...
            CALL RED(M)
            ...
            CALL BLUE(M)
            ...
          END PROGRAM

Part 2. If the names are removed from the interface blocks in both
modules, thus making them nongeneric, and the subroutine calls in program
EXAMPLE_1 replaced by "CALL CMN(M)", is the resulting program standard
conforming? That is, may a procedure interface description occur in
multiple nongeneric interface blocks that are accessible to a given
scoping unit and may the program unit reference that procedure?

ANSWER:

Part 1. No. The example is not standard conforming.
Part 2. No.

Discussion: The last sentence of the second paragraph of 12.3.2.1 states

     A procedure must not have more than one explicit specific interface
     in a given scoping unit.

In the example the subroutine CMN has two specific interfaces, one from 
each module in the program EXAMPLE_1 which is forbidden.

The program could be made standard conforming by making the name CMN 
private in one or both modules or by adding a rename or only option to one 
of the USE statements.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.2.1

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-8 (120.033)

HISTORY: Original interpretation in 120-TMRE-4 (120.077)
         Questioned in X3J3/92-131
         Approved as X3J3/92-174 at meeting 122 by unanimous consent
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000039
TITLE: Association of a Pointer Actual Argument with a Dummy Argument 
KEYWORDS: pointer, actual argument, dummy argument, argument association
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: When a pointer is passed as an actual argument, is the intent 
of the standard as follows:  Dereferencing of the pointer is dependent 
on the interface of the called procedure. That is, if the dummy argument 
is known to be a pointer (with matching type, etc.)  then the pointer 
actual argument is NOT dereferenced - the pointer itself is passed. 
Conversely, if the dummy argument is unknown or is known to not be a 
pointer then the pointer dummy argument is dereferenced so that its 
target is passed (possibly through a temporary)?  If yes, please quote 
the text that specifies the meaning of passing a pointer as an actual 
argument.

ANSWER: Section 5.1.2.4.3 indicates that a pointer actual argument may 
be associated with either a pointer dummy argument or a nonpointer 
dummy argument.  The semantics of a pointer actual argument associated 
with a pointer dummy argument are specified in section 12.4.1.1.  When a 
pointer actual argument is associated with a nonpointer dummy argument, 
the actual argument's associated  target object becomes associated with
the dummy argument.  Section 7.1.4.1 states

     If a pointer appears as a primary in an intrinsic operation or a
     defined operation in which it corresponds to a nonpointer dummy
     argument, the associated target object is referenced.

Discussion: The standard does not specify implementation details. A 
valid implementation would allow passing a descriptor when a pointer 
actual argument is associated with a pointer dummy argument and a 
temporary when the dummy argument is a nonpointer. Another valid 
implementation would be to pass a descriptor in both cases. Since the 
notion of referencing and dereferencing pointers is implementation 
dependent, the standard does not use these terms when discussing 
pointers and targets.

The standard does state when a pointer's association status may change 
(pointer assignment, allocation, deallocation, nullification, and 
association with a dummy argument which is a pointer) and several cases 
where a pointer name refers to the associated target object (assignment 
as primary in an expression, and an I/O list). There is also an example 
of a pointer actual argument associated with a nonpointer dummy 
argument in section 12.5.2.9.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1.2.4.3, 7.1.41, 7.5.1.5,
            9.4.4.4, 12.4.1.1, & 12.5.2.9

EDIT(S): None.

SUBMITTED BY: L. R. Rolison, 120-LRR-9 (120.034)

HISTORY: 120-JLS-9 (120.079)

-----------------------------------------------------------------------

NUMBER: 000040
TITLE: Allocation of Arrays of Pointers
KEYWORDS: arrays, pointer allocation, structures
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Consider the following code fragment:

          TYPE DEF
            INTEGER I
            INTEGER, POINTER :: PTR
          END TYPE

          TYPE (DEF) :: STRUCT (5)
          ...
          ALLOCATE (STRUCT%PTR)

Are the following quotations from the standard sufficient to declare 
this code fragment to be nonstandard-conforming?

   o The constraint immediately following R628
     "Each <allocate-object> must be a pointer or an allocatable array." 

   o The second sentence of the fourth constraint after R613
     "A <part-name> to the right of a <part-ref> with nonzero rank must
      not have the POINTER attribute."

ANSWER: The ALLOCATE statement in the example is not permitted by the 
syntax rules and constraints of the standard:

  R625 <allocate-object>     is <variable-name>
                                            or <structure-component>
 
  R614 <structure-component> is <data-ref>

  R612 <data-ref>            is <part-ref>[%<part-ref>]...

  R613 <part-ref>            is <part-name>[(<section-subscript-list>)]

Constraint: A <part-name> to the right of a <part-ref> with nonzero 
rank must not have the POINTER attribute.

REFERENCES: ISO/IEC 1539:1991 (E) sections 6.1.2 and 6.3.1

EDIT(S): None.

SUBMITTED BY: Larry Rolison, X3J3/92-056

HISTORY: Approved as X3J3/92-069 at meeting 121
                   Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000041
TITLE: Procedure with Target Dummy Argument Requires Explicit Interface
KEYWORDS: dummy argument, explicit interface, TARGET attribute
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: If a procedure has a dummy argument that has the TARGET 
attribute, it must have an explicit interface (section 12.3.1.1).  The 
TARGET attribute is defined solely for the purpose of aiding 
optimization (C.5.3).  Why must  such a procedure have an explicit 
interface?

ANSWER: To aid optimization of the subprogram which calls the procedure 
and to aid in error detection.

Discussion: Section 6.3.3.2 states that upon execution of a RETURN or 
END  statement, some pointers declared or accessed in the procedure 
retain their association status.  If a pointer is accessible to both the 
subprogram which references the procedure and the referenced procedure, 
or if the  procedure is a function whose result has the POINTER 
attribute, such a pointer cannot become associated with an actual 
argument during execution of the procedure if the target actual argument 
becomes associated with a  nontarget dummy argument.  If a procedure 
does not have an explicit  interface, a processor may assume any actual 
argument with the target  attribute cannot become associated with such a 
pointer during execution of the procedure.  Requiring an explicit 
interface for a procedure with a  target dummy argument also allows the 
processor to diagnose association of a nontarget actual argument with 
the target dummy argument.

REFERENCES: ISO/IEC 1539:1991 sections 6.3.3.2, 12.3.1.1, and C.5.3 

EDIT(S): None.

SUBMITTED BY: K. Kazumura, X3J3/92-048 (121-ADT-8) page 23
            
LAST SIGNIFICANT CHANGE: Approval rescinded at meeting 123 (uc)

HISTORY: Posted request to f90 interp e-mail
         Approved as X3J3/92-070 meeting 121
         Approval rescinded at meeting 123 (uc)

--------------------------------------------------------------------------

NUMBER: 000042
TITLE: KIND parameter value
KEYWORDS: kind parameter value, representation of constants
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: It is stated in section 5.1.1.2 that:

     An entity declared with type specifier REAL(KIND(0.0)) is of the
     same kind as one declared with the type specifier REAL.

There are similar statements about INTEGER, DOUBLE PRECISION, 
and COMPLEX type specifiers in sections 5.1.1.1, 5.1.1.3, and 5.1.1.4.

In section 5.1.1.2, for example, must the constant be exactly the 
characters "0.0" to cause the declared entity to be the same as the 
default real entity?  Could the result be different if the constant were 
expressed, for example, as "0."?

It appears that the committee chose the value 0 in these statements 
because it exists on every machine on which a Fortran 90 processor will 
be run.  Further, a specific value was chosen so that machine architecture
differences would be factored out.  For example,  KIND(10000000.) might
have the same kind parameter value as default real on one machine but not
on another.

ANSWER: No, the constant need not be exactly "0.0".  The constant "0.0" 
is used only as an example.

Discussion: The KIND intrinsic is defined in section 13.13.51 of the 
standard to return a value equal to the kind type parameter of its 
argument; the argument may be of any intrinsic type.  In section 13.5.5 
it is stated that the value of the argument to this function need not be 
defined.  It is only the kind type of the argument that is relevant.  
Nowhere in the standard is there a restriction that the argument to the 
KIND intrinsic be a constant at all, much less the specific constant 
0.0.  The <kind-selector> is specified in section 5.1, R505 to be a 
<scalar-int-initialization-expr>.  The definition of an <initialization-
expression> is given in section 7.1.6.1, and the restrictions on the 
argument of the KIND intrinsic in an <initialization-expression> are 
detailed in item (6) of that definition.

The question makes the assertion that KIND(10000000.) might not have the 
same kind parameter value as default real on all machines.  This 
assertion is false.  Possibly the requestor believed that a literal real 
constant could assume a kind parameter value based on the number of 
digits in the constant or some other implicit criterion.  This is not 
allowed in Fortran 90.  In section 4.3.1.2, it is explicitly stated that:

     A literal real constant without a kind type parameter is a default
     real constant if it is without an exponent part..."

Similar arguments apply to the corresponding questions about INTEGER, 
DOUBLE PRECISION, and COMPLEX type specifiers.

REFERENCES: ISO/IEC 1539:1991, sections 4.3.1.2, 5.1, 5.1.1, 7.1.6.1,
            13.5.5, & 13.13.51

EDIT(S): None.

SUBMITTED BY: L.R.Rolison, X3J3/92-060

HISTORY: Approved as X3J3/92-084 at meeting 121 by a vote of 19-0
                   Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000043
TITLE: List-directed character input
KEYWORDS: list-directed, input, character, zero length, null value
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: For list directed input of character items, how does the 
standard distinguish between the input of an undelimited zero-length 
character string and a null value?  If the input is a zero-length 
character string, the corresponding list item must be set to blank, 
whereas if the input is a null value, the definition status of the 
corresponding list item must be left unchanged.  However, there appears 
to be no way to distinguish these two possibilities.

ANSWER: The ambiguity between undelimited zero length character values 
and the null value should be resolved by requiring that zero-length 
character values always be delimited in list-directed input. 

Discussion: Several other potential ambiguities with undelimited 
character items in list-directed input were resolved in section 10.8.1 
by requiring delimiters in those cases.  However, the case of a zero-
length string was  omitted from this list.

EDIT(S): The following changes should be made to section 10.8.1,

   1. Add " and" to the end of item (4), and

   2. Add an additional item to the list after item (4):

     "(5)  The character constant contains at least one character,"

REFERENCES:  ISO/IEC 1539:1991, sections 10.8.1, 10.8.1.1

SUBMITTED BY: Richard E. Maine, X3J3/92-087

HISTORY: Approved as X3J3/92-116 at meeting 121 by a vote of 19-0
                   Approved in ballot 92-182

--------------------------------------------------------------------------

NUMBER: 000044
TITLE: END Statement and Fixed Form Source
KEYWORDS: end statement, fixed form source, initial line
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Consider the following:

   1. Section 3.3.2.4 "Fixed Form Statements", page 24, requires that no
      statement, except the program unit END statement, have an initial
      line that appears to be a program unit END statement.

   2. Other statements, for example, <end-function-statement>, R1218 page
      175, may consist of only the keywords "END" or "END FUNCTION".

While these do not conflict, the combined requirements are not obvious 
and complicate the situation for users.  Consider, for example, 
ending an <interface-body> for a function subprogram:

    1.           END            !wrong, appears to be a program unit END

    2.           EN             !END continued to 2nd line. OK
              &       D

    3.           END FUNCTION   !OK in main PROGRAM unit and SUBROUTINE
                                !subprogram, wrong in FUNCTION subprogram

    4.           EN                           !OK
              &       D FUNCTION

    5.           END F                        !OK


    6.           END FUNCTION A   !OK in main program, OK in SUBROUTINE
              &       BC          !subprogram, OK in function if name
                                  !is not "A"

ANSWER:  Section 3.3.2.4 was brought forward from FORTRAN 77 without 
modification for new Fortran 90 constructs.  The resulting usability 
characteristics, as seen in the examples above, are regrettable enough 
that a repair should be made.

REFERENCES: ISO/IEC 1539:1991 (E) section 3.3.2.4

EDIT(S):

In 3.3.2.4 replace the text "and no other statement in  the program unit 
may have an initial line that appears to be a program unit END statement" 
with ". A statement whose initial line appears to be a program unit END 
statement must not be continued."

SUBMITTED BY: J.C.Shepherd, X3J3/92-012, X3J3/92-013, X3J3/92-014

HISTORY: Approved as X3J3/92-088A at meeting 122 by a vote of 24-0
                   Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000045
TITLE: Array Intrinsics with Arrays of Derived-type Arguments
KEYWORDS: array intrinsics, derived-types, operations, interface blocks
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: The intrinsic functions ALLOCATED, ASSOCIATED, LBOUND, UBOUND, 
PRESENT, SHAPE, SIZE, MERGE, PACK, SPREAD, UNPACK, CSHIFT, EOSHIFT, 
TRANSPOSE, RESHAPE, and TRANSFER are documented as accepting arrays of 
any type.  Does this include arrays of derived-type, and if so, does 
this conflict with  section 4.4.5 which states:

     Any operation on derived-type entities or nonintrinsic assignment
     for derived-type entities  must be defined explicitly by a
     function or subroutine and a procedure interface block.

ANSWER: The intrinsics in question can accept arguments which are arrays 
of derived-types.  This does not conflict with section 4.4.5.

Discussion: The term "operation" in section 4.4.5 refers to user defined
unary and binary operations in expressions and nonintrinsic 
assignments.  Such operators are defined by means of interface blocks 
which define operators and nonintrinsic assignment.  Using an object as
an actual argument in a procedure reference is not considered an 
operation on that  object in this sense.

REFERENCES: ISO/IEC 1539:1991 section 4.4.5 and 13.13
            X3J3/92-051 pages 13-14

EDIT(S): None.

SUBMITTED BY: H.Funaki, X3J3/92-051 (121-ADT-11) pp13-14

HISTORY: Posted request to f90 interp e-mail
         Approved as X3J3/92-092A meeting 121 by a vote of 19-0
         Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000046
TITLE: RESULT clause for RECURSIVE functions
KEYWORDS: result clause, recursive functions
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

   1. Does RECURSIVE require RESULT?

   2. Assuming (1), is a <type-spec> permitted on the function name when
      RECURSIVE is present?

ANSWER:  The RESULT clause is not required for all RECURSIVE functions; 
it is required for those that are directly recursive.  That is, the RESULT 
clause is necessary to make the function visible in its own body so that 
direct recursion can take place.

It should be noted that the prohibition against typing the function name 
when a result variable name is specified was not intended to prohibit 
putting the function type into the header.  In other words:

          FUNCTION F() RESULT (FVAR)
          INTEGER FVAR

and

          INTEGER FUNCTION F() RESULT (FVAR)

are both allowed.  The case prohibited is:

          FUNCTION F() RESULT (FVAR)
          INTEGER F

It is possible for both a <type-spec> and RECURSIVE to appear in a 
single function header.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.2

EDIT(S): None.

SUBMITTED BY: L.Meissner, X3J3/92-045 (121-ADT-5) p17.

HISTORY: For discussion see X3J3/92-45 (121-ADT-5) pp 18, 26-27
	 Approved as X3J3/92-101 at meeting 121 by a vote of 20-0
                           Edit approved in 92-267r at meeting 123

-----------------------------------------------------------------------

NUMBER: 000047
TITLE: Automatic data object in initialization expressions
KEYWORDS: automatic data object, initialization expressions
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Can an automatic data object be used as the argument to the 
LEN function in the initialization expression of a PARAMETER statement 
or an item given the PARAMETER attribute?

ANSWER:  It was the intent of the committee to include objects with non
constant lengths in the restrictions on the LEN function in section 
7.1.6.1 (pages 77 and 78).

REFERENCES: ISO/IEC 1539:1991 (E) section 7.1.6.1

EDIT(S):

   1. Section 7.1.6.1, page 77, item (6) change "not assumed or" to
      "not assumed, are not defined by an expression that is not a
      constant expression, and are not"

   2. Section 7.1.6.1, page 78, item (6) change "not assumed or" to
      "not assumed, are not defined by an expression that is not a
      constant expression, and are not"


SUBMITTED BY: 120.042

HISTORY: For discussion see 120.073A and X3J3/92-036 (121-JKR-4)
	 Approved as X3J3/92-107 at meeting 121 by a vote of 20-0
                           Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000048
TITLE: Pointer-valued statement functions
KEYWORDS: statement function, pointer
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Can a statement function be pointer-valued?  There appears to 
be nothing in section 12.5.4 to prohibit this.

ANSWER: No, a statement function cannot be pointer-valued.

Discussion: From section 12.3.1:

     The interface of a statement function is always implicit.

>From section 12.3.1.1:

     A procedure must have an explicit interface if...
               (2)  The procedure has:
                        (e) A result that is a pointer (functions only)

Therefore, a statement function cannot have a result that is a pointer.

REFERENCES: ISO/IEC 1539:1991 sections 12.3.1, 12.3.1.1, 12.5.4

EDIT(S): None.

SUBMITTED BY: L.Meissner, X3J3/92-45 (121-ADT-5) p37

HISTORY: Approved as X3J3/92-108 at meeting 121 by a vote of 19-0
                   Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000049
TITLE: Characteristics of Function Results
KEYWORDS: characteristics, function result, ENTRY, 
                        exact dependence, partially associated
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Given a character function with an ENTRY statement, both results
must have the same characteristics or be scalars without the  POINTER
attribute and have identical length.  Therefore:

          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN,ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

is standard conforming.

Question 1:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=M+N)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

Is the code above standard conforming?

Question 2:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=N+M)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END

Is the code above standard conforming?

Question 3:
          FUNCTION FUN(M)
            CHARACTER (LEN=M+M)::FUN
            CHARACTER (LEN=M*2)::ENT
            ...
            ENTRY ENT(M)
            ...
          END

Is the code above standard conforming?

Question 4: What is the meaning of the phrase "the exact dependence on the 
entities" in section 12.2.2?

ANSWER:  

Answer 1.	Yes
Answer 2.	Yes
Answer 3.	Yes
Answer 4.  The phrase "the exact dependence on the entities" in section 
12.2.2 refers to run-time values, which may or may not be known at compile-
time.  The requirement "must...be of type default character with 
identical length" is a requirement for a standard-conforming program.  
Since it is not a constraint, a processor is not required to detect a 
violation of this requirement even if the lengths are known at compile-
time, though it may do so.

Discussion: 
The examples in the first three questions are examples of totally
associated variables, and not partially associated, so their lengths
must be identical at run-time.  Therefore, examples in questions 1-3 are
standard conforming.  During consideration of the fourth question, it
became apparent that the text in the standard on partial association
(14.6.3.3) needs correction.

Given the definition of "partially associated" in section 14.6.3.3:

"Two scalar entities are partially associated if they are 
associated without being totally associated."

The last sentence before the first example in 14.6.3.3 [168:41] 

     For character entities, partial association may occur only through
     argument association, or the use of COMMON, EQUIVALENCE, or ENTRY
     statements.

is incorrect.  There is no way that partial association for character 
entities may occur through the use of an ENTRY statement.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.2.2 & 14.6.3.3

EDIT(S):In section 14.6.3.3 change the sentence (last two lines of page 248) 
from

         "For character entities, partial association may occur only  
          through COMMON, EQUIVALENCE, or ENTRY statements"
to
	     "For character entities, partial association may occur only
          through COMMON or EQUIVALENCE statements".

SUBMITTED BY: Y.Yoshida, X3J3/92-051 (121-ADT-11) pp11-13

LAST SIGNIFICANT CHANGE: 1992 11 12

HISTORY: Approved as X3J3/92-109A at meeting 121 by a vote of 19-0
         resubmitted in 92-313 in response to ballot comments and
         approved by unanimous consent at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000050
TITLE: Repeat counts on edit descriptors
KEYWORDS: edit descriptor, repeat count
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Is the repeat specification part of the edit descriptor?

Discussion: In section 10.1.1 the second constraint states that the 
comma separating the <format-items> in a <format-item-list> is optional 
between certain combinations of edit descriptors.

In section 10.2 a format-item is defined as, amongst other things, 
"[r]<data-edit-desc>" and in 10.2.1 an edit-descriptor can be a data-
edit-desc. However, <data-edit-desc> does not contain the repeat count. 
This implies that:

    100   FORMAT(1PE20.10)       !is legal
    200   FORMAT(1P3E20.10)      !is not legal
    300   FORMAT(1P,3E20.10)     !is legal

ANSWER: The repeat count is not part of any edit descriptor except the 
"[r]/" edit descriptor.

The comments in the examples are correct.

REFERENCES: ISO/IEC 1539:1991, sections 10.1.1, 10.2, & 10.2.1 

EDIT(S): None.

SUBMITTED BY: A.D.Tait, X3J3/92-041 (121-ADT-1)

HISTORY:  X3J3/92-041, X3J3/92-042

This problem appears to stem from an incompatibility between FORTRAN 66 
and FORTRAN 77. In FORTRAN 66 a FORMAT statement is of the form: 

               FORMAT(list)

where the list consists of a series of field descriptors separated by 
field separators and optionally preceded and succeeded by slashes. The 
field descriptors for real or double precision values consisted of the 
now familiar Dw.d, Ew.d, Fw.d, and Gw.d edit descriptors (a term 
introduced in FORTRAN 77) preceded by an optional scale factor and 
repeat count. For example, in FORTRAN 66 a valid field descriptor is 
1P3E17.10, where 1P is the scale factor, 3 the repeat count for a field 
containing 10 digits in the fractional part of the number and having a E 
exponent.

In FORTRAN 77 the scale factor is an edit descriptor and thus is a list 
element in the format specification. While FORTRAN 77 specifies places 
where the commas separating list elements in a format specification are 
optional, it fails to make a comma between the scale factor and an 
immediately succeeding repeated D, E, F, or G edit descriptor optional. 
This situation has been carried over to Fortran 90. Thus: 

    100   FORMAT(1PE20.10)   !is legal in F66, F77, and F90
    200   FORMAT(1P3E20.10)  !is legal in F66, and illegal in F77 & F90
    300   FORMAT(1P,3E20.10) !is illegal in F66, and legal in F77 & F90

Edit approved in 92-267r at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000051
TITLE: On Unambiguous generic procedure references
KEYWORDS: generic procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Should the rules in 14.1.2.3 include a rule that uses the fact
that a dummy argument is either a subroutine or a function to disambiguate
a generic procedure reference?  For example, such a rule could be in section 
14.1.2.3, in the sentence that is preceded by "(1)"U, after "with a different 
type" adding "present as a subroutine instead of a function".

ANSWER: No.

The intent of the committee was to keep the rules as simple as possible in
order that they would be easy to understand and to use.  It is not always
possible for the processor to tell whether an actual argument that is a
procedure is a subroutine or an implicitly typed function.

REFERENCES: ISO/IEC 1539:1991 (E) section 14.1.2.3

EDIT(S): None.

SUBMITTED BY: John Reid, SC22/WG5 N786A

HISTORY: X3J3/92-017 at meeting 121 - RFI: generic interfaces and dummy
         	procedure arguments
	Approved as X3J3/92-151 at meeting 122 by a vote of 25-0

--------------------------------------------------------------------------

NUMBER: 000052
TITLE: Expressions in Statement Function Definitions
KEYWORDS: statement functions, array, variable, intrinsic operator,
          expression
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Section 12.5.4 appears to prohibit whole array names appearing
as actual arguments to functions within the <scalar-expr> of a statement
function.  The first constraint states:

     The <scalar-expr> may be composed only of constants (literal and
     named), references to scalar variables and array elements, references
     to functions and function dummy procedures, and intrinsic operators.

A defined operator may be an extended intrinsic operator, as well as a
defined unary  or binary operator.

Question 1: Is the legal FORTRAN 77 program fragment,

          EXTERNAL FCN
          REAL A(2)
          STFN(X) = FCN(A) + X

where FCN is some function and STFN is a statement function, a legal
Fortran 90 program fragment?

Question 2: Is it intended that a defined operator which is an extended
intrinsic  operator be allowed in a statement function definition but
other defined operators  not be allowed?

ANSWER:  The intent is that the program fragment in question one should be
a valid  Fortran 90 program fragment, and that no defined operators be
allowed in a statement function definition. The standard is in error. The
edits below should be applied to correct the standard.

Discussion:  The intent of the standard was to retain the FORTRAN 77
definition of  statement functions without extending it to include defined
operators or array  expressions.  In FORTRAN 77, "expression" and
"variable" referred only to scalar expressions and variables; there were
no defined operators.  In Fortran 90 these  terms also refer to array
expressions and arrays.  The Fortran 90 definition of  statement functions
was intended to prohibit array expressions but overlooked the use of an
array name as an actual argument to a function in the definition of a
statement function.  

REFERENCES: ISO/IEC 1539:1991 section 12.5.4

EDIT(S):  Section 12.5.4

   1. First constraint, first sentence
      change "references to scalar variables and array elements"
      to     "references to variables"

      change "intrinsic operators"
      to     "intrinsic operations"

      after first sentence add

      If <scalar-expr> contains a reference to a function or a
      function dummy procedure the reference must not require 
      an explicit interface, the function must not require an explicit
      interface or be a transformational intrinsic, and the result
      must be scalar.  If an argument to a function or a function
      dummy procedure is array valued, it must be an array name."

   2. Second constraint, third sentence
      change "scalar variable, array element"
      to     "variable"

   3. Fifth constraint, first sentence delete second word ("scalar")

SUBMITTED BY: A. D. Tait X3J3/92-064 item # 13 points to B. Smith e-mail
              in X3J3/92-045 pp. 50-52 

HISTORY: Approved as X3J3/92-153A at meeting 122 by a vote of 17-2

--------------------------------------------------------------------------

NUMBER: 000053
TITLE: Optional Intrinsic Function Arguments
KEYWORDS: intrinsic functions, optional arguments
DEFECT TYPE: Amendment
STATUS: X3J3 draft response

QUESTION: Should constraining text be added to the description of

               optional argument   Y    in CMPLX, and
               optional argument   BACK in INDEX, and
               optional argument   SIZE in ISHFTC, and
               optional argument   A3,... in MAX, and
               optional argument   A3,... in MIN, and
               optional argument   BACK in SCAN, and
               optional argument   BACK in VERIFY

to state that the argument must not be an optional argument of an invoking
procedure?

ANSWER: In principle yes; however it is more appropriate to add an
additional restriction on dummy arguments not present in section 12.5.2.8.

Discussion: The standard contains numerous restrictions intended to ensure
that the rank of a given expression never changes. The case of elemental
functions with optional arguments was inadvertently overlooked.

Consider the following subprogram:

	  SUBROUTINE SUB (A,B,C)
	    INTEGER :: A ,B
	    INTEGER, OPTIONAL :: C (:)
	    PRINT *, MAX (A, B, C)
	  END

When C is present, the result of the elemental function MAX, is an array
of the same shape as C. However, if SUB were to be called with the third
argument omitted, the result would be a scalar. The supplied edit remedies
this deficiency.

REFERENCES: ISO/IEC 1539:1991 (E) 12.5.2.8, 13.13.20, 13.13.46, 13.13.50,
            13.13.52, 13.13.63, 13.13.68, 13.13.91, 13.13.111, 13.13.113.

EDIT(S):

   1. Add the following point to the numbered list in section 12.5.2.8:

     (5) If it is an array, it must not be supplied as an actual
	 argument to an elemental procedure unless an array of the same
	 rank is supplied as an actual argument corresponding to a
	 nonoptional dummy argument of that elemental procedure.

   2. In the paragraph following the numbered list, replace "It" with
      "Except as noted in (5) above, it"

SUBMITTED BY: response to X3J3/92-058 (121-LRR-5)

HISTORY: Submitted as question in 92-058, draft response prepared in
	 X3J3/92-094, and in N815A of the WG5 Victoria meeting
	 based on John Reid's paper, N786A.
	X3J3/92-156r approved at meeting 122

--------------------------------------------------------------------------

NUMBER: 000054
TITLE: Resolving Generic Procedure References
KEYWORDS: generic, interface, intrinsic
DEFECT TYPE: Interpretation
Status: X3J3 draft response

QUESTION: Consider the following code fragment:

          PROGRAM HOST
            DIMENSION ABS(10)
            ...
            CONTAINS
               SUBROUTINE SUB()
                 INTERFACE ABS
                   FUNCTION IA1(I)
                     INTEGER IA1, I
                   END FUNCTION
                 END INTERFACE
                 R = ABS(1.5)

Do the rules for resolving references to names established to be generic
(14.1.2.4.1) imply that R will be assigned the value 1.5 as the result of
invoking the intrinsic ABS?

ANSWER: Yes.

Discussion: ABS is established to be generic in the scope of subroutine
SUB (14.1.2.4 item 1(a)).  The rules in section 14.1.2.4.1 can be used to
resolve the procedure reference. Rule (1) in 14.1.2.4.1 does not apply, as
the reference is not consistent with any specific interface in the
interface block with the name ABS.  Rule (2) does not apply as ABS does
not appear in an INTRINSIC statement.  Rule (3) does not apply as ABS is
not established to be generic in the host scope.  Therefore, rule (4) is
applied and the reference is resolved to the generic intrinsic procedure
ABS.

REFERENCES: ISO/IEC 1539:1991(E) Sections 14.1.2.4 and 14.1.2.4.1

SUBMITTED BY: J.C. Shepherd

HISTORY: One of the questions raised in X3J3/92-048 pg 29-30, 34-40,
         	51, 52 and X3J3/92-052 pg 1-3.
       	Initially drafted as X3J3/92-119
	X3J3/92-157 approved at meeting 122

--------------------------------------------------------------------------

NUMBER: 000055
TITLE: Characteristics of character function results
KEYWORDS: character function, function result
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  In section 12.5.2.5 the second paragraph after the constraints
contains the text: "Otherwise, they are storage associated and must all
be scalars without the POINTER attribute and all be of type default
character with identical length". Is some of this text redundant?

ANSWER:  Yes.

Discussion: The phrase referring to "identical length" was meant to
include the FORTRAN 77  character storage association case. FORTRAN 77
requires either that they all  be of assumed length or all be of the same
constant length; both are included as characteristics that agree in
section 12.5.2.5 in the second paragraph after the constraints that starts
with "If the ENTRY".  The phrase is redundant and is causing confusion.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.5.

EDIT(S):  In Section 12.5.2.5 in the sentence that starts: "Otherwise,
they ... " delete: "all be scalars ... length or".

SUBMITTED BY: J.K.Reid in N786A at the WG5 Victoria Meeting, July 1992.

HISTORY: Drafted at the WG5 Victoria Meeting July, 1992 and submitted
        	 to X3J3 at meeting 122
	X3J3/92-158 approved at meeting 122

--------------------------------------------------------------------------

NUMBER: 000056
TITLE: TRANSFER intrinsic function description
KEYWORDS: Intrinsic functions, examples
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Should the text of Case (iii) under Examples in the TRANSFER
intrinsic function be corrected so the example reads:

     Case (iii): TRANSFER((/1.1,2.2,3.3/),(/ (0.0,0.0) /),1) is a complex
                 rank-one array of length one whose sole element has the
                 value (1.1,2.2)."


ANSWER: No.

Discussion: The current format of the example, 1.1+2.2i, is valid
mathematical notation for complex type.

REFERENCES: ISO/IEC 1539:1991 (E) Section 13.13.108.

EDIT(S): None.

SUBMITTED BY: Larry Rolison in X3J3/92-059  (121-LRR-6)

LAST SIGNIFICANT CHANGE: 1992 11 11, opposite response

HISTORY: Submitted as a request in X3J3/92-059
         Draft response first prepared in X3J3/92-091 
         Subsequent draft in X3J3/92-159 - rejected at meetings 121 and 122
         Revised response proposed in X3J3/92-294 -
         Approved by unanimous consent at meeting 123

--------------------------------------------------------------------------

NUMBER: 000057
TITLE: Prohibition against multiple explicit specific interfaces
KEYWORDS: specific interfaces, interface body, interface block
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  
What is the meaning and/or intent of the following sentence in 12.3.2.1? 

     A procedure must not have more than one explicit specific
     interface in a given scoping unit."

Multiple SPECIFIC interfaces can not be produced by the existence of
interface blocks because the definition of an interface body states
that it only specifies an EXPLICIT interface, not a SPECIFIC interface. 
If the statement in 12.3.2.1: "An external or module subprogram
definition specifies a specific interface for the procedures defined in
that subprogram", only external or module subprograms have specific
interfaces and the specific interfaces are only specified by the text of
the subprogram itself.

Could an example of code be provided that is prohibited by the 
statement "a procedure must not have more than one explicit specific 
interface in a given scoping unit" in 12.3.2.1 and that would not be 
prohibited by some other provision of ISO/IEC 1539:1991?

ANSWER: The statement in the question that "Multiple SPECIFIC interfaces 
can not be produced by the existence of interface blocks" is incorrect. 
An example follows.

Discussion:  The paragraph following the constraints, in 12.3.2.1 is
concerned with "specific interfaces" and it was intended to be understood 
from the context in that discussion that the interface specified by an 
interface body should be both specific and explicit.  See also 14.1.2.4, (2), 
(a) which shows that it was intended that an interface body define a specific 
interface.  The intention was to disallow the same information being provided 
twice,as for other specifications. An edit is supplied to make this clearer. 

An example which illustrates what is prohibited follows:

Example:
          MODULE MOD
            INTERFACE
              SUBROUTINE SUB(I,J)
                INTEGER I,J
              END SUBROUTINE
              SUBROUTINE SUB(M,N)   ! duplication of SUB is illegal
                INTEGER M,N
              END SUBROUTINE
            END INTERFACE
          END MODULE

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.2. 

EDIT(S): Section 12.3.2.1, the sentence that begins "An interface body..."
change "explicit interface" to "explicit specific interface".

SUBMITTED BY: L. Rolison

LAST SIGNIFICANT CHANGE: 1992 11 12

HISTORY: 120.035, 120.090
         Approved as X3J3/92-162A at meeting 122 by unanimous consent
	 Revised following letter ballot at meeting 123 in 92-314 to
	 correct transcription errors in the recording of what was
	 contained in 92-162A.

--------------------------------------------------------------------------

NUMBER: 000058
TITLE: Ambiguous use of "keyword"
KEYWORDS: keyword, argument keyword
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION: Is the use of "keyword" in 12.4.1 page 172 1st paragraph
consistent with the definition of "keyword" in 3.2.1, page 19? Is the
definition of keyword in 3.2.1 consistent with the two definitions of
keyword in 2.5.2 page 16? In 13.10 page 188 is "keyword" the correct term
(or should it be "argument keyword")?

ANSWER:  For each question, the answer is "NO".

There are two different definitions of "keyword", 2.5.2 page 16 and 3.2.1
page 19.  Neither definition is complete.

The edits below combine these two definitions into one and consistently
use "argument keyword" where appropriate.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.5.2, 3.2.1, 12.4.1,& 13.10

EDIT(S):

   1. Page 5, section 1.5.3, (3) [5:9]
      delete "keyword actual arguments and"
      rationale: these are not specifiers and -spec is not used with them.

   2. Page 16, section 2.5.2, 1st pp, 1st occurrence [16:3]
      change "statement keyword"
              --------- -------
      to "statement keyword (often abbreviated to keyword)"
          --------- -------                       -------
      rationale: define "keyword", in a style similar to "object" in
      2.4.3.1.

   3. Page 16, section 2.5.2, 1st pp, end of [16:5]
      add "Keywords appear as upper-case words in the syntax rules
     in Sections 4 through 12".

   4. Page 16, section 2.5.2, 2nd pp 1st sentence [16:6]
      change "name." to "name (see 12.4.1)."

   5. Page 19, section 3.2 [19:35]
      change "keywords" to "statement keywords (2.5.2)"

   6. Page 19, section 3.2.1 [19:37-38]
      delete
      rationale: 2.5.2 is now the complete definition.

   7. Page 160, section 11.3.3.5, 1st pp, 3rd line [160:29]
      change "keywords" to "argument keywords"

   8. Page 168, the pp following the line "END INTERFACE", 2nd sentence
      [168:24] replace with "Invocations of these procedures may use
      argument keywords; for example:"
      rationale: "keyword calls" is not defined.  In general invocations
      can use both positional and argument keywords.

   9. Page 172, 1st paragraph following constraints, 3 occurrences  
      [172:13,16,17]
      change "a keyword" to "an argument keyword", two occurrences, and
      change "the keyword" to "the argument keyword"

  10. Section 13.3, first sentence [183:37], set "positional arguments"
      and "keyword arguments" in regular font

  11. Page 183, section 13.3, 1st pp, 3rd line, 2 occurrences [183:38]
      change "the keyword" to "the argument keyword" and
      change "A keyword" to "An argument keyword"

  12. Page 188, section 13.10, 1st pp, 1st two lines, 2 occurrences  
      [188:12,13]
      change "keyword" to "argument keyword" and
      change "keywords" to "argument keywords"

  13. Page 363, entry for "argument keywords 183" [363:37]
      delete
      rationale: odd to index both singular and plural.  "Keyword",
      and "statement keyword" are indexed to p16, as is the
      remaining entry for "argument keyword".

  14. Annex F, delete entry for "positional arguments" [368:13]

SUBMITTED BY: GEN

HISTORY: WG5/N808, Question 2.
         Approved as X3J3/92-164A at meeting 122 by a vote of 17-4

--------------------------------------------------------------------------

NUMBER: 000059
TITLE: SEQUENCE derived type and component bounds
KEYWORDS: SEQUENCE, derived type
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Given two objects of SEQUENCE derived type, can the two objects
be of the same derived type if the only difference between the two
SEQUENCE derived type definitions is the value of the low bound and high
bound for one dimension of one of the components (assuming the extent of
the dimension of the array component matches the extent given in the
other; and there are no structure components that have PRIVATE
accessibility)?

The description of when two objects of SEQUENCE derived type have the same
type includes the words (2nd paragraph of 4.4.2 "Determination of derived
types") "have structure components that do not have PRIVATE accessibility
and agree in order, name, and attributes".

This text seems to imply that if the derived type includes an <array-spec>
then the individual low bounds and high bounds have to be the same.

An example that corresponds to the question above:

          SUBROUTINE S()
            TYPE T
              SEQUENCE
              INTEGER A(1:10)
            END TYPE
            TYPE (T) X
            CALL S2(X)
            ...

          SUBROUTINE S2(Y)
            TYPE T
              SEQUENCE
              INTEGER A(2:11)
            END TYPE
           TYPE (T) Y
           ...

Do X and Y have the same type?

ANSWER: No.

Discussion: The attributes that a data object may have are enumerated in
section 5.1.2.  Included in these is the DIMENSION attribute (section
5.1.2.4).  In reference to the explicit shape arrays in the example above,
in order for the attributes to agree, the values of the corresponding
lower bounds and the corresponding upper bounds in <explicit-shape-spec>
must be equal.

REFERENCES: ISO/IEC 1539:1991(E) 5.1.2

EDIT(S): None.

SUBMITTED BY: Janice C. Shepherd  X3J3/92-129


HISTORY: X3J3/92-129
         Approved as X3J3/92-165A at meeting 122 by a vote of 19-2
         Approved in ballot 92-182

--------------------------------------------------------------------------

NUMBER: 000060
TITLE: Statement function argument references
KEYWORDS: statement function arguments
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Consider the following program:

         PROGRAM TEST
            INTEGER AR
            EXTERNAL AR
            REAL A(2), FUN, X, Y
            DATA A/2*5./
            FUN(X) = X+X+X
            Y=FUN(A(AR(5)))
          END

          INTEGER FUNCTION AR(I)
            INTEGER I
            AR = 1
            PRINT *, I
            RETURN
          END

When the statement function is referenced, how many times is the function 
AR called?  Or, to put it another way, how many times is the PRINT 
statement in function AR executed during the statement function reference?

ANSWER: In the program above, the function AR is called once unless
the value of the function "can be determined otherwise" than by
evaluating the function.  Therefore,  the PRINT statement in function AR is 
executed at most once.

Discussion: When the statement function is referenced, the actual 
arguments are evaluated and the resulting values are associated with the 
corresponding dummy arguments.  The statement function FUN has only one 
actual argument which contains only one reference to the external function
AR.  Therefore, the function AR is called once as part of the evaluation
of the  actual argument.  The value resulting from this evaluation is
associated with  the single dummy argument of the statement function FUN.
Though the print statement may be executed once, note that 7.1.7.1 gives
license to the processor to not execute the print statement at all.  Thus
the statement in the answer is "the PRINT statement in function AR is
executed at most once".

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.5.4, the fourth 
            paragraph after the last constraint.

EDIT(S): None.

SUBMITTED BY:  Linda J. O'Gara

LAST SIGNIFICANT CHANGE:  1992 11 13

HISTORY: 121-LJO-3, 121-ADT-11 pages 14-17
         Approved as X3J3/92-168 at meeting 122 by a vote of 17-0
	 Revised after letter ballot at meeting 123, in paper 92-315.
	 Revision approved by unanimous consent in meeting 123.

--------------------------------------------------------------------------

NUMBER: 000061
TITLE: G edit descriptor with "d" = 0
KEYWORDS: G edit descriptor
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Is a value of 0 for "d" in a G edit descriptor (e.g. 1PG8.0)
permitted?

ANSWER: Yes. See R1008, R1005, and R404.

QUESTION: Did the committee mean to change the definition of G format in
Fortran 90 (compared to FORTRAN 77)?

ANSWER: Yes. The form of output text produced by the G edit descriptor for
some values and particular edit descriptors was intentionally changed. The
changes require processors to give meaningful output instead of "*"s for
certain values and edit descriptors.

QUESTION: What happens when N (the value to be printed) is zero and "d" is
zero?

ANSWER: The standard indicates a format of F(w-n).-1 is to be used. This
is an error in the standard.

REFERENCES: ISO/IEC 1539:1991 (E) Rules R404, R1005, and R1008

EDIT(S):

   1. In section 10.5.4.1.2 second paragraph, 3rd sentence, after
      "-0.5," add " or N is identically 0 and d is 0,".

   2. In section 10.5.4.1.2, second paragraph, fourth sentence, after "N
      is identically 0" add " and d is not zero".

   3. In section 1.4.1, add item (5) as follows:

     (5) A value of 0 for a list item in a formatted output statement will
         be formatted in a different form for some G edit descriptors. In
         addition, the Fortran 90 standard specifies how rounding of
         values will affect the output field form, but FORTRAN 77 did not
         address this issue: therefore, some FORTRAN 77 processors may
         produce a different output form than Fortran 90 processors for
         certain combinations of values and G edit descriptors.

SUBMITTED BY: J.Brixius, 121-JB-1

HISTORY: 121-ADT-7 pp 1-9, 92-076, 92-118
         Approved as X3J3/92-149A at meeting 122 by a vote of 20-3
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000062
TITLE: Statement function constraints
KEYWORDS: statement function, host association
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Does the last constraint under R1226 allow variables in a
<scalar-expr> of a statement function definition to be accessed via host
association or use association?

          PROGRAM HOST
            INTEGER I
            ...
            CONTAINS
              SUBROUTINE INNER()
                STMTFUNC()=I+1
                ...

ANSWER: Yes.

Discussion: It was the intent of the committee to allow variables made
accessible by use or host association to appear in a <scalar-expr> of a
statement function definition. The text of the last constraint under R1226
needs clarification to better reflect that intent.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.4

EDIT(S): In the last constraint after R1226 in section 12.5.4 replace
"local to" with "accessible in".

SUBMITTED BY: J.C.Shepherd X3J3/92-015

HISTORY: Discussed in X3J3/92-046 pp 28-29
         Initially drafted as X3J3/92-120
         Approved as X3J3/92-160 at meeting 122 by a vote of 23-0
         Approved in ballot 92-182

--------------------------------------------------------------------------

NUMBER: 000063
TITLE: Interfaces and dummy procedure arguments
KEYWORDS: interface, dummy procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Given a procedure that has a dummy argument, must an explicit
interface for the procedure show sufficient information to indicate that
its dummy argument is a dummy procedure?

ANSWER: Yes.

Discussion: The first sentence of the second paragraph in 12.3.2.1
indicates that an interface body must specify all of the procedures
characteristics. Section 12.2 indicates that a procedure's characteristics
include the characteristics of its arguments. Therefore, an interface body
must include an EXTERNAL statement or a nested interface block for each
dummy argument that is a dummy procedure, even though this may not be
necessary in the procedure definition.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.2 and 12.3.2.1

EDIT(S): None.

SUBMITTED BY: J.C.Shepherd, X3J3/92-016

HISTORY: Approved as X3J3/92-161 at meeting 122 by a vote of 24-0
                   Approved in ballot 92-182

--------------------------------------------------------------------------

NUMBER: 000064
TITLE: SPACING result for 0.0
KEYWORDS: SPACING intrinsic
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Is the SPACING intrinsic function intended to return absolute
spacing of model numbers about 0.0 when its argument is 0.0?

Section 13.12.100 under Result Value specifies that the result should be
b**(e-p); this is not equal to the absolute spacing of model numbers
around zero because zero has e == 0, so b**(e-p) provides a much larger
value than expected.

ANSWER: Yes.

Discussion: Since the smallest magnitude model numbers are TINY(X) and
-TINY(X), the absolute spacing around zero is TINY(X). It was intended
that the "otherwise" clause of the SPACING definition apply to this case.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.7.1 and 13.13.100.

EDIT(S): In section 13.13.100, after "Result Value." change "The" to "If
X is not zero, the". In the same section, change "; otherwise " to
". Otherwise".

SUBMITTED BY: J.K.Reid

HISTORY: WG5/N786a item 234/7, N815a item 6 (X3J3/92-136 item 6)
         Approved as X3J3/92-171 at meeting 122 by a vote of 22-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000065
TITLE: Block and Nonblock DO Construct
KEYWORDS: block DO construct, nonblock DO construct
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Consider the following DO loop:

          DO 10, I = 1, 10
             K = I
   10     CONTINUE

It can be parsed using either of the following two paths:

  R816  <do-construct>                  is  <block-do-construct>

  R817  <block-do-construct>       		is  <do-stmt>
                                                 <do-block>
                                                 <end-do>

  R818  <do-stmt> 		                is  <label-do-stmt>

  R819  <label-do-stmt>               	is   DO <label> [<loop-control>]

  R821  <loop-control>              	is  ,<do-variable> =
                                                 <scalar-numeric-expr>,
                                                 <scalar-numeric-expr>

  R822  <do-variable>                	is  <scalar-variable>

  R823  <do-block>                    	is  <block>

  R801  <block>                        	is  [<execution-part-construct>]...

  R209  <execution-part-construct>		is  <executable-construct>

  R215  <executable-construct>     		is  <action-stmt>

  R216  <action-stmt		            is  <assignment-stmt>

  R824  <end-do>                      	is  <continue-stmt>

  R816 <do-construct>                	is  <nonblock-do-construct>

  R826  <nonblock-do-construct> 		is <action-term-do-construct>

  R827  <action-term-do-construct>		is  <label-do-stmt>
                                                 <do-body>
                                                 <do-term-action-stmt>

  R819  <label-do-stmt>             	is  DO <label> [<loop-control>]

  R821  <loop-control>              	is  ,<do-variable> =
                                                 <scalar-numeric-expr>,
                                                 <scalar-numeric-expr>

  R822  <do-variable>               	is  <scalar-variable>

  R828  <do-body>                    	is  [<execution-part-construct>]...

  R209  <execution-part-construct>		is  <executable-construct>

  R215  <executable-construct>    		is  <action-stmt>

  R216  <action-stmt>             		is  <assignment-stmt>

  R829  <do-term-action-stmt>     		is  <action-stmt>

  Constraint:  A <do-term-action-stmt> must not be a <continue-stmt>...

How is a compiler to decide that the above DO loop is obeying the rules
for a  <block-do-construct> (and thus no diagnostic is required) or that
it is following  the rules for a <nonblock-do-construct> (and thus by 1.4
it should report that the  program is being rejected because it is
violating the constraint)?

ANSWER:  The intent of the cited constraint is to remove the ambiguity
raised in the  question in favor of the <block-do-construct>
interpretation.

Discussion: Item 5 in section 1.5.1 states that

     The syntax rules are not a complete and accurate syntax description
     of Fortran, ...; where a syntax rule is incomplete, it is accompanied
     by the corresponding constraints and text.

This is an application of this rule.

REFERENCES: ISO/IEC 1539:1991 (E) sections 1.5.1, 2.1, and 8.1.

EDIT(S): None.

SUBMITTED BY: L. Rolison X3J3/92-126

HISTORY: Approved as X3J3/92-169 at meeting 122 by a vote of 20-0
                   Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------

NUMBER: 000066
TITLE: Declaration of FUNCTION type
KEYWORDS: function, declarations
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: In the following example:

          SUBROUTINE SUB
            ...
            Y=F(X)
            ...
            CONTAINS
              FUNCTION F(X)
                REAL F,X
                  ...
              END FUNCTION F
          END

Is the declaration of function-name "F" in the REAL <entity-decl-list>
legal? Does the second constraint in 5.1 contradict the text in the first
sentence of the first paragraph after constraints in section 12.5.2.2?

ANSWER: Yes. The example above is standard conforming. There is no
conflict between the constraint and the text mentioned.

Discussion: The information in section 5.1 that applies to functions
describes functions being called, not functions being defined by program
units or by internal functions. The information in section 12.5.2.2
describes the definition of functions.

However, this distinction has been made less clear by syntax rules and
constraints in section 5.1 that do not reflect it. The supplied edit
remedies this situation by using consistent terminology and eliminating
the resultant redundant constraint.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1 (R504) and 12.5.2.2

EDIT(S):

   1. Change R504 "<function-name>{(<array-spec>)}" to "<function-name>".

   2. Change "Constraint: An <array-spec> for a <function-name> that does
      not have the POINTER attribute must be an
      <explicit-shape-spec-list>" to "Constraint: An <array-spec> for an
      <object-name> that is a function result that does not have the
      POINTER attribute must be an <explicit-shape-spec-list>".

   3. Delete the constraint "An <array-spec> for a <function-name> that
      does have the POINTER attribute must be a
      <deferred-shape-spec-list>".

SUBMITTED BY: L.R.Rolison X3J3/92-057 (121-LRR-4)

HISTORY: Original response in X3J3/92-090, reconsidered and rewritten
         Approved as X3J3/92-173 at meeting 122 by unanimous consent
         Approved in ballot 92-182

--------------------------------------------------------------------------

NUMBER: 000067
TITLE: Output of negative signed zero
KEYWORDS: F edit descriptors, negative signed zero, formatted output
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: If the real variables A, B, C, and D have the values -.003,
-.003, -0.0, and 0.0 respectively  and they are written with:

          WRITE(6,100) A,B,C,D
   100    FORMAT(F10.2, F10.3, 2F10.3)

is the following output correct:

     -0.00    -0.003       0.0       0.0
.........1.........2.........3.........4

ANSWER: No.

QUESTION: or should it be

      0.00    -0.003     0.000     0.000
.........1.........2.........3.........4

ANSWER: Yes. Negative signed zero in an output record is prohibited by
section 10.5.1 item (3). Truncation of trailing zeros by F edit
descriptor is not allowed. See the last paragraph of section 10.5.1.2.1.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.5.1 and 10.5.1.2.1

EDIT(S): None.

SUBMITTED BY: A.D.Tait X3J3/92-045 pp 14-16

HISTORY: Approved as X3J3/92-074 at meeting 122 by a vote of 22-0
                   Approved in ballot 92-182

--------------------------------------------------------------------------
NUMBER: 000068
TITLE: Pointer association status
KEYWORDS: pointer association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: When the execution of a procedure is terminated by the
execution of a RETURN or END statement, the pointer association status of
a pointer declared or accessed in the procedure becomes undefined unless
one of the exceptions listed in section 6.3.3.2 of the standard applies.

In the following example, when SUB is terminated, X remains associated
because it is in a COMMON block.  Pointer Z will become undefined.  The
Y in the main program is useful, but according to the standard, it is
invalid because it points to the undefined Z.  Is this correct?

            COMMON /COM/ X,Y
            CHARACTER*10,POINTER::X,Y
            ...
            CALL SUB
            PRINT *, X         ! X must be valid
            PRINT *, Y         ! is this Y valid?
          END

          SUBROUTINE sub
            COMMON /COM/ X,Y
            CHARACTER*10,POINTER::X,Y,Z
            ALLOCATE (X,Z)
            X = 'A STRING'
            Z = 'ANOTHER'
            Y => Z
            RETURN
          END

ANSWER: No, the interpretation suggested in the question is not correct.
The example is valid.

Discussion: The question appears to confuse the association status of the
pointer and the definition status of its target.  The pointer association
status of Z becomes undefined on the execution of the RETURN statement in
the above example, but this does not imply that the target of Z becomes
undefined.  The situation is analogous to that described in section
6.3.1.2 of the standard in the context of the ALLOCATE statement.

     If the previous target had been created by allocation, it becomes
     inaccessible unless it can still be referred to by other pointers
     that are currently associated with it.

An example and further elaboration is given in section C.6.4

     The basic principle is that ALLOCATE, NULLIFY, and pointer
     assignment primarily affect the pointer rather than the target.
     ALLOCATE creates a new target but, other than breaking its
     connection with the specified pointer, it has no effect on the old
     target.  Neither NULLIFY nor pointer assignment has any effect on
     targets.

Similarly, the target of Z in the above example is not affected when the
pointer association status of Z becomes undefined.  If the old target of
Z could not be referred to by other pointers, then it would become
inaccessible (though still technically defined).  In this example, the old
target of Z can still be referenced by Y.  It therefore remains both
defined and accessible.

The statement in section 14.6.2.2 that "The definition status of a pointer
is that of its target" applies only when the pointer is associated with a
target.

REFERENCES: ISO/IEC 1539:1991, sections 6.3.1.2, 6.3.3.2, 14.6.2.1, C.6.4

EDIT(S): The list in section 14.6.2.1, item (3), of ways that pointer
association status can become undefined is incomplete.  

In section 14.6.2.1, item (3), add a new subitem as follows:

  (e) After the execution of a RETURN or END statement in a procedure
      where the pointer was either declared or, with the exceptions 
      described in 6.3.3.2, accessed.

The reference to section 6.3.3.2 in 14.6.2.1 (3) (d) is misleading. 
In section 14.6.2.1, item (3), subitem (d), remove "6.3.3.2,".

SUBMITTED BY: Y.Yoshida, X3J3/92-051 p4
HISTORY: Approved as X3J3/92-083A at meeting 122 by a vote of 18-2
	Approved in X3J3/92-329 at meeting 123 (unanimous consent)

--------------------------------------------------------------------------

NUMBER:  000069
TITLE:  I/O implied DO variable
KEYWORDS:  implied DO, I/O statement
DEFECT TYPE: Erratum
STATUS: X3J3 draft response 

QUESTION(S):
    1) Can the "do-variable" in an implied-DO in an I/O statement
       be a sub-object?

    2) Should the second constraint in section 9.4.2 read:
       "Constraint: The "do-variable" must be a named scalar variable
        of type integer, default real, or double precision real."?

ANSWER(S): 
    1) No.  The intent of the committee was to allow only named scalar
       variables as "do-variables".  The supplied edit corrects this error.

    2) Yes, it should have.

Discussion:
    In FORTRAN 77, all implied-DO variables were required to be a "variable",
    and derived types were not part of the language.  The rules for implied-DO
    variables and DO loop "do-variables" were identical.
    The committee's intent was to permit only simple variables (named scalar
    variables) as implied-DO variables in I/O statements.

REFERENCES: ISO/IEC 1539:1991 (E) sections 8.1.4.1.1, 9.4.2, 5.2.9,
            ANSI X3.9-1978 12.8.2.3, 11.10, 9.3.

EDITS: In section 9.4.2, in the second constraint, replace the word
       "scalar" with "named scalar variable".

SUBMITTED BY: Larry Rolison, 92-086 (121-86/121-LRR-9)

HISTORY: 92-086
	Approved as X3J3/92-217b at meeting 123

--------------------------------------------------------------------------

NUMBER: 000070
TITLE: Characteristics specified by interface bodies
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Section 12.3.2.2 indicates that an interface body specifies
all of a procedure's characteristics and that the characteristics must
be consistent with those in the procedure definition.  Are the following
code fragments standard conforming?

(a)   PROGRAM FRED
       INTERFACE
        SUBROUTINE SUB (ARR,J)
         INTEGER ARR(1:)
        END SUBROUTINE
       END INTERFACE
       INTEGER ARR(10)
       CALL SUB(ARR,2)
      END PROGRAM
        
      SUBROUTINE SUB(ARR, J)
       INTEGER ARR(J:)
       ...
      END SUBROUTINE SUB
        
(b)   FUNCTION C1( )
       CHARACTER(*) C1
       ...
      END FUNCTION C1
      FUNCTION C2(N)
       CHARACTER(N) C2
       ...
      END FUNCTION C2

      SUBROUTINE CALLER( )
       INTERFACE
        FUNCTION C1( )
         CHARACTER(*) C1
        END FUNCTION
        FUNCTION C2(N)
         CHARACTER(2) C2
        END FUNCTION
       END INTERFACE
       CHARACTER(5) CC
       CC=C1( )//C2(2)
       
ANSWER:

(a) This example is standard conforming.
(b) This example is not standard conforming.

Discussion:

(a) 12.2.1.1 states that the characteristics of a dummy data object include 
its shape, and that if the shape is assumed then that is a characteristic. 
Section 2.4.5 states that the shape of an array is determined by its rank and 
extent in each dimension (but not by its bounds, 15.1.2.4.2). Therefore the 
characteristics of SUB specified in the interface body are consistent with 
those in the definition of SUB, and the program is standard conforming.

(b) Section 12.2.2 states that the characteristics of a function
include whether or not the function result value is a character of
assumed length.  So the interface body for function C1 must indicate
that C1 is of assumed length.  However, item (3) in 5.1.1.5 indicates
that scoping units that invoke an external character function of assumed
length must have access to a definition of the function with a length type
parameter value other than *.  An edit is included to clarify this 
restriction.

In addition, the interface for C2 does not conform to the standard as the
length of C2 specified as 2 is not consistent with the length specified as
N within the function definition.

EDITS:
In section 5.1.1.5 item (3), add to the end: "Note that the interface for such
a function cannot be specified in an interface body."
   
REFERENCES: ISO/IEC 1539:1991 (E) sections 2.4.5, 5.1.1.5, 5.1.2.4.2, 
12.2.1.1,
        and 12.2.2.
        
SUBMITTED BY: Graham Barber (a)
              Janice Shepherd (b)
                
LAST SIGNIFICANT CHANGE: 1992 11 11, new

HISTORY: Question (a) originally posed in X3J3/92-264.
         Question (b) originally posed in e-mail collection X3J3/92-46.
         Response proposed in X3J3/92-283.

--------------------------------------------------------------------------

NUMBER: 000071
TITLE: USE association and COMMON block names
KEYWORDS: use association, COMMON block names, storage association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Can a module or subprogram access through USE association
variables declared in different modules to be in the same common block?

Example:

      MODULE MOD1
      COMMON /BLOCK/ A,B,C
      END MODULE MOD1

      MODULE MOD2
      COMMON /BLOCK/ X,Y,Z
      END MODULE MOD2

      SUBROUTINE USER()
      USE MOD1
      USE MOD2
      ...
      Y = A               ! Are both Y and A accessible?
      END

ANSWER: Yes.

Discussion: The COMMON statement in MOD1 forms a common block storage
sequence as described in 5.5.2.1.  The COMMON statement in MOD2 similarly 
forms a common block storage sequence.  These two sequences are associated as 
described in 5.5.2.3, thus associating A with X, B with Y, and C with Z.  The 
USE statements in USER make these variables accessible in that scoping unit.  
The associated variables are considered to behave as though they had been 
EQUIVALENCEd.  The list of entities made accessible by USE association in 
11.3.2 includes variables but not common blocks, so there is no implication 
that these two specifications of common block storage sequences for /BLOCK/ 
interfere with each other or require a concatenated common block storage 
sequence in USER.

Various other combinations of USE association, host association, and local
COMMON statements can similarly result in common associated variables being
accessible in the same scoping unit.  One of these cases, that involve
USE association and local COMMON statements, is prohibited in 5.5.2.5.

The edits below emphasize the independence of common block storage sequence
formation from USE and host association and eliminate the ineffective
restriction in 5.5.2.5.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.5.2.1, 5.5.2.3, 5.5.2.5, and 
11.3.2

EDITS:
  1. In the first sentence of 5.5.2.1 after "For each common block", insert
     "in a scoping unit".
  2. At the end of 5.5.2.1, add the following paragraph:
       "Only COMMON statements and EQUIVALENCE statements appearing in the
        scoping unit contribute to common block storage sequences formed in
        that unit.  Variables in common made accessible by USE association or
        host association do not contribute."
  3. At the end of the first paragraph of 5.5.2.3, add the following sentence:
     "USE association or host association may cause these associated objects
     to be accessible in the same scoping unit."
  4. Delete the last two sentences in 5.5.2.5.

SUBMITTED BY: Jon L. Steidel, 120-JLS-8

LAST SIGNIFICANT CHANGE: 1992 11 12, added edits to previously proposed 
interpretation

HISTORY: 120-86 (120-MBSH-3), initial response draft
         92-163, revised draft response
         92-191, revised draft response
         92-316, revised draft response - approved by a (19-2) vote at 
meeting 123

--------------------------------------------------------------------------

NUMBER: 000072
TITLE: Missing constraint for SIZE=
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: In section 9.4.1, should there be an additional constraint:

    "If a SIZE= specifier is present, an ADVANCE= specifier also must appear"?

ANSWER:  Yes.

      In reading the first two paragraphs of section 9.4.1, on page 120,
      immediately following the list of constraints, it can be seen that SIZE
      and EOR have the same requirements and, thus, there should be a
      constraint for SIZE that parallels the constraint (last in the list)
      for EOR.

REFERENCES:
            ISO/IEC 1539:1991 (E) sections 9.4.1

EDIT: Section 9.4.1, [120:25], add a constraint to the end of list:

      "If a SIZE= specifier is present, an ADVANCE= specifier also must 
appear."

SUBMITTED BY: Dick Weaver

HISTORY: 92-193

--------------------------------------------------------------------------

NUMBER: 000073
TITLE: Description of the MERGE intrinsic function
KEYWORDS: MERGE, intrinsic, elemental, array
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: The MERGE intrinsic function is described as an array construction
function in 13.8.6, page 187, and in 13.10.16, page 191.

The description of MERGE, 13.13.67 page 220, classes it as elemental.

Are the 13.8.6 and 13.10.16 descriptions of MERGE consistent with its
classification as an elemental function?  Note that 13.8 is "Array intrinsic
functions" and MERGE is the only elemental included.  Should all elemental
functions be listed as "array construction" functions or should MERGE be
described elsewhere?


ANSWER: No; the classification of MERGE, and possibly other intrinsic
functions, for description purposes is not consistent.  This issue will
be addressed in the next revision.

REFERENCES: ISO/IEC 1539:1991 (E) sections 13.8.6, 13.10.16, 13.13.67

EDIT: None

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92 11 11, first draft response
HISTORY: X3J3/92-197
	Draft response in X3J3/92-322 at meeting 123, not approved

--------------------------------------------------------------------------

NUMBER: 000074
TITLE: Meaning of "referenced" in 11.3.2
KEYWORDS: local names, data entity
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: 

The section of the standard in 11.3.2 [158:27-31] states:

     "Two or more accessible entities, other than generic interfaces,
     may have the same name only if no entity is referenced by this
     name in the scoping unit."

Should the use of this name as an argument to an inquiry function
also be disallowed; or passing the duplicate name as an argument be 
disallowed; or the duplicate name in a pointer assignment be 
disallowed?  Can the duplicate name be the left hand side of
an assignment statement?

Question 2:  Is it valid to have two local-names on a rename-list that
are the same but refer to two different data entities?  In the
following example, is the appearance of the second AA local-name in 
the rename-list legal?

          USE MID, AA=>BB
          USE MID, AA=>CC

ANSWER: 
Answer 1: The cases cited in the question are not covered specifically in 
11.3.2 although they were intended to be included in the quoted text as
"referenced" entities. The cited cases are examples of the appearance of 
names rather than as a technical Fortran 90 term for "reference".

Answer 2: The example is invalid. The appearance of the second
AA is not allowed by the standard. In section 11.3.2 [158:15-16],
the standard states that the local name is a "local name for the entity"
which was intended to mean that a new entity is not created, the
existing entity is just renamed.

Discussion:

It was intended that the term "referenced" be used in the 
sense that an entity "appeared in" or "is referred to" in the
scoping unit, and did not mean "referenced" in terms of the technical
definition. That is, two  or more accessible entities with the same 
name must not appear in the  same scoping unit. An edit has been made
to the standard to improve this wording.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDIT(S):  
In section 11.3.2 [158:28] change the term "no entity is referenced by 
this name" to "the name is not used to refer to an entity".

SUBMITTED BY: Dick Weaver, 92-198 question raised. 
HISTORY:
Response draft in meeting 123 (92-297) - 
approved by unanimous consent in meeting 123.

--------------------------------------------------------------------------

NUMBER: 000075
TITLE: Interface blocks in block data
KEYWORDS: interface block, block data
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  In section 12.3.2.1, on page 167, the 3rd constraint

   "An interface-block must not appear in a BLOCK DATA program unit"

is constraining what? (The existence of a constraint implies that, if the
constraint were not present, the constrained "action" would be allowed.)

ANSWER:  The constraint is redundant with the 2nd constraint in section
11.4 on page 162.


REFERENCES:  ISO/IEC 1539:1991 (E) sections 11.4, 12.3.2.1

EDIT: None

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92 11 11, first draft response
HISTORY: X3J3/92-200
	Draft response in X3J3/92-323 at meeting 123, not approved

--------------------------------------------------------------------------

NUMBER: 000076
TITLE: Attributes, Properties, Characteristics
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  I've been trying to understand "attributes" and "properties".
Beginning with the glossary definition of "attributes":

      Attributes: A property of a data object that may be specified in
                  a type declaration statement

There would seem to be some set of "properties", of which a subset are
"attributes".  However, in trying to use that definition while reading
the standard, I had a variety of difficulties:

      -- that defintion itself:  data entities besides data objects have
         attributes and the attributes of a function result can be specified
         in a type declaration stmt in the same manner as for a data object.

      -- the first pp of chapter 5 equates attributes and properties
         "Collectively, these properties are termed the attributes of the
         data object"

      -- the introduction (xv, 2pp from bottom) equates attributes and
         properties: "... given the desired properties (attributes)"

      -- where I would expect "properties", I find "attributes", for example
         in host association 12.1.2.2.1 "The accessed entities are known
         by the same name and have the same attributes ....".  For host
         association, can the attributes be the same but properties be
         different?

      -- chapter 4, 4.4.2 for example, talks about derived type definitions
         having the SEQUENCE property but a derived type definition is not
         a data object.  (File and file connections also have properties;
         that usage, however, is clearly separate from data entities)

My questions:

    Data objects in Fortran 90 have (1st pp section 5)
                -- attributes
                -- properties
                -- characteristics (see also 12.2.1.1)

    (1) What is the relationship between attributes, properties, and
        characteristics?

    (2) Is this complexity, which seems to have led to a number of
        difficulties, necessary?


ANSWER:

(1) The intended relationships:

    attributes -- Going by the 1st pp of section 5, attributes are
            type plus those things that can be specified in both a
            type declaration statement and a separate specification
            statment (DIMENSION, for example).

    properties -- those things derived from attributes or that could
            be specified in a separate specification statement but
            not in a type statement.  Also, having
            or not having a value is a property (glossary entry "defined").

            The "array property", for example, is derived from
            the dimension attribute.

            The only property specifiable in a separate specification
            statement is SEQUENCE.

     characteristics -- This word is used only a few times in discussions
            of data objects and was likely used as "normal English".
            Unfortunately, "characteristics" is used in a technical way
            in chapter 12; that usage is disjoint from chapter 5.

(2) No, this complexity is not necessary.

The use of "characteristics" is readily removed.

Fortran 90 is not dependent on the distinction between "properties" and 
"attributes".  The distinction would seem to be only an artifact of defining 
attributes in terms of specific specification statements and thus needing 
another term for "attributes" not so specified.   While this may have 
simplified the definition of attributes it has, as you've noted, added 
complexity to the language definition and resulted in errors in the standard 
itself.

To correct this we will:

    -- consolidate "attributes" and "properties" into a single concept,
       "attributes".

    -- explicitly list the attributes a data entity may have and how
       those attributes can be specified.


REFERENCES:
            ISO/IEC 1539:1991 (E), X3J3/92-305, X3J3/92-307

EDIT:

page xv pp beginning "Section 4 (Intrinsic"
   delete "the properties of" [xv]
   change "and properties" to "and attributes" [xv]

page xv pp beginning "Section 4 also"
   change "properties" to "concepts"

   Note: this change is consistent with prior pp "Note that only type
   concepts ..."

page xv pp beginning "Section 5"
   change "properties(attributes" to "attributes" [xv]

page xvii
   change "scope properties" to "scopes" [xvii]

1.5.3
   change "Syntax conventions and characteristics"
       to "Syntax conventions" [5:2]

   rationale" eliminate spurious "characteristics"

2.3.1 page 11 2nd pp
   change "configure" to "specify"  [11:10]

   rationale: that is why most are called specification statements.
   This change is being made in conjunction with the change to 2.4.

2.4 page 13
   change "define the characteristics of" to "specify" [13:2]

2.4.1.1 page 13 1st pp
   change "The properties of intrinsic" to "Intrinsic" [13:11]

2.4.7 page 15
   change "characteristics" to "properties"

   Rationale: consistent with 1.3.2, page 1.

4.4.2 page 35 2nd pp
   change "have the SEQUENCE property" to "specify SEQUENCE" [35:43]

   Rationale: derived data type definitions are the subject and they
   are not data objects and thus do not have attributes.

4.4.2 page 35 2nd pp
   change "with the SEQUENCE property" to "with the SEQUENCE statement"  
   [35:45]

4.4.2 page 36 pp beginning "The actual"
   change "SEQUENCE property" to "SEQUENCE statement" [36:39-40]

5 page 39 1st pp
   replace entire pp with the following pp and table:

Every data entity has a number of attributes (for example, type, rank,
and shape) that determine the uses of the data entity.  Not all attributes
apply to every data entity; the SEQUENCE attribute,
for example, applies only to derived type data entities.  A named
data object or a function result must not be specified explicitly to
have a particular attribute more than once in a scoping unit.

 attribute        how specified for data objects and function results
 ---------        ------------------------------------------------------------
 type             either is determined implicitly by the first letter of
                    its name (5.3), or is specified explicitly in a
                    type-declaration-stmt
 accessibility    type-declaration or specification statement (PUBLIC,PRIVATE)
 ALLOCATABLE      type-declaration or specification statement
 array            derived from rank
 EXTERNAL         type-declaration or specification statement
 intent           type-declaration or specification statement (IN, OUT, INOUT)
 INTRINSIC        type-declaration or specification statement
 OPTIONAL         type-declaration or specification statement
 PARAMETER        type-declaration or PARAMETER statement
 POINTER          type-declaration or specification statement
 rank             type-declaration or specification statement (array-spec)
 SAVE             type-declaration or specification statement
 scalar           derived from rank
 SEQUENCE         SEQUENCE statement in the derived type definition
 shape            type-declaration or specification statement (array-spec)
 TARGET           type-declaration or specification statement
                                                              [39:3-9]

5.1.1.7 page 43 2nd pp
   change "SEQUENCE property" to "SEQUENCE attribute" [43:24]

5.1.2 page 43
   change heading "Attributes" to "Attribute specifiers" [43:31]

   Rationale: parallel construction to the 5.1.1 heading and necessary
   now that DIMENSION is not an attribute (array/scalar, rank and shape are).

5.1.2.1 through 5.1.2.11

   delete "attribute" from each heading [43:34 to 48:29]

   Rationale: parallel construction to  5.1.1.1 through 5.1.1.4 and
   necessary now that DIMENSION is not an attribute

5.1.2.4 page 46, 1st pp, sentence beginning "The DIMENSION"

   change "The DIMENSION attribute" to "DIMENSION" [45:2]

5.1.2.4 page 46, 1st pp, sentence beginning "The rank"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:4]

5.1.2.4 page 46, 1st pp, sentence beginning "An array-spec"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:5]

5.1.2.4 page 46, 1st pp, sentence beginning "If the DIMENSION"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:6]

5.1.2.4 page 46, pp beginning "Examples"

   change "DIMENSION attribute specification" to "the DIMENSION specifier"
                                                         [45:13]

5.1.2.4.3 page 46 pp beginning "The size, bounds, and shape of an"
   delete "except as an argument to an intrinsic inquiry function that is
   inquiring about argument presence, a property of the type or type
   parameters, or association status". [46:26-27]

   Rationale: a reference, 2.5.5, is the appearance of the data object
   in a context requiring its value.  The exceptions above are not references.

5.1.2.4.3 page 46 pp beginning "The size, bounds, and shape of the target"
   delete "except as an argument to an intrinsic inquiry function that is
   inquiring about argument presence, a property of the type or type
   parameters, or association status". [46:31-33]

   Rationale: a reference, 2.5.5, is the appearance of the data object
   in a context requiring its value.  The exceptions above are not references.

5.2.5 page 50
   change "the DIMENSION attribute(5.1.2.4) and specifies the array  
           properties"
   to "rank or rank and shape attributes" [50:35]

5.2.9 page 51
   change "array properties" to "array attributes" [51:38]

5.2.10 page 53 1st pp
   change "properties" to "attributes" [53:39]

5.5.1 page 56 2nd pp
   change "properties" to "attributes" (two occurances) [56:37]

5.5.2 page 59 2nd pp
   change "properties" to "attributes" [59:4]

13.1 page 183 1st pp
   change "properties" to "attributes" [183:7]

glossary: array-valued
   change "property" to "attribute" [254:26]

glossary: attribute
   replace definition with "Attributes determine the uses of a data
                            entity (5)." [254:31]

   Note: alternately, list the attributes.

glossary: defined
   delete "the property of" [256:15]

glossary: explicit interface
   delete "the property of" [257:1]

glossary: inquiry function
   change "properties" to "attributes" [257:34]

glossary: scalar
   change "Not having the property of being an array"
       to "Having a rank of 0" [259:40]

glossary: undefined
   delete "the property of" [261:24]


SUBMITTED BY: Dick Weaver
HISTORY:      <meeting no.>        <information>
                              123                submitted as X3J3/92-202r
	Related question submitted in X3J3/92-248

--------------------------------------------------------------------------

NUMBER: 000077
TITLE: Misc. questions
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  In using the standard, I've noted a number of
corrections.  Are those corrections, expressed here as edits, right?

| rev 1: incorporates Bill Leonard's comments of 25 Sept.


Intro page xiii pp beginning "Computation involving..."
      change "entities" to "data entities"

2.4.3.1, 1st pp page 14
      change "but subobjects"
          to "but subobjects of named objects" [14:2]

      rationale:   '0123456789'(N:N) found on page 62, for example,
      is a constant subobject but is not referenced by a subobject designator.

2.5.6, 2nd pp page 16
       change "different entities"
           to "different data entities" [16:31]

       rationale: the concept of storage applies only to data entities.

4.3.1.2, 3rd pp page 28
       change "such an entity" to "such a data entity" [28:35]

       rationale: kind type applies only to data entities

4.3.1.3, 2nd pp page 29
       change "complex entity" to "complex data entity" [29:29]

       rationale: complex is a data concept; consistent with nearby text.

4.4.1, page 34 3rd pp
       change "any entity" to "any data entity" [34:9]

       rationale: other possibilities are covered in the rest of the
       sentence.

4.4.2, page 35 2nd pp
       change "an entity" to "a data entity" [35:46]

       rationale: only data is being discussed.

4.4.2 page 36 1st line
       change "entities" to "data entities" [36:1]

4.4.5 page 37
       change "entities" to "data entities" (2 occurrences) [37:30]

5 page 39
       change section 5 title from "Data object ..."
                                to "Data entity ..."

       Rationale: Entity declarations, see R504, are for data
       objects and for function results.  A function result is
       not a data object (2.4.3 and 2.4.3.1), but function results
       and data objects are data entities.

       Note that an effect of this change  is to
       align the title "Data entity declarations ..."
             with R504      "entity-decl"

5 page 39 1st pp
       change "every data object"
       to     "every data entity" [39:3]
       change "uses of the object" to "uses of the data entity] [39:4]
       Sentence beginning "Collectively" delete [39:4]

       (see prior rationale)

5 page 39 1st pp
       change "a named data object"
           to "a named data object or a function" (two occurrences) [39:5-6]

6.3.1 page 67
       change "entities" to "variables" [67:30]

       Rationale: only variables can be redefined or undefined

7.1.5 page 77 1st pp
       change "entities" to "data entities" [77:2]

7.1.6.2 page 79 pp beginning "If a specification..."
       change "an entity" to "a data entity"  [79:28]

7.1.7 page 80 pp beginning "The evaluation..."
       change "entity" to "data entity" [80:5]

7.1.7 page 80 pp beginning "For G..."
       change "entities" to "data entities" [80:11]

7.1.7 page 80 pp beginning "Execution of an ..."
       change "entity" to "data entity" [80:26]

7.1.7.1 page 81 pp beginning "Where X is ..."
       change "entities" to "data entities" [81:5]

7.5.3.2 page 93 last pp
       change "entities" to "data entities" (two occurrences) [93:41-42]

8.1.2.4 page 97 pp beginning "The execution of..."
       change "entities" to "data entities" [97:27]

9.1, page 109
       replace the sentence beginning "However, ..."
       with "However, a record as seen by a Fortran program does not
             necessarily correspond to a physical record on an
|            external medium." [109:19]

       Rationale: The existing sentence talks about "physical entity",
       but the Fortran "entity" concept has no physical realization.
       (i.e., this use of "entity" is not consistent with its Fortran 90
       definition).  If footnotes are used then this sentence, less the
|      "However,", would be much better as a footnote.

9.4.1, page 120 pp beginning "In a data transfer statement, the variable..."
       change "entity" to "variable" [120:33]

       Rationale: variables can only be associated with variables

9.4.2 page 123 1st pp
       change "entities" to "data entities" [123:18]

       Rationale: It is data entities that have a value.

9.4.4 page 125 item (5)
      change "entities" to "data entities"

9.4.4.1 page 125
       change "to the entities" to "to the variables" [125:28]

       Rationale: an input item that can receive a value is a variable

9.4.4.1 page 125
        change "from the entities" to "from the data entities" [125:30]

       Rationale: only data entities have values.

9.4.4.4 page 126 1st pp
       change "Data are transferred" to "Data is transferred" [126:10]
       change "and entities" to "and data entities" [126:10]
|      change "the entities" to "the name-value subsequences" [126:15]

|      Rationale: For "Data is transferred", collective nouns should be
|      accompanied by singular verbs when the collection is to be taken
|      as a unit.

9.4.4.4 page 126 2nd pp
       change "entities" to "data entities" [126:18]

9.4.4.4 page 126 3nd pp
       change "entities" to "data entities" [126:20]

9.4.4.4 page 126 pp beginning "All values following ..."
|      change "namelist entity (10.9) within the input records are
               transmitted to the matching entity specified in the
               namelist-group-object-list prior to processing any
               succeeding entity within the input record for
               namelist input statements"
|          to "name-value subsequence (10.9) within the input records are
               transmitted to the matching variable specified in the
               namelist-group-object-list prior to processing any
               succeeding name-value subsequence within the input record for
               namelist input statements" [126:24-26]

       Rationale: name-value subsequence is the term in the referenced text.
                  A namelist-group-object-list specifies variables,
                  see R544.

9.4.4.4 page 126 pp beginning "All values following ..."
       change "If an entity" to  "If a variable" [126:26]
       change "of the entity" to  "of the variable" [126:27]
       change "for that entity" to  "for that variable" [126:28]

       Rationale: R544, variables are specified.

9.4.4.4 page 126 pp beginning "An input ..."
|      change "an entity" to "a variable" [126:29]

       Rationale: variables can only be associated with variables

9.4.4.4 page 126 pp beginning "On output..."
       change "entity" to "data entity" [126:36]

       Rationale: only data entities have a value.

9.4.4.4.1 page 126 1st pp
       change "entities" to "data entities" [126:39]

9.4.4.4.1 page 126 bottom pp
       change "entity" to "variable" [126:44]

9.4.4.4.1 page 127 top
       change "real list entities" to "real variables" [127:1]
       change "complex list entity" to "complex variable" [127:2]
       change "corresponding entities" to "corresponding data entities"[127:2]
|      change "if an entity" to "if a variable" [127:3]
       change "character entity" to "character variable" [127:3]
       change "complex entity" to "complex variable" [127:5]
       change "real entities" to "real variables" [127:5]

9.4.4.4.2 page 127 1st pp
       change "data are transferred" to "data is transferred" [127:17]
       change "entities" to "data entities" [127:17]

9.6.2 page 134 1st pp
       change "entity" to "variable" [134:7}

       Rationale: variables can only be associated with variables.

13.5.4 page 184
       change "entity" to "data entity" [184:18]

13.5.5 page 184
       change "entity" to "data entity" [184:23]

13.10.5 page 189
       change "entity" to "data entity" [189:48]

13.13.53 page 214
       change "entity" to "data entity" [214:32]

glossary entry "entity"
      delete from definition the terms: a named variable, an expression,
         a component of a structure, a named constant
      add to definition the term "a data entity" [256:38-39]

      rationale: the terms deleted were not a complete replacement for
         "data entity".

glossary entry "main program"
      change "subprogram" to "external subprogram" [258:22]

      rationale: consistent with glossary entry for "program unit"

--------------------  end of question ---------------------------------------

ANSWER:

REFERENCES:
            ISO/IEC 1539:1991 (E) sections .....

EDIT:

SUBMITTED BY: Dick Weaver
HISTORY:      <meeting no.>        <information>
                              123               submitted as X3J3/92-203

--------------------------------------------------------------------------

NUMBER: 000078
TITLE: Intrinsic functions in MODULE specification statements
KEYWORDS: USE associated, intrinsic function, MODULE, specification expression
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Consider a module that references an intrinsic function in a 
specification expression which declares a public data object in the 
specification part of the module.  Section 11.3.2 states

   "The local name of an entity made accessible by a USE statement may 
    appear in no other specification statement that would cause any 
    attribute (5.1.2) of the entity to be respecified in the scoping
    unit that contains the USE statement, except that it may appear in 
    a PUBLIC or PRIVATE statement in the scoping unit of a module."

The question centers on whether a scoping unit which uses such a module
gains access to the intrinsic procedure through use association.  
Specifically,
are the following two cases standard conforming?

     Case 1:
       MODULE SPEC
         PARAMETER (J = 3)
         DIMENSION ARRAY (IABS(10 - J)) ! Reference to IABS
       END MODULE

       PROGRAM USER
         USE SPEC
         REAL,DIMENSION (100)  :: IABS  ! Legal to respecify IABS?
         ...
       END

    Case 2:
       MODULE SPEC
         PARAMETER (J = 3)
         INTRINSIC IABS                 ! IABS explicitly declared INTRINSIC
         DIMENSION ARRAY (IABS(10 - J)) ! Reference to IABS
       END MODULE

       PROGRAM USER
         USE SPEC
         REAL,DIMENSION (100)  :: IABS  ! Legal to respecify IABS?
         ...
       END

ANSWER: Neither case is standard conforming.

Discussion:
In both cases, IABS denotes an intrinsic procedure in module SPEC.
Procedures are entities which may be made accessible by USE association,
and in the absence of a PRIVATE declaration applicable to IABS, they are
made accessible.  Thus, the cited restriction applies and the examples
do not conform.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDIT: None

SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 1992 11 10, new
HISTORY: Initially drafted as X3J3/92-205
   Response in X3J3/92-278 - 
   approved by unanimous consent at meeting 123

--------------------------------------------------------------------------

NUMBER: 000079
TITLE: Automatic character and ALLOCATABLE, 
POINTER and TARGET attributes
KEYWORDS: Allocatable, automatic, array, character, 
pointer, target
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress
     
QUESTION: Section 5.1 states:
     
   The specification-expr (7.1.6.2) of a type-param-value
   (5.1.1.5) or an array-spec (5.1.2.4) may be a nonconstant
   expression provided the specification expression is in an
   interface body (12.3.2.1) or in the specification part of a
   subprogram.  If the data object being declared depends on the
   value of such a nonconstant expression and is not a dummy
   argument, such an object is called an automatic data object.
   An automatic object must not appear in a SAVE or DATA
   statement nor be declared with a SAVE attribute nor be
   initially defined with an = initialization-expr.
     
Thus, a character object with a length-selector which is a
nonconstant type-param-value is an automatic object.
     
Section 5.1.2.9 states:
     
   The ALLOCATABLE attribute specifies that objects declared in
   the statement are allocatable arrays.  Such arrays must be
   deferred-shape arrays whose shape is determined when space is
   allocated for each array by the execution of an ALLOCATE
   statement (6.3.1).
     
The standard does not appear to prohibit allocatable arrays of
automatic objects.
     
Question 1: Is it the intent to allow allocatable arrays of
automatic character?
     
      FUNCTION FRED (J)
      CHARACTER(LEN=J),DIMENSION(:),ALLOCATABLE :: CH
      ALLOCATE (CH(100))
     
Question 2: If allocatable arrays of automatic objects are allowed,
is it correct to assume the array must not have the SAVE attribute?
     
Question 3: Character length is part of a character entity's type
and type parameters.  Was it intended that character entities whose
length is specified by a variable expression or a * (assumed length
character) be allowed to also have the POINTER or TARGET attribute?
     
The third constraint of Section 7.5.2 states
     
   The target must be of the same type, type parameters, and rank as
   the pointer.
     
In general, there should be no problem with allowing the POINTER and
TARGET attribute for automatic arrays.  However, there is a problem
if TARGET is intended to be allowed for automatic character, both
scalar and arrays, where the length is specified by a variable
expression.  Character length is part of the type and type
parameters, but where length is specified by a variable, the above
constraint cannot be diagnosed at compile time.  Was it the intent
to allow the TARGET attribute on any automatic objects, only on
automatic arrays except where character length is specified by a
variable expression, or for no automatic objects? If the intent is
to allow TARGET on all automatic objects, the above constraint must
be relaxed as it cannot be detected at compile time.
     
--------------------------------------------------------------------
     
FIRST POSSIBILITY:
     
ANSWER: The intent of the standard is to allow pointers and
allocatable arrays of character type whose length is specified by a
variable expression.  Such arrays must not have the SAVE attribute
specified.  The third constraint of section 7.5.2 cannot be
diagnosed at compile time and is relaxed by one of the supplied
edits.
     
REFERENCES: ISO/IEC 1539:1991 sections 5.1, 5.1.2.9, 7.5.2 and
14.7.5.
     
EDITS:
     
In the third constraint of section 7.5.2 delete ", type
parameters,".
     
Add at the beginning of the paragraph following the constraints of
section 7.5.2, "The target must have the same type parameters as the
pointer."
     
In 14.7.5, item (17), add at the end of the sentence, "unless the
object has the POINTER or ALLOCATABLE attribute".
     
--------------------------------------------------------------------
     
SECOND POSSIBILITY:
     
ANSWER: The intent of the standard is to prohibit pointers and
allocatable arrays of character type whose length is specified by a
variable expression.  An edit is supplied to clarify this
prohibition.  Also, the third constraint of section 7.5.2 cannot be
diagnosed at compile time for automatic character targets or targets
that are character dummy arguments with assumed length and,
therefore, is relaxed by one of the supplied edits.
     
REFERENCES: ISO/IEC 1539:1991 sections 5.1, 5.1.2.9, and 7.5.2.
     
EDITS:
     
Section 5.1, add to the list of constraints: "The POINTER and
ALLOCATABLE attributes must not be specified for an automatic data
object."
     
In the third constraint of section 7.5.2 delete ", type
parameters,".  Add at the beginning of the paragraph following the
constraints of section 7.5.2, "The target must have the same type
parameters as the pointer."
     
     
SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 12 Nov 92 Both responses rejected at
                           meeting 123
HISTORY: Initially drafted as X3J3/92-206
         92-206b/"Second Possibility" rejected at meeting 123 (14-5)
           [less than INT(membership/2)+1]
         92-206b/"First Possibility" rejected at meeting 123 (9-9)

--------------------------------------------------------------------------

NUMBER: 000080
TITLE: Vector subscripts in masked array assignment statements
KEYWORDS: vector subscripts, WHERE statement, WHERE 
construct, array assignment
DEFECT TYPE: Erratum
STATUS: X3J3 draft response
     
QUESTION: Is there a restriction on vector subscripts in masked array 
assignments?
     
Question 1: Is it intended to allow vector subscripts in masked
array assignment statements?
     
Question 2: If the answer to question 1 is "yes", is the intent that
the following two programs are semantically equivalent; that is,
should they print the same results?
     
      PROGRAM ONE
      INTEGER, DIMENSION(5)  :: INDEX, J, K
      INDEX = (/ 1, 2, 3, 4, 5 /)
      J     = (/ 1, 2, 1, 1, 2 /)
      K     = (/ 1, 1, 2, 2, 2 /)
      WHERE (J == K)
        J(INDEX) = 0
      ELSE WHERE
        J(INDEX) = 1
      END WHERE
      PRINT *, J
      END
     
      PROGRAM TWO
      INTEGER, DIMENSION(5)  :: INDEX, J, K
      LOGICAL, DIMENSION(5)  :: MASK
      INDEX = (/ 1, 2, 3, 4, 5 /)
      J     = (/ 1, 2, 1, 1, 2 /)
      K     = (/ 1, 1, 2, 2, 2 /)
      MASK = J == K
      DO I = 1, 5
         IF (MASK(I)) J(INDEX(I)) = 0
      END DO
      DO I = 1, 5
         IF (.NOT.MASK(I)) J(INDEX(I)) = 1
      END DO
      PRINT *, J
      END
     
ANSWER: The answer to questions 1 and 2 is yes.
     
Discussion: Vector subscripts are allowed in masked array assignment
statements.  Section 7.5.3.2 describes the interpretation of vector
subscripts in <mask-expr> and in the <expr> of an <assignment-stmt>.
However, the interpretation of <variable> in <assignment-stmt> is
not completely defined.  If <variable> is an array section, for
example, and a nonelemental function reference occurs within a
<section-subscript>, the interpretation is not specified.  The edits
below correct this.
     
REFERENCES: ISO/IEC 1539:1991 (E) section 7.5.3.2, section 6,
section 6.2.2.
     
EDIT(S):
   In the second paragraph of section 7.5.3.2 after <expr> [93:29],
   add "or <variable>".
     
   In the third paragraph of section 7.5.3.2 after <expr> [93:34],
   add "or <variable>".
     
SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 92-11-13
HISTORY: Submitted as X3J3/92-207 at meeting 123
         Response in X3J3/92-291 approved at meeting 123 (UC)
     
--------------------------------------------------------------------------

NUMBER: 000081
TITLE: Pointer actual argument overlap
KEYWORDS: Pointer, target, actual argument, dummy argument, 
argument associated 
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  Section 12.5.2.9, Restrictions on entities associated with 
dummy arguments, clearly states that if there is partial or complete 
overlap between actual arguments associated with two different dummy 
arguments of the same procedure, the overlapping portions may not be 
defined, redefined, or undefined during the procedure execution.  
It goes on to say:

   This restriction applies equally to pointer targets.  For example , in

   REAL, DIMENSION (10), TARGET :: A
   REAL, DIMENSION (:), POINTER :: B, C
   B => A (1:5)
   C => A (3:9)
   CALL SUB (B, C)

   B (3:5) cannot be defined because it is part of the actual argument 
   associated with the second dummy argument.  C (1:3) cannot be defined
   because it is part of the argument associated with the first dummy 
   argument.  A (1:2) [which is B (1:2)] remains definable through the 
   first dummy argument and A (6:9) [which is C (4:7)] remains definable
   through the second dummy argument.

Unfortunately, this example and does not contain an explicit interface for 
the called subroutine, nor are there sufficient words to clearly state what
is meant by the words and example provided. 

Question 1: Do the above restrictions hold when both dummy arguments 
are non-pointers?  In this case the following interface describes SUB.

      INTERFACE 
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        END SUBROUTINE
      END INTERFACE

Question 2: Same as question 1, only add the TARGET attribute to one 
or both of the dummy arguments. The following interfaces may 
describe SUB.

      INTERFACE 
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:), TARGET :: X, Y
        END SUBROUTINE
      END INTERFACE

or

      INTERFACE 
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        TARGET X
        END SUBROUTINE
      END INTERFACE

Question 3: Do the above restrictions hold *upon entry* when both 
dummy arguments are pointers?  That is, *upon entry* to SUB, is it 
safe to assume that pointer dummy arguments do not have overlapping 
elements which may get defined during execution of SUB?  (I realize 
it is legal through pointer assignment for the pointers to become 
associated with the same target during execution of SUB, this question 
is only about assumptions on entry to SUB.)  The following interface 
describes SUB.

      INTERFACE 
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:), POINTER :: X, Y
        END SUBROUTINE
      END INTERFACE

Question 4: Same as question 3, but one dummy argument is a pointer, 
one has the target attribute.  *Upon entry* to SUB, is it safe to assume 
a pointer dummy argument does not point to any elements of a target 
dummy argument which get defined during execution of SUB, but 
during the execution of SUB such an association may come to exist?  
The following interface describes SUB.

      INTERFACE 
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        POINTER X
        TARGET Y
        END SUBROUTINE
      END INTERFACE

Question 5: Two derived type dummy arguments each have a 
subobject (or a subobject of a subobject etc.) which are pointers 
with the same type, kind type parameter, and rank.  *Upon entry* 
to the subroutine, is it safe to assume such pointer subobjects do 
not have overlapping targets?  That is, in the following fragment, 
*upon entry* to SUB, is it safe to assume X%PTR_1 and Y%PTR_2 
cannot have overlapping target elements which get defined during 
execution of SUB?

       SUBROUTINE SUB (X, Y)
       TYPE A
         SEQUENCE
         REAL, DIMENSION(:), POINTER :: PTR_1
       END TYPE

       TYPE B
         SEQUENCE
         REAL, DIMENSION(:), POINTER :: PTR_2
       END TYPE

       TYPE (A) :: X
       TYPE (B) :: Y
     

Note: A form of the above was posted to f90interp.  The two 
responses are attached for reference.  I read 12.5.2.9 differently 
from John and Kurt, and they read it differently from one another. 

ANSWER:

Discussion:

REFERENCES: 

EDIT:

SUBMITTED BY: Jon Steidel
HISTORY: Submitted Meeting 123 X3J3/92-208 

--------------------------------------------------------------------------

NUMBER: 000082
TITLE: Host association, generic name
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: Consider the program fragment

         1        INTERFACE  F
         2           FUNCTION X(Y)
                    ...

         3        CONTAINS
                    ...
         4           INTEGER F(10)

         5           I = F(2)

Reading in 12.1.2.2.1, Host association:

     Stmt 4 defines F to be an object-name (item 5 in the list on page 164).

     Thus F is the name of a local entity and any entity of the host that
     has F as its nongeneric name is inaccessible (text following list on
     page 164).

     Therefore the generic name, F, in the host is accessible.

     With that, is F(2) in stmt 5 a reference to the generic name or to
     the array name?

ANSWER:

REFERENCES:
            ISO/IEC 1539:1991 (E) sections .....

EDIT:

SUBMITTED BY: Richard Weaver

LAST SIGNIFICANT CHANGE: , original requestor's draft

HISTORY:              <meeting no.>        <information>
	Submitted as X3J3/92-235
	Related question submitted in X3J3/92-209

--------------------------------------------------------------------------

NUMBER: 000083
TITLE: Generic Override of Intrinsic Procedure
KEYWORDS:
STATUS: X3J3 consideration in process

QUESTION:
Because we all like to look at example code, I'll start with that then point 
out what I'm looking for.  Consider if you will:

    INTERFACE sin
      REAL FUNCTION my_sin(x)
        REAL, INTENT(IN) :: x
      END FUNCTION 
    END INTERFACE

My question is this:  Can a generic interface that has the same name as an 
intrinsic procedure override an existing intrinsic procedure?  That is, can a
user provide a generic interface definition such as shown above where the
intent is to invoke the user routine MY_SIN when the generic name SIN is
referenced with an argument of type default real?

Now for some background:  The only reference I've been able to find anywhere
in the standard that hints that a user can extend an intrinsic procedure is 
the following sentence from 14.1.2.3:

    When an intrinsic procedure, operator, or assignment is extended,
    the rules apply as if the intrinsic consisted of a collection of
    specific procedures, one for each allowed combination of type,
    kind type parameter, and rank for each argument or operand.

I interpret this sentence to rule the above example to be NOT standard
conforming.  My reasoning is thus:  The portion of the sentence beginning 
"the rules apply..." tells me that there is a "hidden" generic interface 
for SIN that looks something like:

    INTERFACE SIN
      REAL FUNCTION default_real_sin(x)
        REAL, INTENT(IN) :: x  
      END FUNCTION
      REAL FUNCTION real_first_kind_sin(x)
        REAL(KIND=<some value>), INTENT(IN) :: x
      END FUNCTION
      REAL FUNCTION real_second_kind_sin(x)
        REAL(KIND=<some other value>), INTENT(IN) :: x
      END FUNCTION
      ...
      COMPLEX FUNCTION CSIN(x)
        COMPLEX, INTENT(IN) :: x  
      END FUNCTION
      ...
    END INTERFACE

We know from 11.3.2 that if a user supplies a generic interface with the name
SIN, such as in my first example, the user interface will be "unioned" with 
the "hidden generic intrinsic" interface.  By the rules of chapter 14 for 
determining which specific interface to invoke, it will be discovered that the
MY_SIN specific interface and the DEFAULT_REAL_SIN specific interface are 
ambiguous.  Thus, I conclude that a a user can NOT redefine the interface of 
an existing intrinsic procedure; a user can only EXTEND the interfaces (such 
as defining a specific interface for SIN that accepts an argument of type 
logical).  This conclusion is consistent with the rules for overloading 
intrinsic operators that prohibit a user interface from redefining, say, "+"
for two integer operands.  

Do you agree with my interpretation?

ANSWER:

Discussion:

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.3.2, 12.3.2.1, 14.1.2.3, and
				14.1.2.4.1

EDIT(S):

SUBMITTED BY: Larry Rolison

LAST SIGNIFICANT CHANGE:

HISTORY: Submitted as X3J3/92-210, meeting 123

--------------------------------------------------------------------------

NUMBER:  000084
TITLE:  Change masked array assignment constraint to prose
KEYWORDS:  masked array assignment, WHERE statement, 
WHERE construct, shape, constraint
DEFECT TYPE:  Erratum
STATUS:  X3J3 draft response

QUESTION:  

The first constraint following rule R743 on page 93 states:

    Constraint:  In each assignment-stmt, the mask-expr and the variable
                 being defined must be arrays of the same shape.

However, it may be impossible to determine that the mask-expr and the variable
being defined are of the same shape at compile time.  A program can be
constructed quite easily in which the shapes of these entities are determined 
dynamically at run time.  For example:

           INTEGER array_1(100), array_2(100), start, end
           READ(5,*) start, end, array_1, array_2

  	WHERE (array_1(start:end) .NE. 0)
       	      array_2(start:end) =			&
               	 array_2(start:end) / array_1(start:end)
	   ENDWHERE

The term "shape" is defined in section 2.4.5 Array (page 15) as follows:

    The shape of an array is determined by its rank AND ITS EXTENT IN 
    EACH DIMENSION, and may be represented as a rank-one
    array whose elements are the extents.

Since all constraints are intended to provide additional information to (or 
in some cases limit) the BNF syntax rules and are intended to be determinable 
at compile time, and since the extents of a mask-expr or variable in a masked
array assignment can not always be determined at compile time, this constraint
is in error and should be changed from a constraint to a prose restriction.

ANSWER: Yes, the constraint should be changed.

REFERENCES:

ISO/IEC 1539:1991 (E) sections 7.5.3.1 and 7.5.3.2, in particular the first
contraint following rule R743 on page 93.

EDIT:

  1. Delete the first constraint following rule R743 on page 93.  Use the 
     constraint body as the new first paragraph of section 7.5.3.2.

SUBMITTED BY:  Larry Rolison

HISTORY:      Submitted as X3J3/92-211 at Meeting 123.
                        Approved at meeting 123 (uc)

--------------------------------------------------------------------------

NUMBER:  000085
TITLE:  Nondefault Integer Data Type for UNIT=, RECL=, and REC= Specifiers
KEYWORDS:  unit, data type
DEFECT TYPE:  Interpretation
STATUS:  X3J3 draft response

QUESTION:  Rules R902, R905, and R912 allow any type of integer for UNIT=,
RECL=, and REC= respectively.  Should a nondefault integer data type be
allowed for these specifiers in the <io-control-spec-list>?

ANSWER:  Yes.  The standard is consistent in requiring default KIND scalar
integer variables in I/O statements when values are returned to the program
in such a variable.  When an integer value is required as the value for an
I/O specifier in any of <connect-spec-list>, <close-spec-list>,
<io-control-spec-list>, <position-spec-list>, and <inquire-spec-list>, but no 
value is returned for that specifier, then any KIND of scalar integer 
expression is consistently allowed.

REFERENCES: ISO/IEC 1539:1991 (E) section 9.3, 9.3.4, and 9.4.1

EDITS: None

SUBMITTED BY: Joanne Brixius X3J3/92-212

HISTORY:  Questions submitted as X3J3/92-212, X3J3/92-213, and X3J3/92-243
	Approved as X3J3/92-274 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000086
TITLE: USE and Host Association
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress - content challenged as incomplete

QUESTION:

 Use association, 11.3.2 page 158, states

   "The USE statement provides the means by which a scoping unit access
   named data objects, derived types, interface blocks, procedures,
   generic identifiers (12.3.2.1), and namelist groups in a module."

 Host association, 12.1.2.2.1 page 163, says

   "An internal subprogram, a module subprogram, or a derived-type definition
   has access to the named entities from its host via host association.
   The accessed entities are known by the same name and have the
   same attributes as in the host and are variables, constants, procedures
   including interfaces, derived types, type parameters,
   derived-type components, and namelist groups."

  Question 1: Do USE and host association access the same entities?
              What entities does each access?

  Question 2: For both USE and host association, what entities are
              not accessed?

  Question 3: For host and use association, if the host or module referenced
   contains an EXTERNAL statement for ABC, is ABC an accessed entity that has
   the EXTERNAL attribute?  Note that an EXTERNAL statement is not a "named
   entity" (the statement has no name) and the procedure named in the
   statement is not in the host or module (that is why the EXTERNAL  
   statement).

   The answer to question 1 or 2 should also answer this question.


  Question 4: given the following

       PROGRAM  A           |   MODULE M
         USE X              |    USE Y
                            |
       CONTAINS             |
         SUBROUTINE B       |
          USE M             |

    is subprogram B associated in some way with X?  What way?  Note that A,
    the host of B, "accesses" entities in X via USE association; the
    entities in X are not "in" B's host.


  Question 5: in the same example

    is subprogram B associated in some way with Y?  What way?  As with
    question 4 note that the entities in Y are "accessed" from M; the
    entities in Y are not in M and USE association is to the entities
    "in the module".

  Question 6: given the following:

       Module a     ! level 1 host

       use aa
       interface f
        ...
       contains

       subroutine b ! module subroutine, level 2 host
       use bb
       interface f
       ....

         contains
         subroutine c ! internal subprogram
         use cc
         interface f
         ...
         .... = f(x)  ! an invocation of the generic name f

    and where modules aa, bb, and cc all contain a generic interface for f:

    How is the invocation of the generic name f resolved? (in what sequence
    are which hosts and uses considered?)

    Note the levels of nesting:  a contains b contains c.  Section 14.1.2.4.1,
    Resolving procedure references to names established to be generic,
    (3), seems to consider only "b", the host of "c", and not "a".


ANSWER:

  Answer 1: Entities declared PRIVATE are potentially accessible by
    host association but not by USE association.  Otherwise, it was
    intended that the classes of entities made accessible by these two
    forms of association be the same.  These are named data objects
    (including both constants and variables), derived types (including
    the components of those types), procedures (both those defined in
    the host or module and those declared there and defined
    elsewhere; both those identified by names and those identified by
    other generic identifiers), and namelist groups.
    
  Answer 2: Entities not in the preceding list are not made accessible.
    For example, FORMAT statement labels, construct names, and common
    block names are not made accessible.
    
  Answer 3: In such an example, ABC would be accessible.  In the host or
    module, ABC would denote a procedure and thus be potentially an
    accessible entity; it is not necessary that the definition of ABC be
    present in the host or module.

  Answer 4: The entities of module X made accessible in A by USE association
    are made accessible in B by host association.  Note that each such
    entity has a local name (or other identifier) in A.

  Answer 5: The entities of module Y made accessible in M by USE association
    are made accessible in B by USE association.  Note that each such entity
    has a local name (or other identifier) in M.

  Answer 6: In effect, first c and cc are checked, then b and bb, then
    a and aa, and finally (if f were the generic name of an intrinsic
    function) the intrinsics.

    In applying 14.1.2.4.1 to a reference in c, item (1) provides the
    check of interfaces in c (including those made accessible from cc),
    and item (3) provides for a recursive application of 14.1.2.4.1 to
    b.  In this recursive application, (1) checks b (and bb), and (3)
    results in a further recursive application of 14.1.2.4.1 to a.  In
    this application, (1) checks a (and aa), (3) is not applicable, and
    (4) checks the intrinsics.

    14.1.2.3 establishes that there must be no ambiguity in distinguishing
    the interfaces declared in c from those made accessible from cc.

REFERENCES:
  ISO/IEC 1539:1991 (E) sections 11.3.2, 12.1.2.2.1, 14.1.2.3, and 14.1.2.4.1.

EDIT: none

SUBMITTED BY: Richard Weaver

LAST SIGNIFICANT CHANGE: 1992 11 10, new

HISTORY:  Submitted in X3J3/92-214
	Response proposed in 92-281 - meeting 123 
	(vote of 11-7 was insufficient for approval)

--------------------------------------------------------------------------
NUMBER: 000087

not assigned

--------------------------------------------------------------------------

NUMBER: 000088
TITLE: Common block names and local names
KEYWORDS: common block name, local name
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: Section 12.1.2.2.1 says

    A name that appears in the scoping unit as

    (5) an object name in an entity-decl ...

    ... is the name of a local entity and any entity of the host that
    has this as its nongeneric name is inaccessible.


  Is this consistent with 14.1.2.1 "Common Blocks" ?


ANSWER: Yes.  Accessibility does not apply to common block names.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.1.2.2.1, 14.1.2.1.

EDIT: None

SUBMITTED BY: Dick Weaver

LAST SIGNIFICANT CHANGE: 92-11-11, first draft response

HISTORY: Submitted as X3J3/92-219
	Response proposed in X3J3/92-324, meeting 123
	(vote of 14-6 was insufficient for approval)

--------------------------------------------------------------------------

NUMBER: 000089
TITLE:  Errors in the DATA statement description
KEYWORDS:  DATA statement, data-stmt-value-list, data-stmt-constant
DEFECT TYPE:  
STATUS:  X3J3 consideration in progress

QUESTION:

The description of the values in the data-stmt-value-list on page  53, lines
4-20 contains a recurring flaw.  This section continually refers to the 
constant values in the list as simply "constants".  A structure constructor 
is not a constant; rather it is a constant expression.  This is demonstrated 
by:

    * The definition of "constant" in 2.4.3.1.2.  There are only two broad
      categories of constants defined:  named constants and literal constants.

    * The syntax rules for "constant" (page 20, rules R305-R309) reinforce  
      this definition by defining only two nonterminals:  literal-constant  
      and named-constant.

    * The description of the structure constructor on page 37 states:

          A structure constructor whose component values are all constant 
          expressions is a derived-type constant expression.


ANSWER:

Discussion:

REFERENCES:

EDIT:

Suggested edits:

   1. In rules R532 and R533, change "data-stmt-constant" to
      "data-stmt-constant-value".

   2. In the constraint that begins on line 26, change "data-stmt-constant" to
      "data-stmt-constant-value".

   3. The sentence beginning "Each such value..." on page 53, line 4 is an 
      analog to the second sentence in the constraint on page 52, beginning on
      line 23 and should likewise be made into a constraint.  We need not be
      concerned with adding any kind of constraint stating that if a constant
      list value is a structure constructor, the type definition must appear
      prior to the DATA statement because there are already other rules in
      place that cover this case.  The only case we need be concerned about
      is a named constant, which is the same as the repeat factor case.
      Thus, the changes are:

         a. Delete the sentence beginning "Each such value..." from page 53,
            lines 4-5.

         b. Delete the second sentence of the constraint on page 52,
            lines 23-25.

         c. Add a new constraint following the one on line 23:

              Constraint:  If the DATA statement repeat factor or constant
                           value is a named constant, it must have been
                           declared previously in the scoping unit or made
                           accessible by use association or host association.

   4. Page 53, line 6:  Change "following constant" to "following constant
      value".

   5. Page 53, line 11:  Change "constant" to "constant value".

   6. Page 53, line 17:  Change "constant" to "constant value".

   7. Page 53, line 18:  Change "constant" to "constant or structure
     constructor".

   8. Page 53, line 19:  Change "constant" to "constant or structure
      constructor".

SUBMITTED BY:  Larry Rolison

HISTORY:      Submitted as X3J3/92-221 at Meeting 123.

--------------------------------------------------------------------------

NUMBER: 000090
TITLE: Subroutine and Function names in nested scopes
KEYWORDS: procedure names, nested scopes
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: Section 12.1.2.2.1 says

    A name that appears in the scoping unit as

    (2) a function-name in a function-stmt ...

    (3) a subroutine-name in a subroutine-stmt

    ... is the name of a local entity and any entity of the host that
    has this as its nongeneric name is inaccessible.  Entities that are
    local (14.1.2) to a procedure are not accessible to its host.

 1. If this is true, how can hosts reference internal procedures, module
    procedures and interface blocks (the text in 2.2.3.3 pertains only
    to internal procedures and is somewhat vague) ?

 2. Are entities local to an interface body accessible to the host?
    (i.e., should the "Entities that are local ..." rule above be
    more general?)

ANSWER:
 1. The text cited from sections 12.1.2.2.1 and 14.1.2 contains errors.
    In order to allow internal procedures and module procedures to be
    referenced as described in sections 2.2.3.2 and 2.2.3.3, such
    procedures must be local entities of their hosts.  Edits are
    provided to make this change.

    Additional rules are then needed to prevent the name of a module
    procedure or internal procedure from conflicting with the
    names of local entities within the procedure.  These rules are
    similar in purpose and form to those for external procedures
    and are included in the edits below.

 2. No, entities local to an interface body are not accessible to
    the host.  This is part of the more general rule stated in the
    first two paragraphs of section 14.

      "Entities are identified by lexical tokens within a scope..."

      "By means of association, an entity may be referred to... in a
       different scoping unit..."

    Thus, in the absence of association, an entity is not accessible
    in different scoping units.  The statement in section 12.1.2.2.1 that
    "Entities that are local (14.1.2) to a procedure are not accessible to
    its host" is a specific case of the general rule.  Although redundant,
    this specific elaboration is made for host association to clarify that
    host association is uni-directional.

    Host association does not apply to interface bodies.  The first
    sentence in section 12.1.2.2.1 lists the kinds of scoping units
    that have host association; this list does not include interface
    bodies.  The penultimate paragraph of section 12.1.2.2.1 makes it
    explicit that this omission was intentional.

    Note also that nothing references interface bodies (or interface
    blocks).  An interface body serves only to provide an explicit
    interface for a procedure as described in sections 12.3.1 and
    12.3.2.1.  It is the procedure, not the interface body, that
    may be referenced.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2.3.2, 2.2.3.3, 12.1.2.2.1,
12.3.1, 14, 14.1.2

EDITS: In section 12.1.2.2.1, second paragraph, third sentence [164:1-2],
replace the initial word "A" with "The name of a contained internal
procedure or a".

In the second paragraph of section 12.1.2.2.1,
in item (2) [164:4], delete "in a function-stmt," and also
delete the comma preceding the "or".

Delete items (3) and (4) [164:6-7] and renumber the rest.

In item (1) of the first sentence of section 14.1.2 [241:24],
change "internal procedures" to "contained internal procedures"
and change "module procedures" to "contained module procedures".

Add a new paragraph after the second paragraph of section 14.1.2 [241:31+].
  "Within a scoping unit that defines an internal procedure or a
   module procedure, the name of the procedure must not be used to
   identify a global entity or a local entity of class (1) in that
   scoping unit."

SUBMITTED BY: Dick Weaver

LAST SIGNIFICANT CHANGE: 92-11-11, first draft response

HISTORY: Submitted as X3J3/92-220
	First draft response in X3J3/92-328

--------------------------------------------------------------------------

NUMBER: 000091
TITLE: Constraint diagnosis for SEQUENCE attributes
KEYWORDS: SEQUENCE, modules, constraints
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: 

	Must the following constraints be diagnosed when the
	criteria for the constraint is violated or confirmed
	across module definitions?

	More specifically should the following two constraints:

	The third constraint following R522:

	(p. 49/l. 26-28):  A module procedure that has a dummy argument
		  or function result of a type that has PRIVATE
		  accessibility must have PRIVATE accessibility...

	The third constraint following R424:

	(p. 33/l. 10-11):  If a component of a derived type is of a type
		  declared to be private, either the derived type
		  definition must contain the PRIVATE statement or the
		  derived type must be private.

	be diagnosed in the following program?:

	MODULE a
	   TYPE x
	      INTEGER :: i
	   END TYPE x
	   TYPE y
	      TYPE (x) :: r    ! note component of type x
	   END TYPE y
	CONTAINS
	   FUNCTION f()	       ! module function of type x
	      TYPE(x) :: f
	   END FUNCTION f
	END MODULE a

	MODULE b
	   USE a
	   PRIVATE :: x	      ! note component of type y now has
		      ! a private sequence attribute
		      ! note also that module function f now
		! has private attribute
	END MODULE b


ANSWER:  

Discussion:

REFERENCES:
            ISO/IEC 1539:1991 (E) sections 4.4.1, 5.2.3 and 1.4.

EDIT:

SUBMITTED BY:  Maureen Hoffert

HISTORY:  Submitted at 123 in X3J3/92-225

--------------------------------------------------------------------------

 NUMBER: 000092
 TITLE: Pointer and Storage Association
 KEYWORDS: pointer association, Storage association, ASSOCIATED
 DEFECT TYPE: Interpretation
 STATUS: X3J3 consideration in progress

 QUESTION: Consider the following example program:

       PROGRAM PROG
         INTEGER         :: VAR
         COMMON /COM/ VAR
         VAR = 5
         CALL SUB
       END PROGRAM PROG
       SUBROUTINE SUB
         INTEGER,POINTER :: PTR
         INTEGER,TARGET  :: TGT
         COMMON /COM/ TGT
         PTR => TGT
         ...
       END SUBROUTINE SUB

 Is the pointer assignment legal? Although the entity named TGT was
 declared with the TARGET attribute, a storage associated entity,
 VAR, was not.

 ANSWER: ...

 Discussion: ...

 REFERENCES: ISO/IEC 1539:1991 (E) sections ...

 EDIT: None.

 SUBMITTED BY: Len Moss
LAST SIGNIFICANT CHANGE:
 HISTORY:  Issue arose during Victoria (1992) WG5 meeting, while
              reviewing various questions concerning 120.121(27)
           Separate request submitted following meeting 121
           Submitted as X3J3/92-226 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000093
 TITLE: Scalar Pointer Function Results
 KEYWORDS: function results, pointer attribute
 DEFECT TYPE: Erratum
 STATUS: X3J3 consideration in progress

 QUESTION: May a scalar function result have the pointer attribute?

 ANSWER: ...

 Discussion: ...

 REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1.2.4.3 and ...

 EDIT: ...

 SUBMITTED BY: Len Moss

 HISTORY:  Submitted as X3J3/92-227 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000094
TITLE: Varying length function result, implied-DO loop
KEYWORDS:  implied-DO, WRITE, function
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

     An example of an array-result function is:

          FUNCTION F(I)
          DIMENSION F(I)
          ...
          END

Question 1:

     If this function is used in an output list with an implied-DO:

          WRITE(6,100) (F(I), I=1,N)

     Does the output list consist of N arrays of the array-result of function
     F(I) or does the output list consist of N array element references of
     F(I)?

Question 2:
     A more complicated example is the use of a multidimensional array:
  
          FUNCTION F(I,J)
          DIMENSION F(I,J)
          ...
          END

     The function is used in an output list with an implied-DO:

          WRITE(6,100) ((f(I,J), I=1,N), J=1,K)

     Does the output list consist of N*K arrays of the array-result of  
     function F(I)?

Question 3:

     An example of a character variable-length array-result function is:

          FUNCTION F(I,J)
          DIMENSION F(I)
          CHARACTER(LEN=J) F
          ...
          END

     The function is used in an output list with an implied-DO:

          WRITE(6,100) ( ( F ( I, J ), I=1,N ), J=1,K )

     Does the output list consist of N*K different sized arrays of varying
     character length function results?


Question 4:

     Should an implied-DO loop in an output statement be restricted to
     a scalar function result?  The DATA statement <data-i-do-object> is
     limited to an array element, a <scalar-structure-component>, or a
     <data-implied-do>.  See R536 in section 5.2.9.

ANSWER:

    1) The output list consists of N arrays of the array-result of
       function F(I).
    2) Yes.
    3) Yes.
    4) No.


REFERENCES: ISO/IEC 1539:1991 (E) sections 12.4, 12.4.2, and rule R1209.

EDIT: None.

SUBMITTED BY:  Joanne Brixius X3J3/92-230

HISTORY: Submitted as X3J3/92-230
	Approved as X3J3/92-292 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000095
TITLE: Varying length function result, implied-DO loop
KEYWORDS:  implied-DO, INQUIRE, IOLENGTH, function
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

     In section, 9.6.3, page 134, the INQUIRE with IOLENGTH specifier is
     described.

     The use of implied-DO and function references in an output list
     impacts the INQUIRE statement that used the IOLENGTH specifier with
     an output list.
   
An example of a array-result function is:

          FUNCTION F(I)
          DIMENSION F(I)
          INTEGER I
          REAL F(I)
          ...
          END

QUESTION 1:

     If the function is used in an output list with an implied-DO:

          INTEGER ISIZE
          INQUIRE(IOLENGTH=ISIZE) (F(I), I=1,N)

     Does the output list consist of N arrays of the array-result of function
     F(I) or does the output list consist of N array element references of
     F(I)?  See Question 3.

     The function F(I) must be referenced N times to be able to determine
     the size of the result.  The size of the function result cannot be
     determined by a declaration of the function in the caller.  The
     function must be executed to determine the size of the result.

QUESTION 2:

     An example of a character variable-length array-result function is:

          FUNCTION F(I,J)
          DIMENSION F(I)
          INTEGER I,J
          CHARACTER(LEN=J) F
          ...
          END

     The function is used in an output list with an implied-DO:

          INQUIRE(IOLENGTH=ISIZE) ( ( F ( I, J ), I=1,N ), J=1,K )

     Does the output list consist of N*K different sized arrays of varying
     character length function results?  The actual size of the result can
     only be determined by executing the function.


QUESTION 3:

     Should an implied-DO loop in an INQUIRE statement with an IOLENGTH 
     specifier be restricted to a scalar function result?  The DATA
     statement <data-i-do-object> is limited to an array element, a
     <scalar-structure-component>, or a <data-implied-do>.  See R536 
     in section 5.2.9. This would allow the determination of the size of 
     a function reference without actual execution of the function.

ANSWERS:

    1) The output list in the INQUIRE statement "references" the function
       "F" N times.  Each reference returns an array valued result.  This
       is not necessarily a reference in the sense of an actual function
       call.
   
       Your statement about referencing the function is not correct.
       An implementation is allowed to call the function if it
       so wishes, but is not required to do so.  In the presence of an
       explicit interface it is possible some implementations will not
       call the function, or may call it fewer than N times.

    2) The output list consists of N*K different sized arrays of varying
       length character function results.

       The implementation is not required to actually call the function.

    3) No.

REFERENCES:
    ISO/IEC 1539:1991 (E) sections 9.6.3, 7.1.7.1

EDIT(S): None.

SUBMITTED BY:  Joanne Brixius X3J3/92-231
LAST SIGNIFICANT CHANGE:
HISTORY:  Submitted as X3J3/92-231
	Approved as X3J3/92-311 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000096
TITLE: Definition of "Declaration"
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: "Declaration" is a significant concept of Fortran 90.

          Section 5 is titled "Data object declarations and specifications"
          and what were in Fortran 77 "type statements" are now
          "type declaration statements".  5.1.1 says "A type specifier
          specifies the type of all entities declared in an entity
          declaration list."

          Nowhere, though, can I find a definition of "declaration".

          What does it mean, in Fortran 90, to "declare" something?


ANSWER:
          We will add a definition of "declaration" to the glossary.
          For clarity, we will also add a definition of "specification".

REFERENCES:
            ISO/IEC 1539:1991 (E) sections .....

EDIT:
          add to page 260 after "size" [260:14+]

              Specification: a specification assigns attributes
                and properties to named data objects.

          add to page 256 after "datum" [256:10+]

              Declaration: The process of specifying an attribute or
                a property of a named data object.

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11
HISTORY: Submitted as X3J3/92-232
	Draft response in X3J3/92232r, withdrawn for rconsideration
 
--------------------------------------------------------------------------

NUMBER: 000097
TITLE: Specification Expression
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTIONS:  In section 7.1.6.2 "Specification expression":

   1. In item (9) should not the restriction "defined by an ALLOCATE
      statement" be "allocatable" instead? That is, the ALLOCATE statement
      does not have to exist, it is being allocatable -- even if never
      allocated -- that is restricted. [79:14-15]

      And the same comment re pointer assignment. [79:14-15]

   2. Would Item (9) be clarified if "local" were inserted before "variable"?
      [79:14]

   3. In the text beginning "and where any subscript ..." should not
      "is" be "must be"? As written it says that any subscript is a
      restricted expression. [79:17]

   4. In the text beginning "A specification expression (R509, R514, R515)...
      should not the "(R509, R514, R515)" be deleted?  

ANSWER:
   1. Yes, see edits below. Edits are provided for similar problems in other  
      sections.

   2. No.

   3. No, this is part of a long and complex sentence which begins on
      the previous page.  'Is' is the correct form and parallels the
      rest of the sentence and describes what a restricted expression 'is',
      not what a subscript is.

   4. There is redundancy, but not an error.

REFERENCES: ISO/IEC 1539:1991 (E) sections .....

EDIT:
   Replace "defined by an ALLOCATE statement or pointer assignment"
   With    "a variable that does not have the allocate or pointer attribute"

   in 7.1.6.1 (6), in the first list   [77:27-28]
      7.1.6.1 (6), in the second list  [78: 9-10]
      7.1.6.2 (9)                      [79:14-15]

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11
HISTORY: Submitted as X3J3/92-233r at meeting 123        

--------------------------------------------------------------------------

NUMBER:  000098
TITLE:  KIND param and list directed I/O
KEYWORDS:  unit, data type
DEFECT TYPE:  Erratum
STATUS:  X3J3 draft response

QUESTION:  In an I/O record, can the kind-param of a constant be a named 
constant?

ANSWER:  No.  Section 5.1.2.1 which describes where and when named constants 
are allowed does not discuss named constants in the context of an I/O record;
therefore, named constants are not allowed in an I/O record.  The edit below
clarifies what the committee intended, by specifically addressing
values in I/O records.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.1.2.1

EDITS: In section 5.1.2.1, after the sentence "A named constant must not 
appear
within a format specification (10.1.1)." add the following sentence:
    "A named constant must not appear within an I/O record (9.1)."

SUBMITTED BY: Joanne Brixius X3J3/92-234
HISTORY:  Submitted as X3J3/92-234
	Approved as X3J3/92-273r2 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000099
TITLE: Generic interfaces
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:

     11.3.2, page 158, pp beginning "If two or more" says that:

        If two or more generic interfaces that are accessible in a scoping
        unit have the same name, ..., they are interpreted as a single
        generic interface.

     14.1.2.4.1, page 244, says

        (1) If the reference ... of an interface block that has that name
        and either is contained in the scoping unit ... or is made
        accessible by a USE statement...

        (3) ... if the name is established to be generic in that host scoping  
                unit ...

Question 1:
     What section 11 seems to say will be treated as a single interface is,
     in Section 14, actually treated as individual interfaces.
     Which is correct?

Question 2:
     If the text from 11.3.2 above applies to more than just USE association,
     should it be moved to 12.3.2.1 "Procedure Interface Block"?

ANSWER:

REFERENCES:
            ISO/IEC 1539:1991 (E) sections .....

EDIT:

SUBMITTED BY: Dick Weaver
HISTORY: Submitted as X3J3/92-236 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000100
TITLE: ASSOCIATED intrinsic and zero sized objects              
KEYWORDS: Associated, Zero sized objects, Target, Pointer
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: S20.122 interpretation number 000027 states what conditions must be
met for the two argument form of the ASSOCIATED intrinsic function to return 
a value of true.  It does not state what the behavior of the intrinsic is for
zero sized arguments.  

Question 1: Can the single argument form of the ASSOCIATED intrinsic return 
true as its result if the argument's target is zero sized?  

Question 2: Can the two argument form of the ASSOCIATED intrinsic return true
when both arguments are zero sized?    

The following need answers only if the answer to question 2 is yes.

Question 2a: If the arguments to ASSOCIATED are zero sized but of rank greater
than one, must the extents of each dimension be the same for ASSOCIATED to 
return true?  For example, what is printed by the following program?

       PROGRAM HUH
       REAL, DIMENSION(:,:),    POINTER :: P1, P2
       REAL, DIMENSION(10, 10), TARGET :: A
       P1 => A(10:9:1, :)
       P2 => A(:, 10:9:1)
       PRINT *, ASSOCIATED (P1, P2)
       END

Question 2b: In the following example, rank, shape, type, kind type 
parameters, and extent of dimensions of the zero sized arguments to 
ASSOCIATED match, but the second argument is not the same as the right hand 
side of the previous pointer assigment statement.   What is the output of 
this program?  (Does a notion of "base address" come to play for zero sized 
objects as it does for nonzero sized?)

       PROGRAM HMMM
       REAL, DIMENSION(:,:),    POINTER :: P1
       REAL, DIMENSION(10, 10), TARGET :: A
       P1 => A(:, 2:1:1)
       PRINT *, ASSOCIATED (P1, A(:, 3:2:1))
       END


ANSWER:

Discussion:

REFERENCES: 

EDIT:

SUBMITTED BY: Jon Steidel
HISTORY: Submitted as X3J3/92-240 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000101
TITLE:  Specification statements
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

| rev 1. Replaced the list from Metcalf & Reid Ch 7 with the list
  derived from the syntax in 5.2 of Reid & Metcalf, per note from John & Mike.
  (listing it as Reid & Metcalf sometimes is a result of speaking from the
  end of many alphabetical listings myself!)

| rev 2. Deleted FORMAT, ENTRY from Reid & Metcalf per e-mail suggestion.

-----------------------------------------------------------------------------

  QUESTION: The following list compares the specification statements
  from Fortran 77 (listed in chapter 8), those of Fortran 90 (R214, page8),
| and those of Metcalf & Reid "Fortran 90 Explained" per e-mail.

          Fortran 77        Fortran  90         Metcalf&Reid

                            access              access
                            ALLOCATABLE         ALLOCATABLE
|         COMMON            COMMON              COMMON
                            DATA                DATA
                                                derived-type-def
          DIMENSION         DIMENSION           DIMENSION
|         EQUIVALENCE       EQUIVALENCE         EQUIVALENCE
|         EXTERNAL          EXTERNAL            EXTERNAL
          IMPLICIT                              IMPLICIT
                            INTENT              INTENT
|                                               interface-block
|         INTRINSIC         INTRINSIC           INTRINSIC
                            NAMELIST            NAMELIST
                            OPTIONAL            OPTIONAL
          PARAMETER                             PARAMETER
                            POINTER             POINTER
          SAVE              SAVE                SAVE
|                                               stmt-function
                            TARGET              TARGET
          type-stmt                             type-stmt
                                                USE

I have in the past and I will in the future argue for changes in
terminology -- where those changes better align Fortran with common
usage in describing programming languages or facilitate the description
of Fortran.  However the changes above seem more accidental than
intended and, I am convinced, will make a users transition to Fortran 90
more onerous than it need be.

   -- patterns learned in Fortran 77 will not carry forward, for no
      apparent reason

   -- complexity is increased.  In describing Fortran 77 you could
      write "all specification statements must precede ..." (3-3, line 46).
|
|

   -- incompatible vendor documentation (some will follow the standard,
      some will pick up PARAMETER as M&R did, some will pick up EXTERNAL
|     as M&R did, ...) will make the writing of portable programs
      more difficult.

Question 1: While reclassifying DATA as a specification statement seems
an improvement, the deletions and not classifying some new statements
(see M&R, above) as specifications seems unfortunate.  Were these
changes in terminology intended or an accidental result of incorporating
statement sequencing rules into the BNF?

Question 2: Do you want to reconsider?

Question 3: In 11.3.3.1 page 159
should
  "A common block and all its associated specification statements
be changed to:
  "................................................... and type-declaration 
...

Question 4: In 12.3.2 page 167
should
  "... and by specification statements for the dummy arguments ..."
be changed to
  "........................ and type-declaration ....."

Question 5: In 12.5.2.2 page 175, in the first constraint
should
  "... any specification statement ..."
be changed to
  "... any specification or type-declaration statement ..."

Question 6: In 12.5.2.5 page 178, in the first constraint
(same question as 5, above).


ANSWER:

1)  Yes.  The changes in terminology were intended as a way to 
specify partially the statement ordering via the BNF.  The effect 
of losing the easy way to specify "specification" statements was 
unintentional.

2)  No.  Reverting to the FORTRAN 77 style would not be a benefit 
at this time.  This style will be reconsider in writing Fortran 9x, in 
particular the changes suggested in the question, items 3 through 6.

EDITS:
Section 11.3.3.1, [159:11] after "specification", 
add "and type-declaration"

Section 12.3.2 [167:7] after "specification", add
"and type-declaration"

Section 12.5.2.2, first constraint, [175:36] after "specification" add
"or type-declaration"

Section 12.5.2.5, first constraint, [178:1] after "specification" add
"or type-declaration"

SUBMITTED BY: Dick Weaver

HISTORY:              <meeting no.>        <information>
          92-244r2           123                      first submitted
          92-325              123                      initial response

--------------------------------------------------------------------------

NUMBER: 000102
TITLE: Returned value for INQUIRE POSITION= on an empty file
KEYWORDS: 
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Consider the following two cases

1. Reading an empty sequential file

         OPEN ... POSITION='REWIND'    !positioned at initial point
         READ ... END=                 !reads endfile record, positioned
                                       ! after endfile record
         BACKSPACE ...                 !positioned before endfile record
                                       ! which is also the initial point
         INQUIRE ... POSITION=

2. Writing an empty sequential file

         OPEN ... POSITION='REWIND'    !positioned at initial point
         ENDFILE ...                   !write endfile record, positioned
                                       !  after endfile record
         BACKSPACE ...                 !positioned before endfile record
                                       ! which is also the initial point
         INQUIRE ... POSITION=


In section 9.6.1.16, "POSITION= ..." appears to imply any of the
following can be returned by the INQUIRE statement in these three cases:

           processor dependent  - since the file has been repositioned
           REWIND               - since the file is now at its initial point
           APPEND               - since the file is now at its terminal point

Thus even for implementations that are specified to use REWIND and APPEND,
rather than a processor-dependent value, the standard would seem to be
ambiguous.  One implementation can return "REWIND" while another returns
"APPEND".  Is this ambiguity intended?

ANSWER:

Yes.  If the file has been repositioned since the OPEN
statement was executed, then the value returned by INQUIRE(POSITION=...) is
processor-dependent.  No particular value is required to be returned, but a 
few values are prohibited in certain cases.  The processor is free to return 
any value that is not specifically prohibited by section 9.6.1.16.

A standard-conforming program cannot depend on a particular value being
returned in this case.  If an implementation chooses to return "REWIND"
or "APPEND" after a file has been repositioned, the file must currently
be positioned at the same point as if it had just been opened with that
same value for the POSITION specifier in the OPEN statement.
An implementation must not return APPEND if the file is not positioned at
its terminal point or endfile record.  Similarly, it must not return REWIND
if the file is not positioned at its initial point.


This is not the same as saying that an implementation will return APPEND
when the file is positioned at its terminal point.  It need not.
But if it does return APPEND, then the program can be assured that the
file really is positioned at its terminal point or endfile record.

REFERENCES:
            ISO/IEC 1539:1991 (E) Section 9.6.1.16

EDITS: None.

SUBMITTED BY: Dick Weaver
HISTORY:  92-245 rev2, 92-245 rev3

--------------------------------------------------------------------------

NUMBER: 000103
TITLE: Statement Function with unreferenced dummy argument
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Consider the following example

    F (A, B, C ) = A + B    !statement function, dummy-arg C not used in expr
    INTEGER C

Since "C" is implicitly typed, must any later type definition 
(the INTEGER C in the example) confirm that typing?

ANSWER:  Yes.  This is covered in the second constraint in Section 12.5.4, 
page 182.  While that constraint appears to be about the scalar-expr "A+B", 
the last sentence, beginning "If a scalar...", applies to the dummy arguments
as well (the 2nd constraint combines what should have been two separate
constraints).

The constraint will be split and clarified.

REFERENCES:
            ISO/IEC 1539:1991 (E) sections .....

EDIT:  In section 12.5.4 split the second constraint at "If a scalar
       variable ..." [182:12] into a new constraint and add "dummy-arg,"
       just before "scalar variable".

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11
HISTORY:  Submitted as X3J3/92-249
	Approved as X3J3/92-249r at meeting 123 by a vote of 16-3

--------------------------------------------------------------------------

NUMBER:  000104
TITLE:  Rounding formatted output
KEYWORDS: rounding, formatted i/o
DEFECT TYPE: Interpretation
STATUS:  X3J3 draft response

QUESTION 1:
    The standard requires floating-point values to be rounded,
    on output (see 10.5.1.2.1 through 10.5.1.2.4).  It does not, 
    however, say how they are to be rounded.  Always rounding 
    up and always rounding down are allowed by the standard. 
    Was that intended?

QUESTION 2:
    The ISO/IEC 1539:1980 semantics for G edit descriptors
    assume that floating-point values are rounded down.  The
    ISO/IEC 1539:1991 semantics for G edit descriptors
    assume that floating-point values are rounded to nearest.
    If those assumptions are violated, the implementation is
    sometimes required to print strings of asterisks for
    numbers that a user might think should be printed normally.

    If the interpretation is that implementations must always
    round to nearest, to which nearest value must they round
    in the case of a value exactly between two representable
    values?

ANSWERS: 
    1) Yes.

    2) No particular rounding method is required by the standard.
       The above analysis of the effect of this on output formatting
       using the G edit descriptor in a formatted write statement is correct.

       This change from FORTRAN 77's behavior was made in order to
       suggest a particular preferred implementation, namely, round
       to nearest.  The committee believed that this change would promote
       portability of programs and consistency in implementations of I/O
       libraries, without actually requiring any particular rounding method.

       The standard's description for selecting between E and F editing,
       when the user specified a G edit descriptor, assumes that if
       a value to be printed is exactly between the two numbers obtained
       by rounding the original value up and down (to the appropriate
       number of decimal digits), then the magnitude of the value printed
       will be the absolute value of the original value rounded up.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.5.4.1.2

EDITS: None

SUBMITTED BY: Robert Corbett, X3J3/92-268
LAST SIGNIFICANT CHANGE:
HISTORY: Submitted as X3J3/92-268 
	Approved as X3J3/92-299 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000105
TITLE: Parallel Evaluation of Operands and Arguments
KEYWORDS: expression, operand, argument, function, parallel, concurrent
DEFECT TYPE: Amendment
STATUS: X3J3 consideration in progress

QUESTION: Does Fortran permit concurrent evaluation of operands
          in expressions and of actual arguments of functions?

ANSWER: Yes.

Discussion: The evaluation of a subexpression is not allowed to
"affect" the value of another part of the same statement
(ISO/IEC 1539:1991 (E) section 7.1.7).  Further, processors are
permitted "considerable flexibility" to evaluate expressions "in the
most efficient way possible" including flexibility in "the order
of argument evaluation" (Section C.12.5).  Part of the rationale is
to provide "latitude for optimization (for example, for parallel
processing)" (Section C.12.5).  Opportunities for optimization in
the form of parallel computation exist in expressions with more than
one operand or actual argument.  Fortran permits such optimizations,
and the standard should make this as clear as possible.  This will
increase the likelihood that emerging implementations on parallel
systems will take full advantage of their capabilities.

The lack of restrictions on the order in which function arguments
are evaluated is implicit in Sections 7.1.7 and 12.4.2 and explicit
in Section C.12.5.  All three sections imply that concurrent
evaluation is also an option.  The following edits will clarify the
point.  The edits to Section 12.4.2 will help avoid confusion on
the option of delaying argument evaluation (currently elucidated in
Section C.12.5), and the edits to Section C.12.5 will give the
option of concurrent argument evaluation the same level of attention
as options on order and timing.  Taken together, the edits will make
it clear that Fortran processors can overlap the evaluation of
operands and function arguments when this enhances efficiency, such
as, for example, when a processor has access to multiple arithmetic
processing units or pipelines.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 7.1.7, 12.4.2, & C.12.5

EDIT(S):

1. In Section 12.4.2, replace the second sentence, by "When it is
   invoked, the arguments are associated, and then the function is
   evaluated."

2. In Section 12.4.2, third sentence: replace the term "executed"
   with "evaluated".

3. In Section C.12.5, paragraph 4, second sentence: replace the
   phrase "evaluating an operand" by "evaluating an actual argument
   or operand".

4. In Section C.12.5, paragraph 4, replace the third sentence by
   "The flexibility also includes the order of operand or argument
   evaluation and concurrent operand or argument evaluation."

SUBMITTED BY: R. L. Page

LAST SIGNIFICANT CHANGE: , requestor's original draft

HISTORY:

--------------------------------------------------------------------------

NUMBER: 000106
TITLE: Multiple USE of modules; renaming rules
KEYWORDS: USE, modules, accessibility, renaming
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress - content challenged

QUESTION: Section 11.3.2 states

     More than one USE statement for a given module may appear in a 
     scoping unit.  If one of the USE statements is without an ONLY qualifier,
     all public entities in the module are accessible and the rename-lists and
     only-lists are interpreted as a single concatenated rename-list.  If 
     all the USE statements have ONLY qualifiers, only those entities named  
     in one or more of the only-lists are accessible, that is, all the only-  
     lists are interpreted as a single concatenated only-list.

Assume the following module definition in considering the following questions.
      
      MODULE MOD
      INTEGER I, J, K
      END MODULE

Question 1: If the following USE statements appear in a scoping unit, by
what names are I and J accessible?

      USE MOD
      USE MOD, ONLY: X => I
      USE MOD, ONLY: Z => J

The rules quoted above state in this case all public entities are accessible
since one of the USE statements is without an ONLY qualifier.  By 
concatenating the only-lists and rename-lists on a single rename list we have

      USE MOD, X => I, Z => J

Is I accessible through both the name I and X, and is J accessible through
both the name J and Z?

Question 2: Same as question 1 without the ONLY clause.  Here, all the 
USE statements are without ONLY clauses.

      USE MOD
      USE MOD, X => I
      USE MOD, Z => J

Because MOD appears in a USE statement without a rename-list, are all 
public entities from MOD accessible by their declared name in MOD as well
as any local names given in the rename-lists?  That is, is I accessible
by both I and X, and J accessible by both J and Z?

ANSWER: In both examples, I is made accessible only as X, and J is made
accessible only as Z.

Discussion: As indicated by the text cited in 11.3.2, the USE statements
in a scoping unit that reference a particular module are to be interpreted
collectively, not individually.

REFERENCES: ISO/IEC 1539:1991, sections 11.3.2

EDIT: none

SUBMITTED BY: Jon Steidel
HISTORY: Initially drafted as X3J3/92-246
  Response proposed in X3J3/92-279 - 
  meeting 123 vote (12-4) insufficient to approve

--------------------------------------------------------------------------

NUMBER: 000107
TITLE: USE renaming of generic and specific interfaces
KEYWORDS: USE, module, generic name, specific name, 
interfaces, renaming
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: A module contains a generic interface whose name matches the 
name of a specific interface defined in the interface block defining the 
generic interface.  When the module is used, the name of the generic 
interface appears in a rename-list on the USE statement.  Does the 
rename apply also to the specific interface?  For example:

      MODULE MOD
      INTERFACE GEN
        SUBROUTINE GEN (A, B)
           REAL A, B
        END SUBROUTINE
      END INTERFACE
      END MODULE

      SUBROUTINE USER (X)
         USE MOD, RENAME => GEN  ! Renames generic and specific GEN
         DIMENSION GEN (100)     ! Legal to have local variable by name GEN?
         ...
      END SUBROUTINE

ANSWER: Yes, the rename also applies to the specific name.

Discussion: In the example, RENAME is the local name in USER which 
refers to the same entity that the name GEN refers to in MODULE.  
The name GEN is free to be used for other purposes in USER.

REFERENCES: ISO/IEC 1539:1991, sections 11.3.2

EDIT: none

SUBMITTED BY: Jon Steidel
HISTORY: Initially drafted as X3J3/92-247
                  Response proposed in X3J3/92-282 - 
                  approved by unanimous consent at meeting 123

--------------------------------------------------------------------------

NUMBER: 000108
TITLE: Referencing disassociated pointers
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION: There are several places in the standard that refer to whether
      a disassociated pointer can be referenced. The places seem to
      be inconsistent in the restrictions they place on such references.

      In section 5.1.2.4.3

       "The size, bounds, and shape of the target of a disassociated
        array pointer are undefined.  No part of such an array
        may be defined, nor may any part of it be referenced
        except as an argument to an intrinsic inquiry function
        that is inquiring about argument presence, a property of
        the type or type parameters, or association status."

      In section 5.2.7

        "An object that has the POINTER attribute must not be
        referenced or defined unless, as a result of executing a pointer
        assignment (7.5.2) or an ALLOCATE statement (6.3.1),
        it becomes pointer associated with a target object
        that may be referenced or defined."

      In section 7.1.4.1

       "If the pointer is not associated with a target, it may appear
        as a primary only as an actual argument in a reference to a
        procedure whose corresponding dummy argument is declared to
        be a pointer."

      In section 7.5.2

       "A pointer must not be referenced or defined unless it is
        associated with a target that may be referenced or defined."

      In section 13.7.2

       "The inquiry functions RADIX, DIGITS, MINEXPONENT,
        MAXEXPONENT, PRECISION, RANGE, HUGE, TINY, and
        EPSILON return scalar values related to the parameters of
        the model associated with the types and kind type parameters
        of the arguments. The value of the arguments to these
        functions need not be defined, pointer arguments may be
        disassociated, and array arguments need not be allocated."


    (1) Where exactly can a pointer that is disassociated be
        referenced?

    (2) Can array pointers that are disassociated be referenced
        in more places than scalar pointers that are disassociated?

    (3) Can a pointer with an undefined association status ever
        be referenced? (eg as the argument to the KIND intrinsic
        in a PARAMETER statement).

ANSWER:

REFERENCES:

EDIT:

SUBMITTED BY: Janice C. Shepherd
HISTORY: Submitted as X3J3/92-258 at meeting 123

--------------------------------------------------------------------------

NUMBER: 000109
TITLE: Intrinsic Function ASSOCIATED
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: The description of ASSOCIATED (section 13.13.13) fails to 
specify that the result is scalar. Is this an oversight? Or
is there some way in which an array-valued result can be returned?

ANSWER: The result returned by ASSOCIATED is always scalar. The following
edit makes this clear.

EDIT:  In 13.13.13 in the specification of the result type, add
	"scalar" after "default logical".
	
REFERENCES: ISO/IEC 1539:1991(E) Section 13.13.13

SUBMITTED BY: Graham Barber
LAST SIGNIFICANT CHANGE: 1992 11 11, new
HISTORY: Originally submitted as X3J3/92-264
         Response proposed in X3J3/92-317 - 
         approve by (18-1) vote at meeting 123

--------------------------------------------------------------------------

NUMBER: 000110
TITLE: Named Constant Shape Specification
KEYWORDS: statement ordering, type declaration statement, named
          constant, PARAMETER statement shape, DIMENSION statement,
          attribute specification
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response
     
QUESTION: The standard seems inconsistent in that the following
appears valid
     
             SUBROUTINE SUB ( )
               REAL, PARAMETER :: R = 1
               DIMENSION R (2)
             END
     
while the following appears not to be
     
             SUBROUTINE SUB ( )
               PARAMETER (R = 1)
               DIMENSION R(2)
             END
     
Was this the intent?
     
ANSWER: No, both are illegal.
     
Discussion: Section 5.2 states,"All attributes (other than type) may
be specified for entities, independently of type, by single
attribute specification statements.  The combination of attributes
that may be specified for a particular entity is subject to the same
restrictions as for type declaration statements regardless of the
method of specification." Section 5.2.10 places the following
restriction on objects named in a PARAMETER statement: "The named
constant must have its type, shape, and any type parameters
specified either by a previous type statement in the same scoping
unit, or by the implicit typing rules currently in effect for the
scoping unit." While the restriction is stated in the section
titled, "The PARAMETER Statement", it applies to all objects with
the parameter attribute.  Objects with the parameter attribute may
appear in subsequent specification expressions and initialization
expressions.  Because of this, the committee chose to require the
shape of an object with the parameter attribute to be known before
it is initialized and thus before it can appear in subsequent
specification and initialization expressions.
     
REFERENCES: ISO/IEC 1539:1991 sections 5.2 and 5.2.10.
     
EDITS: none
     
SUBMITTED BY: Peter Griffiths
HISTORY: Initially drafted as X3J3/120-100
         Submitted as X3J3/92-289 at meeting 123
         Approved at meeting 123 (17-2)

--------------------------------------------------------------------------

NUMBER: 000111
TITLE: Array constructors in masked assignment statements
KEYWORDS: array constructors, masked assignment statements, WHERE
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress
     
QUESTION: The description of masked array assignments (section
7.5.3.2, p 93) does not specify how an array constructor referenced
in such an assignment is evaluated.  The basic question to be
answered is:
     
     "Is the evaluation of an array constructor controlled
     by the <mask-expr>?"
     
I believe that the answer should be no since there are some array
constructors where evaluation on an element by element basis is not
possible; e.g.,
     
      (/ MATMUL(A,B) + 1 /)
     
There are also array constructors where it is hard for a compiler to
select a particular element for evaluation; e.g.,
     
      (/ (( A(1:J:I), I=1,J), J=M,N) /)
     
Note that unmasked evaluation of array constructors, although in my
mind the correct interpretation, will introduce some interesting
semantics; e.g., consider the following two statements:
     
      where (A .NE. 0) B = 1/A                   (S1)
      where (A .NE. 0) B = (/ 1/A /)             (S2)
     
Execution of these two statements may lead to divide by zero
overflow for (S2) but not for (S1)!
     
ANSWER:
     
Discussion:
     
REFERENCES: ISO/IEC 1539:1991(E) section 7.5.3.2.
     
EDIT(S): none
     
SUBMITTED BY: Graham Barber
LAST SIGNIFICANT CHANGE 92 11 13
HISTORY: Submitted as X3J3/92-264, part (2), at meeting 123
         Response in 92-293 rejected at meeting 123 (10-10)

--------------------------------------------------------------------------

NUMBER: 000112
TITLE: Sequence Derived Type External Functions
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress - content challenged

QUESTION:  Can an external function of sequence derived type be declared
with a TYPE specification in the FUNCTION statement?

For example, is the following a valid code fragment?

TYPE (T) FUNCTION F ()
   TYPE T
      SEQUENCE 
      INTEGER I, J
   END TYPE T
   ...
END 

ANSWER: Yes, the code fragment is valid, as an external function of
sequence derived type can be declared with a TYPE specification in its
FUNCTION statement.

Discussion:  The second paragraph of 12.5.2.2 indicates the only two
conditions under which the attributes of a function result must be
specified by specification statements within the function body.

"If the function result is array-valued or a pointer, this must be
specified by specifications of the name of the result variable within
the function body."

It was not intended that the syntax of allowing TYPE on a FUNCTION
statement be limited to internal and module functions.  The last sentence
of the first paragraph of 5.1.1.7 should not be applied to function
results.  An edit is included for clarification.

REFERENCES:  5.1.1.7, 12.5.2.2.

EDIT(S):  Add after the last sentence of the first paragraph of 5.1.1.7:

"If the data entity is a function result, the derived type can be
specified on the FUNCTION statement providing the derived type is defined
within the body of the function or is accessible there by use or host
association."

SUBMITTED BY: Janice C. Shepherd, 92-130.
HISTORY: Draft response proposed in 92-298 - (14-4) vote at meeting 123
         insufficient for approval

--------------------------------------------------------------------------

NUMBER: 000113
TITLE: Ordering of Array Specification and Initialization
KEYWORDS: statement ordering, type declaration statement,
          initialization, shape, DIMENSION statement, attribute
          specification
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress
     
QUESTION: Fortran 90 requires that an array initialized via a DATA
statement must have its array properties established by a previous
specification expression (5.2.9).  When an array is initialized via
an =initialization-expr specification in a type declaration
statement, however, there is no such requirement.  For example, the
code fragment,
     
             INTEGER :: I
             DATA I /2*1/
             DIMENSION :: I(2)
     
is prohibited by the standard, whereas the similar fragment,
     
             INTEGER :: I = (/1,1/)
             DIMENSION :: I(2)
     
appears to be permitted.  Is the lack of such a requirement when
initializing an array in a type declaration statement an error in
the standard?
     
ANSWER: No, this difference between the DATA statement and an
initialization-expr in a type declaration statement was intended.
     
Discussion: The DATA statement does not provide complete information
about the array properties of the objects it initializes; in
particular, the size and shape of an array cannot be determined from
DATA statements.  The committee decided that permitting this
information to be provided after the DATA statement would make
certain implementation models very difficult.
     
On the other hand, initialization of an array in a type declaration
statement must obey a different set of requirements, namely, the
intrinsic assignment conformance rules (5.1, 7.5, 7.5.1.4).  There
are two cases:
     
   1) If the initialization-expr is an array, the object being
      initialized must be an array with identical shape.  The
      subsequent explicit declaration of the shape of the
      array must confirm the shape deduced from that of the
      initialization-expr.
     
   2) If the initialization-expr is a scalar, the shape of the
      object being initialized is not determined, but there is
      only a single value that must be preserved until the shape
      has been determined in a subsequent declaration statement.
     
In the judgment of the committee, this did not constitute a serious
obstacle to efficient implementation.  The committee therefore chose
instead to permit this construction in the interest of avoiding
unnecessary restrictions on statement ordering.
     
REFERENCES: ISO/IEC 1539:1991 sections 5.2.9, 5.1, 7.5 and 7.5.1.4.
     
EDITS: none
     
SUBMITTED BY: Peter Griffiths
LAST SIGNIFICANT CHANGE: 13 Nov 92 Response rejected at
                           meeting 123 (8-12)
HISTORY: Initially drafted as X3J3/120-62 (120-LJM-2a)
         Resubmitted as X3J3/92-287
         Response in X3J3/92-287r rejected at meeting 123 (8-12)

--------------------------------------------------------------------------

NUMBER: 000114
TITLE: Named Constant Attribute Specification
KEYWORDS: statement ordering, type declaration statement, named
          constant, PARAMETER statement, shape, DIMENSION statement,
          attribute specification statement
DEFECT TYPE: Erratum
STATUS: X3J3 draft response
     
QUESTION: The standard seems inconsistent in that the program unit
     
             SUBROUTINE SUB ( )
               REAL, DIMENSION (2) :: R
               PARAMETER (R = 1)
             END
     
appears to be valid while the program unit
     
             SUBROUTINE SUB ( )
               DIMENSION R(2)
               PARAMETER (R = 1)
             END
     
does not appear valid as section 5.2.10 states, "The named constant
must have its type, shape, and any type parameters specified either
by a previous occurrence in a type declaration statement in the same
scoping unit, or by the implicit typing rules currently in effect
for the scoping unit." Was it intended that one case be legal while
the other is not?
     
ANSWER: No, that was not the intent; both program units are legal.
     
Discussion: Section 5.2 states,"The combination of attributes that
may be specified for a particular entity is subject to the same
restrictions as for type declaration statements regardless of the
method of specification." Section C.5.1 also supports this intent.
Thus there is evidence in the standard that the same restrictions
should be applied to objects independent of whether their attributes
were specified in a type declaration statement or an attribute
specification statement.  The edit below clarifies this intent by
changing the statement in section 5.2.10 quoted above.
     
REFERENCES: ISO/IEC 1539:1991 sections 5.2.10, 5.2, and C.5.1
     
EDITS: Section 5.2.10, replace the first sentence following the
constraints with, "The named constant must have its type, shape, and
any type parameters specified either by previous type declaration or
attribute specification statements in the same scoping unit, or by
the implicit typing rules currently in effect for the scoping unit."
     
SUBMITTED BY: Peter Griffiths
HISTORY: Initially drafted as X3J3/120-99
         Submitted as X3J3/92-288 at meeting 123
         Approved at meeting 123 (UC)

--------------------------------------------------------------------------

NUMBER: 000115
TITLE: Multiple dummy arguments
DEFECT TYPE: Interpretation
KEYWORDS:
STATUS: X3J3 draft response

QUESTION:  Section 12.5.2.5 implies that a dummy argument in an ENTRY
statement can also appear in the subprogram's FUNCTION or SUBROUTINE
statement.  That is, the following is standard conforming:

      SUBROUTINE S(A,B,C)
      ...
      ENTRY SE(A,B)
      ...
      END SUBROUTINE

Does this imply that an entity can occur multiple times in a single
list?  For example,

      FUNCTION F(A,B,A)
      ...
      END FUNCTION

      SUBROUTINE S( )
      ...
      ENTRY SE(C,D,C)
      ...
      END SUBROUTINE

ANSWER: Section 14.1.2 indicates that these program fragments are invalid.

Discussion: Section 14.1.2 lists named variables as a class (1) entity.
The section also indicates that a name that identifies a local entity
of one class must not be used to identify another local entity of the
same class.  When a dummy argument appears in both an ENTRY statement
and a subprogram FUNCTION or SUBROUTINE statement, the name denotes the
same local entity and not two different entities of the same class.  In
the program fragments shown, the entity denoted by the first A is not the
same entity as the second A.  A similar statement can be made for the
entities denoted by C.  In both cases, the fragments are attempting to
use the same name for two entities of the same class and are therefore
invalid.

REFERENCES: ISO/IEC 1539:1991 (E) section 14.1.2

EDIT(S): None

SUBMITTED BY:
LAST SIGNIFICANT CHANGE: 1992-11-11, new
HISTORY: Discussed in e-mail 92-048 (pg 27-29,30-34)
         	Response proposed in X3J3/92-295 - 
	approved by unanimous consent at meeting 123

--------------------------------------------------------------------------

NUMBER:000116
TITLE: Scoping Units and statement labels
KEYWORDS: Scoping units, statement labels, hosts
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  

Question 1: When does the scope change from the host to an inner scope? 
It makes a difference in determining when a label is a duplicate of
another label in the same scope.

Question 2: In the following example, are the labels considered
duplicates thus making the program not standard conforming?

       PROGRAM EX1
  10    INTEGER I
  20    TYPE T
  10      INTEGER T1
  20      REAL T2
  30      INTEGER T3
  30    END TYPE


Question 3: In the following example, are the labels not considered duplicates
as the INTERFACE and END INTERFACE statements are in the host scope while
the two interface bodies each have their own scope?

       PROGRAM EX2
10       INTEGER I
20       INTERFACE
10         SUBROUTINE S(A)
20           REAL A
30         END SUBROUTINE
10         FUNCTION F (AA)
20           REAL AA
30         END FUNCTION
30       END INTERFACE

Question 4: In the following example, are the labels not considered duplicates
since the internal subroutine and function are separate scoping units?

     MODULE
10     INTEGER I
     ...
20   CONTAINS
10     SUBROUTINE INNER1 ( )
20       I = I + 1
30     END SUBROUTINE
10     FUNCTION F ( )
20       F = 4.5
30     END FUNCTION
30   END MODULE

ANSWER:

Answer 1:  In 2.2 a scoping unit is defined.  The syntax rules for
a derived type definition, a procedure interface body, and a program unit
or subprogram define the extents of scoping units.  Thus the
TYPE, END TYPE, PROGRAM, END PROGRAM, MODULE, 
END MODULE, BLOCK DATA, END BLOCK DATA, SUBROUTINE, 
END SUBROUTINE, and FUNCTION, END FUNCTION define the 
beginning and end of such scoping units.

Answer 2: The example is not standard conforming because there are
duplicate labels in the scoping unit of the derived type since the
TYPE statement is part of the derived type.

Answer 3: The example is standard conforming and does not have
duplicate labels.

Answer 4: The labels for the internal subroutine and function are
not considered duplicates since they are in separate scoping units.


REFERENCES: ISO/IEC 1539:1991 (E) section 2.2 [9]

EDITS(S): None

SUBMITTED BY: Janice Shepherd 
LAST SIGNIFICANT CHANGE: 1992-11-13
HISTORY: 92-304   (Meeting 123) - approved by unanimous consent at meeting 
123.

--------------------------------------------------------------------------

NUMBER: 000117
TITLE: A clarification request on generic interfaces
KEYWORDS: interface block, module procedure
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION: The second constraint in section 12.3.2.1 appears to indicate that 
the following program fragment is not standard conforming.  Is the following 
code fragment standard conforming?

      MODULE MOD
      CONTAINS
       SUBROUTINE SUB1(I)
       ...
       END SUBROUTINE SUB1
      END MODULE

      PROGRAM MAIN
       USE MOD
       CALL INNER
      CONTAINS
       SUBROUTINE INNER
        INTERFACE SUB
         MODULE PROCEDURE SUB1
        END INTERFACE
        ...
       END SUBROUTINE
      END PROGRAM

ANSWER: Yes.  The program fragment is standard conforming.

Discussion: There are several defects in the second constraint of section 
12.3.2.1.  First, the constraint should not restrict the program fragment 
that is shown nor similar ones involving generic interfaces in internal 
procedures within module subprograms.  Second, the constraint implies that an 
<interface-block> is a scope, when it is not.  An edit is included to correct 
these defects.

REFERENCES: ISO/IEC 1539:1991 (E) Section 12.3.2.1.

EDIT: Replace the second constraint in section 12.3.2.1 with 
"The MODULE PROCEDURE specification is allowed only if the 
<interface-block> has a <generic-spec> and is contained in a scoping 
unit where each <procedure-name> is accessible as a module procedure."

SUBMITTED BY: Y. Yoshida
LAST SIGNIFICANT CHANGE: 1992-11-12, new
HISTORY: Question posed in X3J3/92-132 items 63,64.
        	Response proposed in X3J3/92-318; 
	not formally considered at meeting 123 due to a lead time problem

--------------------------------------------------------------------------

NUMBER: 000118
TITLE: Named constructs and host association
KEYWORDS: 
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Section 12.1.2.2.1 defines when a name appearing in a 
scoping unit is the name of a local entity, making inaccessible any entity 
of the host that has the same name as its nongeneric name.  Should the 
appearance of a name as a construct name be on the list?

ANSWER: Yes.

Discussion: Section 14.1.2 indicates that construct names are local entities.
An edit is included to add construct names to the list in section 12.1.2.2.1.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.1.2.2.1 and 14.1.2.

EDIT: Add new item to the list in section 12.1.2.2.1:
  "(16) The name of a named construct"
and adjust the list punctuation accordingly.

SUBMITTED BY: P. Griffiths
LAST SIGNIFICANT CHANGE: 1992 11 12, new
HISTORY: Submitted as a request in X3J3/92-132 item 68.
         Response proposed in X3J3/92-319 - 
	approved by unanimous consent at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000119
TITLE: Rank of assumed-shape array
KEYWORDS: Rank, assumed-shape, array, argument
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Must the rank of an assumed-shape dummy argument match that of the
corresponding actual argument?

Discussion: The fourth paragraph of section 12.4.1.1 indicates that if a dummy
argument is a pointer, the actual argument must be a pointer and their ranks
must agree.  No similar statement appears to exist for assumed-shape
arrays.

ANSWER: Yes.  The rank of an assumed-shape dummy argument must match that of
the actual argument.  This is implied by the statement in 5.1.2.4.2 that an
assumed-shape array takes its shape from the associated actual argument array.
An edit is included to clarify this restriction.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.4.1.1 and 5.1.2.4.2

EDIT: At the end of the first paragraph of section 12.4.1.1 [172:41], add: "If
the dummy argument is an assumed-shape array, the rank of the dummy argument
must agree with the rank of the actual argument."

SUBMITTED BY: A. Meyer
LAST SIGNIFICANT CHANGE: 1992 11 12, new
HISTORY: Submitted as a request in X3J3/92-132 item 69.
         	Response proposed in X3J3/92-320 - 
	approved by unanimous consent at meeting 123.

--------------------------------------------------------------------------

NUMBER: 000120
TITLE: PRESENT intrinsic and host association
KEYWORDS: PRESENT, host association, optional
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Can the PRESENT intrinsic be called from an 
internal procedure with an argument that is an optional dummy
argument of its host?

For example

        SUBROUTINE HOST(OPT)
        REAL, OPTIONAL :: OPT
        ...
        CONTAINS
           SUBROUTINE INNER ( )
           IF (PRESENT (OPT) ) THEN
              ...

ANSWER: Yes.


Discussion: As long as the optional dummy argument is accessible
            it can be used as an argument to the PRESENT
            intrinsic. An edit is provided for clarification.
                
REFERENCE: ISO/IEC 1539:1991 (E) Section 13.13.80

EDIT:
        Replace the description of Argument in 13.13.80 with
       "A must be the name of an optional dummy argument that is
        accessible in the procedure in which the PRESENT function
        reference appears."

SUBMITTED BY: J. C. Shepherd
LAST SIGNIFICANT CHANGE: 1992 11 11, new
HISTORY: Question and proposed response first appeared in X3J3/92-321

--------------------------------------------------------------------------

NUMBER:  000121
TITLE: ";" As a Statement Separator
KEYWORDS: Separator, ";"
DEFECT TYPE: Amendment
STATUS: X3J3 consideration in progress 

Question:  Are the following cases legal?
1)	C = A ;  + B

2)	F = ; &
 	G

3)	; P = Q

ANSWER:

SUBMITTED BY: Paul St. Pierre,  119-PSP-1
LAST SIGNIFICANT CHANGE:
HISTORY:      119-PSP-1         (initial submission)
                     X3J3/92-284     (considered at meeting 123)

--------------------------------------------------------------------------

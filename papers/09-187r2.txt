                                                          09-187r2
To:       J3
From:     Stan Whitlock
Subject:  Results of the J3 interp letter ballot #18
Date: 2009 May 8

NB: F2008 edits for F03/0112 and F03/122 were passed at m188.


Here are the results of J3 letter ballot #18 on Fortran
interpretations that officially closed 23-Mar-2009.  The ballot is
in J3 paper 09-155 for meeting #188.  If I have transcribed a vote
or a comment incorrectly, please let me know.

J3 rep             F03 F03 F03 F03 F03 F03 F03 F03 F03 F03 F03 F03
                   063 064 065 071 112 119 122 125 126 127 128 129

Malcolm Cohen (*)    C   C   N   Y   Y   Y   Y   Y   Y   Y   N   Y
Michael Ingrassia    Y   Y   N   Y   Y   Y   Y   Y   Y   Y   Y   Y
Bill Long            C   C   Y   Y   Y   Y   Y   Y   Y   Y   C   C
Dan Nagle            Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y
Craig Rasmussen      no ballot received
Van Snyder           Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y
Stan Whitlock        Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y   Y
Jim Xia              N   N   Y   N   Y   C   Y   N   Y   Y   C   C

(*) Malcolm Cohen is the voting alternate for Jeanne Martin

where  Y means "yes"
       C       "yes with comment"
       N       "no with comment"

The comments for each interp are attached below in the same order as
the table above.  The summary of DRAFT results is as follows:

  F03 F03 F03 F03 F03 F03 F03 F03 F03 F03 F03 F03
  063 064 065 071 112 119 122 125 126 127 128 129

    C   F   F   Y   Y   C   Y   Y   Y   Y   F   C

    Y = passed
    C = passed as amended
    F = Failed J3 letter ballot

The interps marked "C" pass with some minor fixes, as noted below.

The interps marked "F" failed the J3 letter ballot and now have the
status "J3 consideration in progress".

The edited interps in their final form are attached and will appear
in the next version 006A.  Suggested edits for F2008 were updated to
09-007r1.

/Stan

**********************************************************************

F03/0063  Procedure pointers in BLOCK DATA program units

  Malcolm Cohen COMMENT for F03/0063 YES vote:

    I agree with Bill Long's suggestions.

  Bill Long Comment for F03/0063:

    To remove procedure pointers from common blocks, additional edits
    seem to be needed [ref in 04-007]:

      [98:18] Remove "or <proc-pointer-name>"  {113:3 in 09-007}.

      [98:25] Remove "or <proc-pointer-name>"  {113:10 in 09-007}.

      [411:21] Remove item (7) in the list of names in a scoping unit
      that override the same host-associated name. {452:22 in 09-007}.

  Jim Xia NO comment on F03/0063:

    I agree with Bill that the edits need to include fixes to C587
    and C590.

  Resolution for F03/0063: Bill's edits were added to the answer;
    F03/0063 passed J3 letter ballot #18 as modified

F03/0064  Recursive declaration of procedure interfaces

  Malcolm Cohen COMMENT for F03/0064 YES vote:

    The entire DISCUSSION section should be deleted as it is wrong.

    The answer does not address Rob James examples;  these appear to
    continue to be problematic.

    Also consider

      MODULE m3
        PROCEDURE(s),POINTER :: sptr
      CONTAINS
        SUBROUTINE s(p)
          PROCEDURE(sptr) :: p
        END SUBROUTINE
      END MODULE

    In the normal course of events one would like to allow
      PROCEDURE(module-procedure-name),POINTER :: mpptr
    since it is natural to want to provide a procedure pointer that
    matches a module procedure, so we should not just take away the
    ability to use a (later-defined) module procedure here.

    Rob James' suggestion of
     "The characteristics of a dummy procedure shall not depend on
      the characteristics of the procedure or interface body in
      which it is declared."
    would seem to catch all these examples.  Unfortunately it breaks
      REAL(KIND=3) FUNCTION F(G) RESULT(R)
      REAL(KIND(R)),EXTERNAL :: G

    In any case, the dummy argument case is different (it's certainly
    trickier) and especially since there is not an obvious fix I would
    prefer us to fix the original problem as described in F03/0064
    using the edit there, and discuss and debate how to solve the
    dummy procedure case separately.

    I thought about
      "The <interface-name> shall be previously declared or be the name
      of an accessible module procedure; if it is the name of a module
      procedure either the module procedure shall be previously defined
      or the PROCEDURE statement shall appear in the specification part
      of the module."
    which seems to fix Rob's examples but unfortunately not mine.

    The DISCUSSION section plus my additional example should be used to
    form a new interp request.

  Bill Long Comment for F03/0064:

    The text following Example 1 in the Discussion says "which is being
    declared by an interface body is *NOT* previously declared".  But
    there is no interface body in Example 1. Similarly, Example 2 also
    has no interface bodies.  The examples do not seem relevant to the
    topic of the ANSWER section. Maybe both examples should be deleted.

  Jim Xia NO comment on F03/0064:

    The edits do not apply to example 1 and 2 in the extended
    discussion.  In both examples, module procedures are used.  The
    term <interface-body> is not applicable to them as indicated by
    Note 12.3 on page 258

      "An interface body cannot be used to describe the interface of an
      internal procedure, a module procedure, or an intrinsic procedure
      because the interfaces of such procedures are already explicit."

    Furthermore the discussion on example 2 is more confusing than
    useful because it refers to IMPORT statement.  I can not see how
    the IMPORT statement is relevant to this example.

  Resolution for F03/0064: Failed J3 letter ballot #18

F03/0065  Relational equivalence

  Malcolm Cohen REASON for F03/0065 NO vote:

    I agree with Bob Corbett that "mathematical" treatment of
    relationals is inappropriate and unfriendly.  We should require
    the right answer.  Processors with deficient hardware that
    cannot compare numbers without subtraction are notably thin on
    the ground these days; pandering to them serves no useful purpose.

    Also, the "mathematical" answer is the wrong answer for IEEE NaNs.

  Michael Ingrassia reason for F03/0065 NO vote:

    The value of A < B should require the computation of A and B as
    coded and the comparison of their computed values.  Saying that
    "all possible values" refers to mathematical values permits
    unnecessary mathematical rewriting which destroys carefully
    coded floating point computations.  That isn't the interpretation
    we want.

  Resolution for F03/0065: Failed J3 letter ballot #18

F03/0071  Subroutine/function ambiguity in generics

  Jim Xia NO comment on F03/0071:

    The reason for my NO vote is exactly the same as I stated in J3
    letter ballot #17 (08-259).  I believe it is a poor decision to
    assume the user *must have meant* ff to be a function name in
    resolving the generic name Q.  Asking programmers to explicitly
    declare the type, or better the interface of procedure ff is
    helping them avoid writing sloppy programs.

  Resolution for F03/0071: /interp did not agree with Jim's reason;
    F03/0071 passed J3 letter ballot #18

F03/0119  Elemental procedures and deferred length character components

  Jim Xia YES comment on F03/0119:

    The example3 contains an error in the derived type definition of
    t1:
      TYPE t1(n)
        INTEGER,LENGTH :: n
        ...

    should be
      TYPE t1(n)
        INTEGER,LEN :: n

  Resolution for F03/0119: Jim's comment was accepted;  F03/0119 passed
    J3 letter ballot #18

F03/0125  Definitions of EXTENDS_TYPE_OF and SAME_TYPE_AS

  Jim Xia NO comment on F03/0125:

    I disagree with the edits to make return result of EXTENDS_TYPE_OF
    as processor dependent when dynamic type of either A or MOLD is
    not extensible.  It should be clear that in such case the return
    value of EXTENDS_TYPE_OF is false because the concept of type
    extension is only applicable to extensible types.

  Resolution for F03/0125: /interp did not agree with Jim's comment;
    F03/0125 passed J3 letter ballot #18

F03/0128  Subobjects in namelist output

  Malcolm Cohen REASON for F03/0128 NO vote:

    The sentence being edited begins
      "The name of each namelist group object list item is placed ...".
    This is not ambiguous in any way.  The namelist group object list
    items are the named variables in the NAMELIST statement; see p95
      R553 <namelist-group-object> <<is>> <variable-name>
    There can be no question about this, regardless of what nonstandard
    behaviour some vendor might or might not do.

    This is a feature request, and what's more, one that makes a
    processor that uses the feature not compliant with Fortran 90/95.
    In the compatibility section we list the things that "may have a
    different interpretation" for F77, so this ought to be there as
    well (that is if we thought it was a good idea).

    Oh, and the edit is way short of implementing the feature, since
    the "designator" of a namelist group object list item is just its
    name.

  Bill Long Comment for F03/0128:

    In the EDIT section the reference [247:17] should be [247:27].

  Jim Xia YES comment on F03/0128:

    I agree with Bill that the edits should refer to [247:27].

  Resolution for F03/0128: accepted edit line number change; Failed
                           J3 letter ballot #18

F03/0129  C_LOC of character substrings

  Bill Long Comment for F03/0129:

    In the EDITS section, the reference [399:2-2] should be [399:2-3].

  Jim Xia YES comment on F03/0129:

    In the first edit, [395:8(16.1.2.5)] should be [395:8(15.1.2.5)].

    In the fourth edit at [399:2-2(15.2.4p1)], it says
      Change "and" to a comma,
    I assume "and" is referring to the 2nd and in this sentence.  Also
    in this edit, can we be clear that the initialization expression
    for length must evaluate to one (1).  It takes the combination of
    edits at [396:5-7] and [399:2-2(15.2.4p1)] to deduce this.  The
    current edit may result in wrong assumption by users that a
    variable declared such as character(2) is also interoperable with
    a C entity.

    The last edit at [399:7-8(15.2.5)] has exactly the same problem as
    to that in the previous edit.

  Resolution for F03/0129:  accepted Bill's change;  accepted Jim's
    to the first edit, in the fourth and last edits, make it the
    'second "and"', /interp did not agree that 15.2.4 and 15.2.5 is
    the place to note that only character(1) is interoperable with
    a C entity;  F03/0129 passed J3 letter ballot as modified

----------------------------------------------------------------------

NUMBER: F03/0063
TITLE: Procedure pointers in BLOCK DATA program units
KEYWORDS: Procedure pointer, common block, block data
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

It is clear that procedure pointers are permitted in common blocks.
However, due to the restrictions on BLOCK DATA program units, it seems
that such a common block can not appear in a BLOCK DATA program unit.

Was it intended that common blocks containing procedure pointers could
be initialized in a BLOCK DATA program unit?

ANSWER:

It was a mistake to try to allow procedure pointers in common blocks.

Edits are provided to correct this blunder.

EDITS:

All edits refer to 04-007.

[98:17] Delete the second line of R558   {114:19 R569 in 09-007r1}.

[98:18] Remove "or <proc-pointer-name>"  {114:21 in 09-007r1}.

[98:21] After "allocatable" insert "a procedure pointer,"
                                         {114:24 in 09-007r1}.

[98:25] Remove "or <proc-pointer-name>"  {115:2 in 09-007r1}.

[411:21] Remove item (7) in the list of names in a scoping unit
that override the same host-associated name. {448:22 in 09-007r1}.

SUBMITTED BY: Rob James

HISTORY: 05-178    m172  F03/0063 submitted
         05-225    m173  Passed by J3 meeting
         06-133r2  m175  Passed J3 letter ballot #12
         N1658     m176  Failed WG5 ballot N1657
         09-148    m187  Revised answer, passed by J3 meeting
         09-187    m188  Passed J3 letter ballot #18 09-155 as modified

F2008 note: include edits above + [04-007/98:21-22 5.5.2 C588]
  Delete "a function name, an entry name," because these were
  originally synonyms for "a result name" (as applied to
  <variable-name> in R558).  Now, "a function name" (as applied to
  <proc-pointer-name> in R558) prohibits function pointers.

----------------------------------------------------------------------

NUMBER: F03/0064
TITLE: Recursive declaration of procedure interfaces
KEYWORDS: procedure, interface
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:

Consider the following program:

      PROGRAM foo
        PROCEDURE(sub) :: p
        INTERFACE
          SUBROUTINE sub(p2)
            IMPORT p
            PROCEDURE(p) :: p2
          END SUBROUTINE
        END INTERFACE
      END PROGRAM

C1212 appears to prohibit the case of an interface name in a procedure
declaration statement being the name of something declared in a later
procedure declaration statement.  But it does not appear to prohibit
the case of an interface name being the name of something declared in
a later interface body.

In the above program, the characteristics of p rely on the
characteristics of sub.  The characteristics of sub, in turn, rely on
the characteristics of p.

Is this program standard-conforming?

ANSWER:

No, this program is not standard-conforming.  The interface name in a
procedure declaration statement should not be permitted to be declared
in a later interface body.  An edit is supplied to correct this
oversight.

DISCUSSION:

The edit changes C1212 to read:

  C1212 ... If <name> is declared by a <procedure-declaration-stmt>
        or <interface-body> it shall be previously declared."

Example 1:

    MODULE m1
    CONTAINS
      SUBROUTINE s(p)
        PROCEDURE(s) :: p
      END SUBROUTINE
    END MODULE

This is clearly invalid, since the declaration of "s" in the PROCEDURE
statement is still in progress (until END SUBROUTINE) and therefore "s"
which is being declared by an interface body is *NOT* previously
declared.

Example 2:

    MODULE m2
    CONTAINS
      SUBROUTINE s1(a)
        PROCEDURE(s2) :: a
      END SUBROUTINE
      SUBROUTINE s2(b)
        PROCEDURE(s1) :: b
      END SUBROUTINE
    END MODULE

This is invalid because the interface body for S1 does not have access
to S2.  Furthermore, adding an IMPORT statement is ineffective because
of the requirement
  "An entity that is imported ... and is defined in the host scoping
   unit shall be explicitly declared prior to the interface body."

EDITS:

All edits refer to 04-007.

[264:22]  Before "it shall", insert "or <interface-body>".

SUBMITTED BY: Rob James

HISTORY: 05-179    m172  F03/0064 submitted
         05-226    m173  Passed by J3 meeting
         06-133    m175  Failed J3 letter ballot #12
         09-149    m187  Passed by J3 meeting
         09-187    m188  Failed J3 letter ballot #18 09-155

  Malcolm Cohen COMMENT for F03/0064 YES vote:

    The entire DISCUSSION section should be deleted as it is wrong.

    The answer does not address Rob James examples;  these appear to
    continue to be problematic.

    Also consider

      MODULE m3
        PROCEDURE(s),POINTER :: sptr
      CONTAINS
        SUBROUTINE s(p)
          PROCEDURE(sptr) :: p
        END SUBROUTINE
      END MODULE

    In the normal course of events one would like to allow
      PROCEDURE(module-procedure-name),POINTER :: mpptr
    since it is natural to want to provide a procedure pointer that
    matches a module procedure, so we should not just take away the
    ability to use a (later-defined) module procedure here.

    Rob James' suggestion of
     "The characteristics of a dummy procedure shall not depend on
      the characteristics of the procedure or interface body in
      which it is declared."
    would seem to catch all these examples.  Unfortunately it breaks
      REAL(KIND=3) FUNCTION F(G) RESULT(R)
      REAL(KIND(R)),EXTERNAL :: G

    In any case, the dummy argument case is different (it's certainly
    trickier) and especially since there is not an obvious fix I would
    prefer us to fix the original problem as described in F03/0064
    using the edit there, and discuss and debate how to solve the
    dummy procedure case separately.

    I thought about
      "The <interface-name> shall be previously declared or be the name
      of an accessible module procedure; if it is the name of a module
      procedure either the module procedure shall be previously defined
      or the PROCEDURE statement shall appear in the specification part
      of the module."
    which seems to fix Rob's examples but unfortunately not mine.

    The DISCUSSION section plus my additional example should be used to
    form a new interp request.

  Bill Long Comment for F03/0064:

    The text following Example 1 in the Discussion says "which is being
    declared by an interface body is *NOT* previously declared".  But
    there is no interface body in Example 1. Similarly, Example 2 also
    has no interface bodies.  The examples do not seem relevant to the
    topic of the ANSWER section. Maybe both examples should be deleted.

  Jim Xia NO comment on F03/0064:

    The edits do not apply to example 1 and 2 in the extended
    discussion.  In both examples, module procedures are used.  The
    term <interface-body> is not applicable to them as indicated by
    Note 12.3 on page 258

      "An interface body cannot be used to describe the interface of an
      internal procedure, a module procedure, or an intrinsic procedure
      because the interfaces of such procedures are already explicit."

    Furthermore the discussion on example 2 is more confusing than
    useful because it refers to IMPORT statement.  I can not see how
    the IMPORT statement is relevant to this example.

----------------------------------------------------------------------

NUMBER: F03/0065
TITLE: relational equivalence
KEYWORDS: transformation, relational equivalence, mathematical value
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION:

Given
  REAL X
  X = ... some value ...
may
  IF( X+3.0 .EQ. 3.0 )...
be transformed into
  IF( X .EQ. 0.0 )...
by the processor?

References are to J3/04-007.

7.1.8.3 Evaluation of numeric intrinsic operations has a discussion of
"mathematically equivalent", "mathematical value" and "computational
results".

7.1.8.5 Evaluation of relational intrinsic operations has "Two
relational intrinsic operations are relationally equivalent if their
logical values are equal for all possible values of their primaries."

"values" in that context is ambiguous to me.  Is it the infinite set
of mathematical values or is it the finite set of hardware
representable (computational) values?

My brief scan of F2003 finds that "values" without any adjectives
means what the hardware can represent.

Assuming "values" in 7.1.8.5 means what the hardware can represent,
then I conclude that the transformation cannot be done.  However, Note
7.22 shows "I > J" transformed into "J-I < 0"; which is not true for
the finite set of hardware values (due to undefined behavior of
overflow), but is true for the infinite set of mathematical values.

I believe that "possible values" should be changed to either:
  possible mathematical values
or
  possible computational values

ANSWER:

Since it can be undecidable whether expressions are mathematically
equivalent, it is clear that the permission to evaluate mathematically
equivalent expressions means "if an expression can be determined to be
mathematically equivalent it can be used instead."

Even in cases where it is easy to determine that expressions are
mathematically equivalent, it can be formidably expensive to determine
that they are equivalent for the finite but sometimes very large set of
"all possible computational values of their primaries."

The term "different computational results" includes the case that one
expression does not produce overflow when evaluated computationally for
some set of computational values of its primaries, while a
mathematically equivalent expression does produce overflow when
evaluated computationally for some members of that set of values of its
primaries.

One can imagine a processor that cannot evaluate I > J, but it can
evaluate I - J and then examine the sign.  This transformation thus has
to be allowed for all values, not just for those computational values
for which no overflow results.

Therefore, the term "all possible values" refers to mathematical values.

EDITS:

None.

SUBMITTED BY: Fred Tydeman

HISTORY: 05-192    m173  F03/0065 submitted
         09-150    m187  Passed by J3 meeting
         09-187    m188  Failed J3 letter ballot #18 09-155

  Malcolm Cohen REASON for F03/0065 NO vote:

    I agree with Bob Corbett that "mathematical" treatment of
    relationals is inappropriate and unfriendly.  We should require the
    right answer.  Processors with deficient hardware that cannot
    compare numbers without subtraction are notably thin on the ground
    these days; pandering to them serves no useful purpose.

    Also, the "mathematical" answer is the wrong answer for IEEE NaNs.

  Michael Ingrassia reason for F03/0065 NO vote:

    The value of A < B should require the computation of A and B as
    coded and the comparison of their computed values.  Saying that
    "all possible values" refers to mathematical values permits
    unnecessary mathematical rewriting which destroys carefully coded
    floating point computations.  That isn't the interpretation we want.

----------------------------------------------------------------------

NUMBER: F03/0071
TITLE: Subroutine/function ambiguity in generics
KEYWORDS: subroutine, generic, implicit
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

 Q1. Is the following generic allowed?

     interface q
       subroutine qr(f)
         implicit real(f)
         external f
       end subroutine
       subroutine qc(f)
         implicit complex(f)
         external f
       end subroutine
     end interface q

     The uncertainty arises because it is not established
     whether F is a subroutine or a function. If either F
     were a subroutine, then it would be clear that the
     generic was disallowed. One might be able to use this
     to deduce that both Fs must be functions. This seems
     like an obscure deduction to demand of the compiler.

 Q2. Consider the following "obviously" allowed generic

     module m
       interface q
         subroutine qr(f)
           real, external :: f
         end subroutine
         subroutine qc(f)
           complex, external :: f
         end subroutine
       end interface q
     end module m

     Is the following main program valid?

     program main
       use m
       external ff
       call q(ff)
     end

     Again, the problem is that it is unclear whether or not
     ff is a function or subroutine. If it is a subroutine,
     then the call is ambiguous. One might thus deduce that
     ff must be a function, and therefore of type real,
     but this seems like an obscure deduction to demand of
     the compiler.

ANSWER:

1. The program fragment is not conforming.  A generic interface is
   required to be nonambiguous.  This is a similar situation to the
   declaration of an external procedure in a module, where a
   procedure that is a function is required to have its type and
   type parameters explicitly declared.  An edit is provided to
   require this for specific procedures in a generic interface.

2. The main program program unit is conforming, although the program
   would not be if the external procedure FF were not in fact a real
   function.  If the reference had been to QR instead of Q, it would
   be clear that FF has to be a real function, from the point of view
   of the main program scoping unit.  At the call site, the reference
   to Q is known to be a reference either to QR or QC (the interface
   block for Q is not defective), both of which require a function
   actual argument.  FF is known to be either a subroutine or a
   function, since it explicitly has the EXTERNAL attribute, and if
   it is a function it is known by implicit typing rules to be real.
   Because neither specific in the generic allows a subroutine as an
   argument, FF must therefore be a function.  Since FF is real, QR
   is called.  (The generic cannot have a specific that accepts a
   subroutine as an argument, as that would violate the requirements
   in 16.2.3.)

EDITS:

[261:3] In 12.3.2.1 Interface block,
  immediately after "A generic interface is always explicit.",
  append new sentence to paragraph
    "If a specific procedure in a generic interface has a function
     dummy argument, that argument shall have its type and type
     parameters explicitly declared in the specific interface."
{I.e. if you just say EXTERNAL dummy, you must mean a subroutine.}

SUBMITTED BY: Richard Maine

HISTORY: 05-265    m174  F03/0071 submitted
         08-189r1  m184  Answer provided - Passed by J3 meeting
         08-259    m185  Failed J3 letter ballot #17 08-213
         08-262    m185  Passed by J3 meeting
         09-187    m188  Passed J3 letter ballot #18 09-155

F2008 note: edit is 09-007r1 [285:5+] 12.4.3.4.1 "Generic identifiers"
  after "A generic interface is always explicit."

----------------------------------------------------------------------

NUMBER: F03/0112
TITLE: Attributes allowed for dummy arguments in defined assignments
KEYWORDS: defined assignment, dummy argument, attributes
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

INTRODUCTION:

It seems the standard is quite loose in allowing various attributes
declared for the dummy arguments used in a defined assignment
(7.4.1.4).  In particular, attributes such as POINTER and ALLOCATABLE
can be declared for dummy arguments in the defined assignment.
However the interpretations on their declarations need to be
clarified.

QUESTION:

Consider the follow subroutines (assuming a derived type DT already
defined)

Q1. Are POINTER and ALLOCATABLE attributes allowed for the second
    dummy argument in defined assignment?

    interface ASSIGNMENT (=)
    subroutine defAssgn1 (dt1, dt2)
        type(DT), intent(out) :: dt1
        type(DT), POINTER, intent(in) :: dt2
    end subroutine
    end interface

    In 12.3.2.1.2 [263:10-12], the standard says the following
    "A defined assignment is treated as a reference to the subroutine,
     with the left-hand side as the first argument and the right-hand
     side enclosed in parentheses as the second argument."

    This statement seems to prohibit the use of subroutine defAssgn1
    for defined assignment since a pointer enclosed in parentheses
    refers to its associated target not the pointer itself, as
    indicated by rules in 7.1.4.1 [123:39-124:3].


Q2. Are POINTER and ALLOCATABLE attributes allowed for the first
    dummy argument in defined assignment?

    interface ASSIGNMENT (=)
    subroutine defAssgn2 (dt1, dt2)
        type(DT), POINTER, intent(out) :: dt1
        type(DT), intent(in) :: dt2
    end subroutine
    end interface

    There are no rules in the standard that disallow this declaration.
    However the use of POINTER/ALLOCATABLE attributes on the first
    dummy argument is very doubtful.  Since POINTER/ALLOCATABLE
    attributes don't disambiguate generic declarations(16.2.3), their
    use will prevent the normal declarations of defined assignments,
    wherein dt1 is declared without POINTER or ALLOCATABLE attribute.

ANSWER:

Yes to both questions.  The interface blocks are not defective.  The
standard places very few restrictions on the arguments to defined
assignment subroutines:  [363:6...]

  Each of these subroutines shall have exactly two dummy arguments.
  Each argument shall be nonoptional.  The first argument shall have
  INTENT (OUT) or INTENT (INOUT) and the second argument shall have
  INTENT (IN). ...

Preventing the first argument from having the POINTER attribute
violates F90.

Preventing the second argument from having the ALLOCATABLE attribute
would introduce a prohibition not specified by TR 15581, and might
therefore be viewed as an incompatibility that ought to be announced
in subclause 1.5.

A program couldn't reference defAssgn1 by way of defined assignment
because the right-hand side of a defined assignment is treated as an
expression enclosed in parentheses which would have neither the POINTER
nor the ALLOCATABLE attribute.

A note is provided to draw the readers attention.

EDITS:

At the end of 12.3.2.1.2 insert a new NOTE 12.10+:

"NOTE 12.10+
  If the second argument of a procedure specified in a defined
  assignment interface block has the POINTER of ALLOCATABLE attribute,
  it cannot be accessed by defined assignment, since the right-hand
  side of the assignment is enclosed in parentheses before being
  associated as an actual argument with the second argument.  This
  makes it an expression, which does not have the POINTER or
  ALLOCATABLE attribute."

SUBMITTED BY: Jim Xia

HISTORY: 08-120    m183  F03/0112 Submitted
         08-120r1  m183  Create answer
         08-120r2  m183  Passed by J3 meeting
         08-163    m184  Failed J3 letter ballot 08-141
         08-186r1  m184  Another answer - Passed by J3 meeting
         08-259    m185  Failed J3 letter ballot #17 08-213
         08-263r1  m185  Revised answer - passed by J3 meeting

F2008 note: edit is 09-007r1 [287:6-] 12.4.3.4.3 "Defined assignments"
            after NOTE 12.8 - edit passed at m188

----------------------------------------------------------------------

NUMBER: F03/0119
TITLE: Elemental procedures and deferred length character components
KEYWORDS: deferred length, elemental
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Constraint C1279 says
  "In the scoping unit of an elemental subprogram, an object
   designator with a dummy argument as the base object shall not
   appear in a <specification-expr> except as the argument to one of
   the intrinsic functions BIT_SIZE, KIND, LEN, or the numeric inquiry
   functions (13.5.6)."

It has been stated in previous J3 papers that the reason for this
restriction is to ensure that every iteration of a single invocation
of an elemental procedure will have the same stack size: and this
desire was achieved in Fortran 95.

However, the situation changes with deferred-length character
components.  Consider example 1:

PROGRAM example1
  TYPE t
    CHARACTER(:),ALLOCATABLE :: cp
  END TYPE
  TYPE(t) array(100)
  DO i=1,100; array(i)%cp = REPEAT('x',i); END DO
  CALL zap(array)
  ...
CONTAINS
  ELEMENTAL SUBROUTINE zap(x)
    TYPE(t),INTENT(INOUT) :: x
    REAL work(LEN(x%cp))
    ...
  END SUBROUTINE
END PROGRAM

In the invocation "CALL zap(array)", the invoked procedure will have a
different size for its WORK array for every element of ARRAY.  Thus
the restriction no longer achieves its aim (though this aim is not
actually stated in the standard).

However, as stated the restriction still prohibits the very similar
program example2:

PROGRAM example2
  INTEGER :: array(100) = (/ (i,i=1,100) /)
  CALL es(array)
  PRINT *,array
CONTAINS
  ELEMENTAL SUBROUTINE es(x)
    INTEGER,INTENT(INOUT) :: x
    REAL work(x)
    ...
  END SUBROUTINE
END PROGRAM

There does not seem to be any technical reason for the prohibition
of example2.

A more problematic case arises for an elemental function whose result
variable has a length type parameter that depends on a deferred length
parameter of a dummy argument.  This can occur both for intrinsic type
CHARACTER and for parameterized derived types.  Consider:

PROGRAM example3
  TYPE t1(n)
    INTEGER,LEN :: n
    INTEGER istring(n)
  END TYPE
  TYPE t2
    CHARACTER(:),ALLOCATABLE :: string
  END TYPE
  PRINT *,f( [ t2('short'),t2('this is much longer') ] )
CONTAINS
  ELEMENTAL FUNCTION f(x)
    TYPE(t2),INTENT(IN) :: x
    TYPE(t1(x%string%len)) f
    INTEGER j
    f%istring = [ (ICHAR(x%string(j:j),j=1,f%n)) ]
  END FUNCTION
END

The invocation of F in the PRINT statement will return an array whose
elements have different length type parameters, something that is
supposed to be impossible.

Is this restriction still correct and useful?  That is,
(a) was example1 intended to be standard-conforming,
(b) should example2 be standard-conforming,
(c) was example3 intended to be standard-conforming.

ANSWER:

Although there is no technical (implementation) reason for prohibiting
example2 while allowing example1, doing so is not a defect in the
standard.

However, allowing elemental functions to produce arrays whose elements
have different length type parameters would be a defect.

Thus,
  example1 is standard-conforming as argued;
  example2 is not conforming, because it violates constraint C1279;
  example3 was intended to be prohibited: an edit is supplied to fix
           this defect in the standard.

EDIT:

In 12.7.1, constraint C1278,
  [287:17] After "scalar" change "and" to a comma.
  [288:1] At the end of the sentence insert
    ", and shall not have a type parameter that is defined by
     an expression that is not an initialization expression".

SUBMITTED BY:  Malcolm Cohen

HISTORY: 08-258    m185   Submitted F03/0119
         08-299r1  m186   Revised answer, passed by J3 meeting
         09-103    m187   Revised, passed by J3 meeting + F08 fix
         09-187    m188   Passed J3 letter ballot 09-155 as modified

----------------------------------------------------------------------

NUMBER: F03/0122
TITLE: When do objects of sequence derived type have the same type?
KEYWORDS: SEQUENCE type
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Consider the following program:

       MODULE MOD
         TYPE, PRIVATE :: T
           SEQUENCE
           INTEGER :: I
         END TYPE
         TYPE(T) :: X, Y
       CONTAINS
         SUBROUTINE S
           X = Y
         END SUBROUTINE S
       END

       PROGRAM MAIN
         USE MOD
         CALL S
         X = Y
       END

The first sentence of subclause 4.5.1.3 of the 2003 Fortran standard
says the program conforms because the objects X and Y have the same
type, because they are declared by reference to the same type
definition.  The last sentence of that subclause says they do not
have the same type because the type definition is declared to be
PRIVATE.

Does the program conform to the 2003 Fortran standard?

If not, which assignment statement causes the program not to conform?

ANSWER:

The program conforms to the 2003 Fortran standard.

ANALYSIS:

The determination that an object cannot have the same type as another
one that is declared by reference to a type that is declared to be
PRIVATE cannot possibly refer to an object declared in a scope where
the type is not accessible.  Therefore the objects must be declared
in scopes where the type is accessible.  It is irrelevant whether the
type is "declared to be PRIVATE" in that scope, because accessibility
attributes determine whether a name is accessible in a different
scope.

It would be absurd if the assignment statement in the module
subprogram were not standard conforming.  Given that it must be
standard conforming, it would be absurd if the assignment statement
in the main program were not standard conforming.

Edits are provided to clarify this conclusion.

EDITS:

In subclause 4.5.1.3 [47:11], remove "declared to be PRIVATE or"
from the last sentence.

SUBMITTED BY: Van Snyder

HISTORY: 08-270    m185  F03/0122 submitted
         08-270r1  m185  Passed by J3 meeting
         09-187    m188  Passed J3 letter ballot 09-155

F2008 note: edit is 09-007r1 [63:10] 4.5.2.4 "Determination of derived
  types" remove "declared to be PRIVATE or" - edit passed at m188

---------------------------------------------------------------------

NUMBER: F03/0125
TITLE: Definitions of EXTENDS_TYPE_OF and SAME_TYPE_AS
KEYWORDS: EXTENDS_TYPE_OF SAME_TYPE_AS
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

The arguments of EXTENDS_TYPE_OF and SAME_TYPE_AS are required to
be of extensible type. Does this restriction apply to the declared
type, the dynamic type, or both?

ANSWER:

This restriction was intended to apply to the dynamic type; this is
clear from the existing text.  However, the restriction is stronger
than required or useful, and so an edit is supplied to weaken it.


DISCUSSION:

For EXTENDS_TYPE_OF, this is clear from the Result Value paragraph
which explicitly specifies the result when either the A or MOLD
argument to the intrinsic is unlimited polymorphic.

For SAME_TYPE_AS, this is clear from Note 13.17 which explains how to
work out the result when one or both arguments is a disassociated
pointer (or unallocated allocatable), including that of an unlimited
polymorphic entity.

However, in the case of unlimited polymorphic, it is unreasonable to
require the program to somehow know that the dynamic type is
extensible; these functions should return the right result whenever
either argument is of extensible type, and otherwise it should be
processor dependent, i.e. the restriction should be weakened.

EDITS:

[316:16-17] In 13.7.38, EXTENDS_TYPE_OF, arguments A and MOLD,
  after "of extensible"
  change "type" to "declared type or unlimited polymorphic",
  twice.

[316:21] Change the last "otherwise" to
         "if the dynamic type of A or MOLD is extensible,".

[316:22] At the end of the sentence insert
         "; otherwise the result is processor dependent".

[347:30,348:1] In 13.7.101, SAME_TYPE_AS, arguments A and B,
  after "of extensible"
  change "type" to "declared type or unlimited polymorphic",
  twice.

[348:3] Change "The"
        to "If the dynamic type of A or B is extensible, the"
[348:4] Append new sentence to paragraph
        "If neither A nor B have extensible dynamic type, the
         result is processor dependent."

SUBMITTED BY: John Reid

HISTORY: 08-281    m186  F03/0125 submitted
         08-281r2  m186  Passed by J3 meeting + F08 fix
         09-187    m188  Passed by J3 letter ballot #18 09-155

----------------------------------------------------------------------

NUMBER: F03/0126
TITLE: References to VOLATILE variables in pure procedures
KEYWORDS: VOLATILE, PURE
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Was it intended to allow a VOLATILE variable to be referenced
in a pure procedure?

ANSWER:

No.  It was intended that the result of invoking a pure function in a
FORALL assignment statement should never depend on the order in which
the invocations are executed, see NOTE 12.44.  The value of a variable
with the VOLATILE attribute might change between invocations of the
function in ways incompatible with this design.

EDIT:

[286:22+] In 12.6, Pure procedures, add a new constraint:

  "C1271a The <designator> of a variable with the VOLATILE attribute
          shall not appear in a pure subprogram."

SUBMITTED BY: John Reid and Bill Long

HISTORY: 08-284    m186  F03/0126 submitted in response to N1745 by
                          Nick Maclaren noting the problem
         08-284r1  m186  Passed by J3 meeting {F08 fixed in 12.7
                          "Pure procedures" 09-007 [317:14] C1281}
         09-187    m188  Passed J3 letter ballot #18 09-155

----------------------------------------------------------------------

NUMBER: F03/0127
TITLE: Duration of procedure execution
KEYWORDS: argument association, procedure
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

In the following questions, the following type definition and procedure
are assumed:

  TYPE T
    INTEGER :: C = 17
  END TYPE

  SUBROUTINE S(A,B)
    TYPE(T),INTENT(IN) :: A
    TYPE(T),INTENT(OUT) :: B
    ...
  END

(1) Consider

  TYPE(T) X
  X%C = 3
  CALL S(X,X)

Q1. Is this valid, and if so, is A%C equal to 3 or 17?

Discussion: B is default-initialized "on invocation", and A is not
  permitted to be changed "during execution", so this depends on
  whether "during execution" was intended to include the process of
  invocation.

(2) Consider

  TYPE(T) X
  X%C = 3
  CALL S(F(),X)

where F is the internal function

  TYPE(T) FUNCTION F()
    F = X
  END FUNCTION

Q2. Is this valid?  If so, what is the value of B%C (3 or 17)?

Discussion: The reference to procedure F is not permitted to "affect
  or be affected by the evaluation of any other entity within the
  statement" (7.1.8 paragraph 3).  However, X is not being affected by
  "evaluation" (it is not being evaluated by becoming argument-
  associated with dummy argument A).  A becomes defined "on
  invocation" of S and it is not clear whether that precedes argument
  evaluation or not.

(3) Consider

  SUBROUTINE V(AA,BB)
    TYPE(T),VALUE :: AA
    TYPE(T),INTENT(OUT) :: BB
    ...
  END

  TYPE(T) X
  X%C = 3
  CALL V(X,X)

Q3. Is this valid?  If so, what is the value of AA%C (3 or 17)?

Discussion: AA gets its value by argument association, so happens at
  the same time as the definition of BB (which defines the actual
  argument).  It is not clear what the semantics are here.

Q4. It is similarly unclear as to what is or is not permitted during
    invocation of a procedure when an actual argument might be modified
    by some other activity, for example if it has the VOLATILE or
    ASYNCHRONOUS attribute.

ANSWER:

The standard does not unambiguously supply an interpretation of these,
and therefore they are invalid by subclause 1.5, first sentence.  Edits
are supplied to clarify this.

EDITS:

[81:15] 5.1.2.7, paragraph beginning "The INTENT(IN)",
  change "during the execution"
  to "during the invocation and execution".
{Makes example 1 clearly invalid, and makes it clear that INTENT(IN)
 variables are unchanged from the start of invocation.}

[81:26] Append to the INTENT(OUT) paragraph
  "Any undefinition or definition implied by association of an actual
   argument with an INTENT(OUT) dummy argument shall not affect any
   other entity within the statement that invokes the procedure."
{Makes examples 2 and 3 clearly invalid.}

[275:2,5] Change "during the execution"
  To "during the invocation and execution",
  Twice.
{Makes it clear that the anti-aliasing rules apply for the whole
 process of procedure invocation and execution, not just the
 execution part.}

SUBMITTED BY: Malcolm Cohen

HISTORY: 08-298r1  m186  F03/0127 submitted
         08-298r2  m186  Passed by J3 meeting + F08 edit
         09-187    m188  Passed J3 letter ballot #18 09-155

----------------------------------------------------------------------

NUMBER: F03/0128
TITLE: Subobjects in namelist output
KEYWORDS: NAMELIST
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:

Was it intended to disallow vendors to provide namelist output that
includes a subobject designator followed by a value?

ANSWER:

No, it was intended that vendors should have the same choice as users
writing namelist input as to whether to provide the name of an object
followed by a list of values that give the value of the object or to
provide a sequence of subobject designators, each followed by a list
giving the value of the subobject.

DISCUSSION:

At the start of clause 10.10.2 (Namelist Output) of the Fortran
2003 standard, as amended by Corrigendum 3, is the text
"The form of the output produced is the same as that required for
input, except for the forms of real, character, and logical values, and
output produced with user-defined derived-type output".
There is no exception for the freedom on input to use subobject
designators.

The text in the second paragraph of clause 10.10.2.2, says "The name
of each namelist group object list item is placed in the output record
followed by an equals and a list of values of the namelist group object
list item.". The intention here was to use "name" in the generalized
sense of name or designator, as in paragraph 1 of clause 10.10.1.1:
"If a namelist group object is an array, the input record corresponding
to it may contain either the array name or the designator of a
subobject of that array, using the syntax of object designators (R603).
If the namelist group object name is the name of a variable of
derived type, the name in the input record may be either the name of
the variable or the designator of one of its components, indicated by
qualifying the variable name with the appropriate component name."

Because of the meaning attached to "name", in the rest of the standard,
it should not be used in this way in clause 10.10.2.2.

EDIT:

[247:27] In 10.10.2.2, Namelist output records, paragraph 2, change
"The name" to "The name or designator".

SUBMITTED BY: John Reid

HISTORY: 09-115    m187  Submitted F03/0128
         09-115r1  m187  Passed by J3 meeting + F2008 fix
         09-187    m188  Failed J3 letter balllot #18 09-155: accept
                          edit line number change, F2008 fix from m187
                          does not appear in 09-0007r1; 

  Malcolm Cohen REASON for F03/0128 NO vote:

    The sentence being edited begins
      "The name of each namelist group object list item is placed ...".
    This is not ambiguous in any way.  The namelist group object list
    items are the named variables in the NAMELIST statement; see p95
      R553 <namelist-group-object> <<is>> <variable-name>
    There can be no question about this, regardless of what nonstandard
    behaviour some vendor might or might not do.

    This is a feature request, and what's more, one that makes a
    processor that uses the feature not compliant with Fortran 90/95.
    In the compatibility section we list the things that "may have a
    different interpretation" for F77, so this ought to be there as
    well (that is if we thought it was a good idea).

    Oh, and the edit is way short of implementing the feature, since
    the "designator" of a namelist group object list item is just
    its name.

----------------------------------------------------------------------

NUMBER: F03/0129
TITLE: C_LOC of character substrings
KEYWORDS: interoperability
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Consider
  SUBROUTINE S(A,I,K)
    USE ISO_C_BINDING
    CHARACTER(*),TARGET :: A
    CHARACTER(:),ALLOCATABLE,TARGET :: B
    TYPE(C_PTR) P1,P2,P3,P4,P5
    P1 = C_LOC(A(1:1))    ! *1
    P2 = C_LOC(A(I:I))    ! *2
    P3 = C_LOC(A(1:))     ! *3
    P4 = C_LOC(A(I:K))    ! *4
    ALLOCATE(CHARACTER(1)::B)
    P5 = C_LOC(B)         ! *5
  END SUBROUTINE

C_LOC (case 1) requires of its argument that it have interoperable
type and type parameters (15.1.2.5, p395).  Case 2 does not apply
because character type has a length type parameter.

15.2.1 states
  "if the type is character, interoperability also requires that the
   length type parameter be omitted or be specified by an
   initialization expression whose value is one".

However, a substring does not have a declared type parameter that can
be omitted or specified by an initialization expression.  Even in the
reference marked *1, it is the substring starting and ending positions
that are specified by initialization expressions, not the substring
length.  In any case, if *1 satisfied the quoted requirement then *3
also has its starting and ending positions specified by by
initializations "or omitted".  In case *2, it must be totally obvious
that the length has to be 1 since the expressions are lexically
identical with no user function references, but neither are
initialization expressions.  If I==K, it would be reasonable to expect
*4 to be interoperable but it certainly does not satisfy the stated
requirements.  Or, another interpretation would be that for substrings
the length type parameter is by definition "omitted" since they have
no syntax for its specification: in which case the question would
arise as to what happens for zero-length substrings.

It seems that the authors of the requirement forgot that "variables"
include "substrings".

Finally, case *5 is totally ambiguous because B has multiple length
specifications, one which does not satisfy the requirement (the
declaration) and one which does (the ALLOCATE statement).

ANSWER:

C_LOC should only require nonzero length, which corresponds to the
requirement we make for arrays.

Furthermore, the description of interoperability of intrinsic types
is confusing for type CHARACTER.

Edits are provided to fix the defects.

EDITS:

[395:8(15.1.2.5)] In the <<Argument.>> paragraph,
  Before "type parameters" insert "kind".

[395:16+] Insert new sentence after list:
  "X shall not be a zero-length string."

[396:5-7] Replace "; if ... one." with
  ".  If the type is character, the length type parameter is
   interoperable if and only if its value is one."
{Reword so that the type/kind can be interoperable even if the
 length is not.}

[399:2-3(15.2.4p1)] Before "scalar" insert "named",
{I think this is supposed to be talking about named variables only,
 not about subobjects.}
                    Change "if" to "if and only if"
{Seems to be broken...}
                  Change the second "and" to a comma,
                  At the end of the sentence insert
  ", and if it is of type character its length is not assumed or
   declared by an expression that is not an initialization
   expression".
{It seems more straightforward to forbid the invalid than to require
 the valid.}

[399:7-8(15.2.5)] Change "An array Fortran variable"
                  to "A Fortran variable that is a named array",
                  Change "if" to "if and only if",
                  Change the second "and" to a comma,
                  At the end of the sentence insert
  ", and if it is of type character its length is not assumed or
   declared by an expression that is not an initialization
   expression".

SUBMITTED BY:  Malcolm Cohen

HISTORY: 09-121r1  m187  Submitted F03/0129
         09-121r1  m187  Passed by J3 meeting + F2008 fix
         09-187    m188  Passed J3 letter ballot 09-155 as modified

----------------------------------------------------------------------

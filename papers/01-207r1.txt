
                                                        J3/01-207r1

Date:   14-Jun-2001
To:     J3 Members
From:   interp/Stan Whitlock
Subj:   F95 interp letter ballot #4 - interps ready for WG5

Letter ballot #4 for F95 interps was in 01-207.txt.  The results of
the ballot after J3 meeting #157 are in 01-224r1.txt.  Below are the
text of the interps that "passed by J3 letter baloot" and are ready
for WG5.  These are 2, 10, 11, 12, 18, 19, 20, 21, 22, 24, 25, 28, 29,
81, 85, 87, 88, 89, 90, 91, 92, 93, and JP-06.

At the end of this paper is the new text for interp #23 that failed
the letter ballot, has been amended, and will be submitted for J3
consideration at meeting #158.

/Stan

---------------------------------------------------------------------

NUMBER: 000002
TITLE: Free source form requirement for blank in PRINT statement
KEYWORDS: Free source form, PRINT, blank
DEFECT TYPE: Interpretation
STATUS: Passed by J3 letter ballot

QUESTION:

Consider the following PRINT statement form
Section 3.3.1 of the Fortran 95 standard states:

  A blank shall be used to separate names, constants, or labels from
  adjacent keywords, names, constants, or labels.

  NOTE 3.3
  For example, the blank[s] after ... READ ... [is] required in the
  following:

  ...
  READ 10
  ...

Although the sentence preceding R420 is somewhat confusing in that it
uses the phrase "a sequence of characters, DELIMITED by either
apostrophes or quotation marks", the syntax rule itself is clear that
the " or ' delimiting characters are part of the
<char-literal-constant> syntax.  The first sentence on the top of
page 36 then clarifies that although the delimiter characters are a
part of the syntax, they are not a part of the value.

Section 3.2 makes it clear that a character literal constant is a
token. Section 3.2.5 describes delimiters but does not include either
" or ' because it is describing delimiters for lists.

Thus, it seems clear that in free source form a blank is required
between the keyword PRINT and the character literal constant
containing the format list but there is also some disagreement on
this point among existing Fortran processors.

(1) In free source form, is a blank required between the keyword
    PRINT and the character literal constant containing the format
    specification?

(2) Also, for clarification, in free source form, is a blank required
    between the keyword PRINT and the asterisk that represents the
    list-directed output specifier?

ANSWER:

(1)  Yes.  The analysis in the QUESTION is correct.  Since PRINT is a
     keyword, when the format specification is a character literal
     constant, the blank is required between the keyword PRINT and
     the format specifier.

(2)  No.  Since PRINT is a keyword, according to the cited rule in
     3.3.1, the asterisk would have to be a name, a constant, or a
     label in order for a blank to be required to separate PRINT from
     the asterisk.  By 3.2.1, an asterisk is not a name.  By 3.2.2,
     an asterisk is not a constant.  And by 3.2.4, an asterisk is not
     a statement label.  Yes, an asterisk may be used as a dummy
     argument alternate return specifier representing a statement
     label but that usage is irrelevant to the PRINT statement.
     Therefore, since an asterisk is none of the three items that
     must be separated from PRINT by a blank, the blank is not
     required.

EDITS: None.

SUBMITTED BY: Larry Rolison / Dick Hendrickson

HISTORY: 97-238   m143 Submitted
         01-151r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000010
TITLE: Meaning of embedded blanks in namelist input name
KEYWORDS: NAMELIST, optional qualification, name, input
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

BACKGROUND:

In running some older NAMELIST tests, a test case was encountered
that has embedded blanks within the "optional qualification"
following a namelist group object name:

    CHARACTER*10 string
    NAMELIST /junk/ string

    WRITE(9,*) ' $junk string(  :  ) = ''1234567890'' /'
    REWIND(9)
    READ(9,junk)
    ...
    END

While studying the standard to determine if the above program was
standard- conforming or not, some questions arose about the use of
"name" and embedded blanks in the namelist section 10.9.1.1.  Among
them were: Since a blank is a delimiter, should it be allowed to be
embedded in a variety of places in a namelist input record that are
not currently described by the standard?  Do we want to strain
namelist input scanning more than a reasonable amount?

In normal Fortran terminology, the term "name" does not include
subobject qualification.  In section 2.5.1 Name and designator, lines
2 through 5, the standard states:

  A name is used to identify a program constituent, such as a program
  unit, named variable, named constant, dummy argument, or derived
  type.  The rules governing the construction of names are given in
  3.2.1.  A subobject designator is a name followed by one or more of
  the following: component selectors, array section, array element
  selectors, and substring selectors.

In section 10.9.1 Namelist Input, lines 13 to 16, the standard states:

  In each name-value subsequence, the name shall be the name of a
  namelist group list item with an optional qualification and the
  name with the optional qualification shall not be a zero-sized
  array, a zero-sized array section, or a zero-length character
  string.  The optional qualification, if any, shall not contain a
  vector subscript.

In section 10.9.1.1 Namelist group object names, lines 32 and 33, the
standard states:

  The name in the input record may be preceded and followed by one or
  more optional blanks but shall not contain embedded blanks.

QUESTION:

(1) Does Section 2.5.1 mean that the optional qualification described
    in the 10.9.1 is not part of the name for namelist input?

    If the optional qualification is not part of the name, there seem
    to be no rules for where blanks and end-of-record may occur
    within the optional qualification.

    Also note that size of the name and the optional qualification
    together may be longer than the size of an input record if there
    are multiple levels of structure component qualification in a
    structure component reference.

(2) Are embedded blanks allowed within substring and subscript
    qualifications in the namelist input?  May an END-OF-RECORD occur
    in these same places?

(3) More specifically, are embedded blanks/END-OF-RECORD allowed in
    the following places in namelist input?

   a.  Between the name and the left parenthesis of either a
       substring or subscript qualification?

   b.  Between tokens within the parenthesized qualifier?

   c.  Between the two sets of parentheses for array and substring
       notation?

   d.  Within the two subscripts or start and end values themselves?

 (4) Are embedded blanks allowed within a reference to a structure?
     May an END-OF-RECORD occur within this reference?

ANSWER:

   The answer to all of the questions above is no.

   In section 10.9.1, the standard says "In each name-value
   subsequence, the name shall be ...".  This usage of "name" refers
   to the optionally qualified namelist group object list item;
   therefore, in this context, "name" refers to both the namelist
   group object name list item, and any following qualification.  In
   section 10.9.1.1, the standard says "The name in the input record
   may be preceded and followed by one or more optional blanks but
   shall not contain embedded blanks."  This usage of "name" also
   refers to optionally qualified namelist group object list item;
   therefore, no blanks are permitted anywhere within the "name" of a
   name-value subsequence.  An edit clarifies this.

   Since the end of a record has the same effect as a blank in
   namelist input (10.9), an end of record may not appear anywhere
   within the "name" of a name-value subsequence.

EDITS:

   Replace the last sentence of subclause 10.9.1.1 [179:32-33] by
     "In the input record, each object name or subobject
      designator may be preceded and followed by one or more
      optional blanks but shall not contain embedded blanks."

SUBMITTED BY: Joanne Brixius / Larry Rolison

HISTORY: 97-253   m143 submitted
         01-152r1 m156 Passed unanimously at J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000011
TITLE: G editing typo
KEYWORDS: G edit descriptor
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

In F95 section 10.5.4.1.2, the last line of the table shows an
equivalent conversion of F(w-n).1,n('b').  This is different from the
corresponding table in F90, which shows this conversion as
F(w-n).0,n('b').  There is no obvious reason for this change; it
appears to be a typo in f95.

Should this conversion be F(w-n).0,n('b') as in Fortran 90?

ANSWER:

Yes, this was a typographical error in f95.

EDITS:

[171:23] Last line of the table in 10.5.4.1.2.  Change ".1" to ".0"

SUBMITTED BY: Richard Maine

HISTORY: 97-225   m143 Submitted Aug. 12, 1997
         01-151r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000012
TITLE: Evaluation of Intrinsic Procedures
KEYWORDS: Algorithm, Mathematical, Computational
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

1.  When the standard specifies an algorithm for computing a
    mathematical procedure, must a processor use the specified
    algorithm?

    Example: ANINT is defined as INT (A + 0.5).  On some processors
             ANINT (16 000 001.0) evaluates to 16 000 002.0 using
             this algorithm.

2.  May a processor return a mathematically equivalent result in the
    evaluation of a numeric intrinsic procedure?

    Example: If ANINT (16 000 001.0) can be computed as the more
             expected 16 000 001.0, may a processor do so?

ANSWER:

1.  No, a processor is not required to use the algorithm from the
    standard.

2.  Yes, a processor may return the mathematically equivalent result
    in the evaluation of any numeric intrinsic procedure.

DISCUSSION:

The use of an algorithm in the definitions for intrinsic procedures
is intended to describe the end result.  It is not intended to
require that a processor use a particular method of achieving that
result.  Thus, an algorithm specifies the mathematical results, not
the computational results, of the evaluation of intrinsic procedures.

This standard does not require a processor to use a particular
accuracy or precision.  Section 1.4, "Exclusions", states in part:

    "This standard does not specify: . . .
     (6)  The physical properties of the representation of quantities
          and the method of rounding, approximating, or computing
          numeric values on a particular processor." [1:26, 1:37-38]

The edits correct the definitions of the results for the intrinsic
functions ANINT and NINT to be expressed in mathematical terms.

EDITS:

On page 231, subclause 13.14.10, Result Value paragraph [231:16-17].
Replace by
  <Result Value.> The result is the integer nearest A, or if there are
  two integers equally near A, the result is whichever such integer
  has the greater magnitude.

On page 259, subclause 13.14.77, Result Value paragraph [259:9-10].
Replace by
  <Result Value.> The result is the integer nearest A, or if there are
  two integers equally near A, the result is whichever such integer
  has the greater magnitude.

SUBMITTED BY: Keith H. Bierman

HISTORY: 95-247r1 m134 Submitted as F90 interp 000202 with proposed
                       response, approved 9-4, subsumes F90 interp
                       000200.
         95-256   m134 Ballot failed, 10-6
         95-260   m135 Proposed response, no action
         96-023   m136 Proposed response, no action
         96-054   m137 Proposed response, no action
         96-117   m138 Proposed response, no action
         97-259r1 m143 Re-submitted as F95 interp 000012 with
                       proposed response
         00-214   m153 Passed unanimously
         00-254   m154 Passed J3 letter ballot
         00-268   m154 Failed WG5 ballot (N1403)
         01-153   m155 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000018
TITLE: ELEMENTAL procedures with no arguments
KEYWORDS: Elemental, procedure
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

Section 12.7.2 of ISO 1539-1:1997 seems to assume there is at least
one argument to an elemental procedure.  The semantics of the
following examples do not seem to be clearly specified.

Example 1:
      ELEMENTAL INTEGER FUNCTION f()
        f = 0
      END

Example 2:
      ELEMENTAL INTEGER FUNCTION g(i,j)
        INTEGER,INTENT(IN) :: i,j
        g = i + j
      END

Example 3:
      ELEMENTAL INTEGER FUNCTION h(i)
        INTEGER,INTENT(IN),OPTIONAL :: i
        h = i
      END

Example 4:
      ELEMENTAL SUBROUTINE s()
        REAL x,y,z
        x = 0
        y = 0
        z = x/y
      END

QUESTION 1:

What is the shape of a reference to function F in example 1?  Is it
scalar?

QUESTION 2:

If G() is referenced as G(iscalar,jarray(1:0)), the result is a
zero-sized array.  Is "iscalar" referenced (need it be defined)? Is
the body of G() executed?

QUESTION 3:

What is the shape of a reference to H() if the argument is textually
not present?

QUESTION 4:

When subroutine S is invoked, how many times is it executed?
Is this example standard-conforming, or may a processor raise a
divide-by-zero exception?

ANSWER:

(1) Yes, A reference to F() is intended to be scalar.
    A clarifying edit is supplied.

(2) It is not possible to tell, in Fortran 95, whether the body of
    G() is executed, so that part of the question has no answer.
    [no edit required]
    Yes, ISCALAR must be defined; this is the same situation as
    writing
      ISCALAR + JARRAY(1:0)
    directly, with no user-defined ELEMENTAL procedure being used.
    [no edit required]

(3) If the I argument to H is textually absent, a reference to H
    returns a scalar result (cf. answer to question 1).  Note that
    execution of this procedure is not standard-conforming if the
    optional argument is not present.  The "H = I" line should be
    replaced by
      IF (PRESENT(I)) THEN
        H = I
      ELSE
        H = 0 ! or some other desired scalar value
      END IF
    [no edit required]

(4) The intention was that the subroutine is executed once per
    invocation. This is not clear from the standard; an edit is
    supplied to correct this oversight.  However, the example is not
    standard-conforming on a processor whose arithmetic does not
    allow division by zero.
    [no edit required]

EDITS:

    Replace the final sentence of subclause 12.4.3 [206:7-10] by:
        "A reference to an elemental subroutine (12.7) is an
         elemental reference if there is at least one actual argument
         corresponding to an INTENT(OUT) or INTENT(INOUT) dummy
         argument, all such actual arguments are arrays, and all
         actual arguments are conformable."

[214:28] After "If" insert "there are no actual arguments or".

SUBMITTED BY: Malcolm Cohen

HISTORY: 98-117   m144 Submitted
         00-123   m152 Revised by submitter (version above) but
                       withdrawn for further study without vote
         01-148r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000019
TITLE: Result of NULL intrinsic associated with CHARACTER(*) dummy
       argument
KEYWORDS: NULL intrinsic, assumed character length parameter,
          argument association, pointer association
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION: Consider the following program.

      PROGRAM P
        CALL SUB(NULL())
      CONTAINS
        SUBROUTINE SUB(C)
          CHARACTER(*), POINTER :: C

          PRINT *, LEN(C)
        END SUBROUTINE SUB
      END PROGRAM P

According to 7.1.4.1 [91:27-30], "The data type, type parameters and
rank of the result of the intrinsic function NULL when it appears
without an argument are determined by the pointer that becomes
associated with the result.  See Table 7.2."  In this case, the
pointer that becomes associated with the result is the corresponding
dummy argument when the result appears as an actual argument.

However, according to 5.1.1.5 [51:14-18], a dummy argument of type
character, with a character length parameter of *, "assumes the
length of the associated actual argument when the procedure is
invoked."

Is this a standard conforming program?  If so, how is the length of C
determined, and what should be the output of this program?

ANSWER:

No, this program does not conform to the standard since the actual
argument does not have a character length for the dummy argument to
assume. The edit makes this clear.

EDITS:

Page 91, subclause 7.1.4.1, last line [91:41]. Add
    The optional argument shall also be present if the reference
    appears as an actual argument corresponding to a dummy argument
    with assumed character length.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-148   m145 Submitted
         01-154r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000020
TITLE: Execution of a WHERE statement within a WHERE construct
KEYWORDS: WHERE statement, WHERE construct
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION: 7.5.3.2 [113:17-19] indicates that:

   Upon execution of a WHERE statement or a WHERE construct statement
   that is part of a <where-body-construct>, the pending control mask
   is established to have the value m .AND.(.NOT. mask-expr).
                                     c

[112:41-45] indicates that:

   Upon execution of an ENDWHERE statement, the control mask and
   pending control mask are established to have the values they had
   prior to the execution of the corresponding WHERE construct
   statement.  Following the execution of a WHERE statement that
   appears as a <where-body-construct>, the control mask is
   established to have the value it had prior to the execution of the
   WHERE statement.

Notice that after execution of an ENDWHERE statement, the pending
control mask is established to have the value it had prior to the
execution of the corresponding WHERE construct statement, but the
same is not the case for the pending control mask established by the
execution of a WHERE statement that appears as a
<where-body-construct>.

According to this, the output of the following program

      PROGRAM P
        INTEGER :: A(2) = 0, B(2) = 0

        WHERE((/.TRUE.,.TRUE./))
          WHERE((/.TRUE.,.FALSE./)) A = 1
        ELSEWHERE
          A = 2
        END WHERE
        PRINT *, A

        WHERE((/.TRUE.,.TRUE./))
          WHERE((/.TRUE.,.FALSE./))
            B = 1
          END WHERE
        ELSEWHERE
          B = 2
        END WHERE
        PRINT *, B
      END PROGRAM P

will be

 1 2
 1 0

Was this difference in behaviour intended by the committee?

ANSWER:

No. It was intended that
     WHERE(<mask-expr>) <where-assignment-stmt>
should have the same interpretation as
     WHERE(<mask-expr>)
         <where-assignment-stmt>
     END WHERE
The output from the above program should be
 1 0
 1 0

An edit is supplied to correct the text.

EDITS:

Page 113, subclause 7.5.3.2. In the first line of the paragraph
following NOTE 7.48 [113:17] delete 'a WHERE statement or'; after
the paragraph [113:20+] add the new paragraph:
  Upon execution of a WHERE statement that is part of a
  where-body-construct, the control mask is established to have the
  value <m_c>.AND.<mask-expr>. The pending mask is not altered.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-149   m145 Submitted
         01-155   m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000021
TITLE: Restrictions on <generic-spec> on END INTERFACE
KEYWORDS: INTERFACE block, END INTERFACE, generic procedures
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION: According to section 12.3.2.1 [194:18-20]

    The <generic-spec> may be included in the <end-interface-stmt>
    only if it was provided in the <interface-stmt> and, if
    included, shall be identical to the <generic-spec> in the
    <interface-stmt>.

It is not clear what the words "shall be identical" were intended to
mean. In particular, were they intended to merely convey the idea
that the two <generic-spec>s shall specify the same entity, even
though such an entity might be represented in more than one way, or
were they intended to convey something more restrictive?  Are either
of the following examples standard conforming programs?

Example 1:

      PROGRAM P
        INTERFACE OPERATOR(.NE.)
          LOGICAL FUNCTION F(I, C)
            INTEGER, INTENT(IN) :: I
            CHARACTER(*), INTENT(IN) :: C
          END FUNCTION F
        END INTERFACE OPERATOR(/=)
      END PROGRAM P

Example 2:

      MODULE MOD
        INTERFACE GEN
          SUBROUTINE SUB1(I)
            INTEGER :: I
          END SUBROUTINE SUB1
        END INTERFACE
      END MODULE MOD

      PROGRAM P
        USE MOD, G1=>GEN, G2=>GEN
        INTERFACE G1
          SUBROUTINE SUB2(L)
            LOGICAL :: L
          END SUBROUTINE SUB2
        END INTERFACE G2
      END PROGRAM P

ANSWER:

The intention is that the <generic-spec> in the END INTERFACE
statement should be obviously the same as that in the INTERFACE
statement, both to the human reader and to the compiler.  The words
"shall be identical" signify that they must be lexically identical,
that is, identical apart from layout changes permitted by the source
form and the interpretation of the operators .LT., .LE.,.GT., .GE.,
.EQ., and .NE. as always being identical to <, <=, >, >=, ==, and /=.

Example 1 conforms to the standard, but example 2 does not.

Edits are provided to make this clear.

EDITS:

On page 194, subclause 12.3.2.1, in the fourth constraint following
R1207 [194:19-20] delete 'and, if included, ... <interface-stmt>' and
add:
   If the <end-interface-stmt> includes <generic-name>, the
   <interface-stmt> shall specify the same <generic-name>.  If the
   <end-interface-stmt> includes ASSIGNMENT(=), the <interface-stmt>
   shall specify ASSIGNMENT(=).  If the <end-interface-stmt> includes
   OPERATOR(<defined-operator>), the <interface-stmt> shall specify
   the same <defined-operator>.  If one <defined-operator> is .LT.,
   .LE., .GT., .GE., .EQ., or .NE., the other is permitted to be the
   corresponding operator <, <=, >, >=, ==, or /=.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-150   m145 Submitted
         01-156   m156 1st answer passed unanimously at J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000022
TITLE: Use of NULL() as initialization
KEYWORDS: NULL intrinsic, initialization, default initialization,
          DATA statement
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Rules R429, R505 and R540 respectively describe the syntax for
default initialization of pointer components, pointer objects in type
declaration statements and pointer objects in DATA statements.  These
rules seem to indicate that NULL is to be considered a keyword in
those contexts. This has the surprising effect that the first example
below is a standard conforming program, while the second is not.
That is, in some contexts, something that looks very much like a
reference to an intrinsic function, is in fact a keyword followed by
parentheses.

Example 1:

      MODULE MOD
        INTRINSIC NULL
      END MODULE MOD

      PROGRAM PROG
        USE MOD, DISASSOCIATE=>NULL
        INTEGER, PARAMETER :: NULL = 17
        INTEGER :: J = NULL

        INTEGER :: I
        INTEGER, POINTER :: P => NULL(), P2
        DATA P2, I/NULL(), NULL/
        TYPE DT
          INTEGER, POINTER :: P => NULL()
        END TYPE DT
        TYPE DT2
          INTEGER, POINTER :: I
          INTEGER :: J
        END TYPE DT2
        TYPE(DT2) :: S = DT2(DISASSOCIATE(), NULL), S2
        DATA S2/DT2(DISASSOCIATE(), NULL)/
      END PROGRAM PROG

Example 2:

      MODULE MOD
        INTRINSIC NULL
      END MODULE MOD

      PROGRAM PROG
        USE MOD, DISASSOCIATE=>NULL

        INTEGER, POINTER :: P => DISASSOCIATE(), P2
        DATA P2/DISASSOCIATE()/
        TYPE DT
          INTEGER, POINTER :: P => DISASSOCIATE()
        END TYPE DT
      END PROGRAM PROG

In some places in the scoping unit of PROG example 1, NULL() is used
to specify initialization or default initialization, while in others
NULL is a named constant, and DISASSOCIATE() must be used to specify
initialization.

1) Is example 1 a standard conforming program?

2) Is example 2 a standard conforming program?

3) Was it the intent of the committee that, within the contexts of
   R429, R505 and R540, NULL should be treated strictly as a keyword
   rather than as a reference to an intrinsic function?

DISCUSSION:

The intention is that the intrinsic function NULL be referenced with
no arguments in initialization contexts. This is made clear in the
middle of page 49 in the paragraph that begins 'If <initialization>'
[49:20-21] and also in 7.1.4.1. If the intrinsic function has been
renamed, the new name should be used.

ANSWER:

(1) No, the example is not conforming because it references two
    different entities with the same name (NULL the local variable,
    and NULL the intrinsic function).  See 14.1.2.

(2) No, the example does not conform to the standard as published.
    This is an error, corrected by the supplied edits which make this
    example conforming.

(3) No, the intention was that "NULL()" should be a reference to the
    intrinsic function.  Edits are supplied to remove the keyword
    status of this syntax.

EDITS:

Page 39, subclause 4.4.1, replace the second line of R429 [39:20] by
                 <<or>> => <pointer-initialization-expr>
      R429a  <pointer-initialization-expr> <<is>> <function-reference>
      Constraint: <function-reference> shall be a reference to the
                  intrinsic function NULL with no arguments.

Page 47, subclause 5.1, replace the second line of R505 [47:40] by
                 <<or>> => <pointer-initialization-expr>

Page 49, subclause 5.1, in the paragraph that begins 'If
     <initialization>' [49:20-21], replace 'NULL()' by
     '<pointer-initialization-expr>' twice.

Page 62, subclause 5.2.10, replace the fifth line of R540 [62:19] by
                 <<or>> <pointer-initialization-expr>

Page 62, subclause 5.2.10, in the penultimate line of the page
     [62:48], replace 'NULL()' by 'pointer association status'.

Page 63, subclause 5.2.10, in lines 1, 7 and 10 of the page
     [63:1,7,10], replace  'NULL()' by
     '<pointer-initialization-expr>' thrice.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-151   m145 Submitted
         01-157   m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000024
TITLE: Termination of a partial record by a CLOSE, BACKSPACE,
       ENDFILE, or REWIND statement
KEYWORDS: Record termination, CLOSE, BACKSPACE, ENDFILE, REWIND
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Suppose a partial record has been written as a result of a
nonadvancing WRITE. If the file is closed, or a BACKSPACE, ENDFILE,
or REWIND statement is performed on the file, must the partial record
be terminated?

ANSWER:

After a nonadvancing WRITE there is always a current record in a
file. Existing descriptions of file closure and of the BACKSPACE,
ENDFILE and REWIND statements define subsequent operations on the
file. Further clarification in the BACKSPACE, ENDFILE and REWIND
cases is provided in C.6.1.5 [321:7-11].

An edit is provided to make the intention clear.

EDITS:

Page 136. At the end of the last paragraph of subclause 9.2.1.3.1
[136:33] add
   If a nonadvancing output statement leaves a file positioned within
   the current record and no further output statement is executed
   for the file before it is closed or a BACKSPACE, ENDFILE, or REWIND
   statement is executed for it, the file is positioned after the
   current record before the specified action is performed.

SUBMITTED BY: Robert Corbett

HISTORY: 98-155   m145   Submitted (part 2)
         WG5/N1410       Draft answer
         00-260   m154   Passed by J3 meeting
         00-329   m155   Failed J3 letter ballot
         01-158r1 m156   Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000025
TITLE: List-directed input: types of variables corresponding to
       repeated values
KEYWORDS: List-directed input, repeated values
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

When a repeat count is used in list-directed input, must all the
variables into which the repeated value is read have the same type?
I see no reason in the standard to assume that restriction, but at
least one Fortran 90 implementation assumes it.

ANSWER:

No, the variables are not required to be of the same type, but the
type of the repeated constant is either a literal constant, or a
nondelimited character constant, but not both (10.8, "where <c> is a
literal constant or a nondelimited character constant").  Whether
certain forms of a repeated constant are treated as a literal
constant or a nondelimited character constant is determined by the
type of the first variable which consumes this value.  Indeed, how
many characters from the input record are part of <c> is dependent on
the type of the first variable which consumes a value from that
<r*c>.

For example, the input
   2*(1.0, 0.0)
conforms to the standard when consumed by three list items of type
character or by two list items of type complex.  If there are three
character variables, the first two get the value "(1.0", while the
third gets the value "0.0)".  If there are two complex variables,
they both are assigned the value (1.0,0.0).

Similarly, the input
   2*.TRUE.
can be consumed by two logical variables, or two character variables,
but not by one character and one logical variable.

An edit is provided to clarify the situation.

EDITS:

In section 10.8.1,  add the following as a new paragraph, just before
Note 10.26 [175:33+].
  "For the <r*c> form of an input value, the constant <c> is
   interpreted as a nondelimited character constant if the first list
   item corresponding to this value is of type default character,
   there is a nonblank character immediately after <r*>, and that
   character is not an apostrophe or a quotation mark; otherwise, <c>
   is interpreted as a literal constant."

SUBMITTED BY: Robert Corbett

HISTORY: 98-155   m145 Submitted (part 3)
         WG5/N1410     Draft answer
         01-159r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000028
TITLE: Implicitly Typed Statement Function Character Dummy
KEYWORDS: statement function, constant expression, implicit typing
DEFECT TYPE: Clarification
STATUS: Passed by J3 letter ballot

QUESTION:

Is the following program-unit standard-conforming?

SUBROUTINE sub(n)
  IMPLICIT CHARACTER*(n) (c)
  stmtfn(ch) = LEN(ch)
END

A quick survey of 6 compilers showed no consensus on whether this was
legal, with 3 accepting it (as standard-conforming), 2 rejecting it,
and 1 crashing with an internal error.  The standard seems to say
(middle of section 5.1.1.5, [51:32-33]) that if you explicitly
specify the length then it must be a constant specification
expression, but does not appear to constrain implicit lengths.

ANSWER:

No, the example is not standard-conforming.

DISCUSSION:

The quoted section of the standard says:
  "The length specified for a ... statement function dummy argument
   of type character shall be a constant specification expression."
The first paragraph of 5.3 says
  "In a scoping unit, an IMPLICIT statement specifies a type, and
   possibly type parameters, for all implicitly typed data entities
   ..."

Therefore the requirement that the character length of a statement
function or statement function dummy argument be constant applies to
implicitly typed entities as well as explicitly typed entities.

EDITS: None

SUBMITTED BY: Malcolm Cohen

HISTORY: 98-164   m145 Submitted
         01-149   m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000029
TITLE: Nested Derived Types and Defined Assignment
KEYWORDS: derived type, defined assignment
DEFECT TYPE: Clarification
STATUS: Passed by J3 letter ballot

QUESTION:

According to Fortran 90, intrinsic assignment of derived
type entities does not invoke defined assignment for components of
these entities, even if it exists.  Should this situation have been
corrected in Fortran 95 to avoid breaking encapsulation of derived
types?

That is, in the example program below, is the final assignment
statement intended to invoke the user-defined assignment routine for
the "name" components of "a" and "b", or should it do pointer
assignment on the (PRIVATE) "value" components of the "name"
components?

MODULE lib_varying_string
  TYPE varying_string
    PRIVATE
    CHARACTER,POINTER :: value(:)
  END TYPE
  INTERFACE ASSIGNMENT(=)
    MODULE PROCEDURE assign_vs_to_vs
  END INTERFACE
CONTAINS
  SUBROUTINE assign_vs_to_vs(var,expr)
    TYPE(varying_string),INTENT(OUT) :: var
    TYPE(varying_string),INTENT(IN) :: expr
    ALLOCATE(var%value(SIZE(expr%value,1)))
    var%value = expr%value
  END SUBROUTINE
END
PROGRAM programme
  USE lib_varying_string
  TYPE mytype
    TYPE(varying_string) name
  END TYPE
  TYPE(varying_string) x,y
  TYPE(mytype) a,b
  x = y               ! invokes "assign_vs_to_vs(x,(y))".
  a%name = b%name     ! invokes "assign_vs_to_vs(a%name,(b%name))"
  a = b               ! in F90, pointer assigns the "value" components
END

ANSWER:

No, there is no ambiguity or error in the standard.

DISCUSSION:

Intrinsic assignment is not intended to invoke user-written
procedures. This would introduce anomalies with initialization by
DATA statements.

Library writers cannot in any case depend on defined assignment to
enforce encapsulation automatically, because the user can
deliberately (or accidentally) omit to import the defined assignment
from the module. (Also, other facilities such as TRANSFER may break
encapsulation).

In the example given, a defined assignment should be provided for
TYPE(mytype) by the programmer.

EDITS: None.

NOTE: This is MTE work item M16 for Fortran 2000.

SUBMITTED BY: Malcolm Cohen

HISTORY: 97-197   m142  Submitted
         97-197   m145  Passed unanimously as amended {see 98-167
                        minutes}
         Failed WG5 letter ballot.
         00-330   m155  Option 0 answer passed unanimously by J3
                        meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000081
TITLE: Definition status of derived-type objects with pointer
       components
KEYWORDS: Definition status, Derived type, Pointer component
DEFECT TYPE: Clarification
STATUS: Passed by J3 letter ballot

QUESTION:

Consider:
        TYPE t
          REAL,POINTER :: x
        END TYPE
        TYPE(t) var1,var2
        NULLIFY(var1%x)
        var2 = var1     ! Unfortunate.

According to 14.7.1,
  "An object is defined if and only if all of its subobjects are
   defined."

from which I conclude that the program fragment above is not
conforming.

Should the definition status of an object containing pointer
components depend on the pointer association status of its pointer
components and not their definition status?

ANSWER:

No, pointer components shall not affect the definition status of an
object.  The above program fragment was intended to be standard-
conforming.  Edits are supplied to clarify this situation.

EDITS:

[288:17] Replace with
  "(1) An array is defined if and only if all of its elements are
       defined.

   (2) A derived-type scalar object is defined if and only if all of
       its nonpointer components are defined.

   (3) A complex or character scalar object is defined if and only if
       all of its subobjects are defined."

[288:18-19] Replace "(2)" with "(4)".

SUBMITTED BY: Malcolm Cohen

HISTORY: 99-266   m151 submitted
         99-266r1 m151 approved uc
         00-135   m152 revised but withdrawn (no vote)
         01-165r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000085
TITLE: Public components of inaccessible types
KEYWORDS: Accessibility, Derived Types, Components
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

F90 interpretation 32 indicated that components of a derived type
may be accessible even in scopes where the derived type name is
inaccessible.  It added an edit to 12.1.2.2.1 of f90 (14.6.1.3 of
f95) saying
  "If a derived type name of a host is inaccessible, data entities of
   that type or subobjects of such data entities can still be
   accessible."

The discussions in the last 2 paragraphs of 4.4.1 of f95 appear to
treat the accessibility of the derived type and its components
as independent issues.  Drafts of f2k added a note to make the
independence clear.

However, 14.1.2.5 of f95 says "If the type is accessible...and the
definition of the type does not contain the PRIVATE statement
(4.4.1), the component name is accessible...."  This statement
appears to make accessibility of the type a condition for
accessibility of the component names, in contradiction with the
above cited edit from f90 interpretation 32.

The following code sample illustrates the issue.  This sample works
on several f90 compilers.

  module m
    type t
      integer :: i
    end type t
    type (t) :: a
  end module m

  program p
    use m, only: a
    a%i = 2
    write (*,*) a%i
  end program p

Question 1.  Is it allowed to access public components of a derived
type object when the type name is inaccessible as illustrated in the
above sample code?

Question 2.  Should there be an edit in 14.1.2.5 of f95 to clarify
this?

ANSWER: (1) Yes.
        (2) Yes.

DISCUSSION:

The quoted text from 14.1.2.5 does not specify the accessibility
of components when a type is not accessible.

EDITS:

[280:25-26] Replace
              "the type is accessible ... 14.6.1.3)"
            by
              "an entity of the type is accessible in another scoping
               unit"
{Whether by use or host association, or - if the type is accessible -
 by declaring a local variable of the type.}

SUBMITTED BY: Richard Maine

HISTORY: 99-101   m148   Submitted
         WG5/N1404       Draft answer
         00-260   m154   Passed by J3 meeting
         00-329   m155   Failed J3 letter ballot
         01-160   m156   Passed unanimously at J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000087
TITLE: MOD and MODULO intrinsic functions with zero divisor
KEYWORDS: Intrinsic functions, MOD, MODULO
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Consider the programs:

      PROGRAM example1
        PRINT *,MODULO(3,0)
        PRINT *,'Test succeeded'
      END

      PROGRAM example2
        PRINT *,MOD(3,0)
        PRINT *,'Test succeeded'
      END

Are these programs standard-conforming, and should "Test succeeded" be
printed in each case?

DISCUSSION:

13.14.74 says of MODULO: "If P=0, the result is processor dependent."

13.14.73 says of MOD: "If P=0, the result is processor dependent."

It appears that example1 and example2 are equally conforming.

INFORMATION:

Out of 7 Fortran 90/95 compilers, with
  example1: 5 compiled it ok, 3 of these crashed it at runtime
  example2: 2 compiled it ok, both of these crashed it at runtime

Out of 1 FORTRAN 77 compiler,
  example2 did not compile (error message).

Note that section 7.1.7 [97:6-7] states
  "The execution of any numeric operation whose result is not defined
   by the arithmetic used by the processor is prohibited."
This would seem to be contradictory, at least in spirit, to the
definitions of MOD and MODULO.

ANSWER:

No, these programs were not intended to be standard-conforming. The
processor should be allowed to optimise assuming that P is not zero.
Edits are supplied to correct this mistake in the standard.

EDITS:

  [3:32+] "(3) Earlier standards specified that if the second
               argument to MOD or MODULO was zero, the result was
               processor dependent.  This standard specifies that
               the second argument shall not be zero."
  [257:30]    Append "P shall not be zero."
  [257:32]    Change "If P .ne. 0, the" to "The"
  [257:32-33] Delete "If P = 0, the result is processor dependent."
  [257:41]    Append "P shall not be zero."
  [258:2]     Delete "If P .ne 0,"
  [258:4]     Delete "If P = 0, the result is processor dependent."
  [258:5]     Change "If P .ne. 0, the" to "The"
  [258:5-6]   Delete "If P = 0, the result is processor dependent."

SUBMITTED BY: Malcolm Cohen

HISTORY: 00-325   m155 Passed unanimously as amended by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000088
TITLE: INTRINSIC statement and attribute
KEYWORDS: intrinsic
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Is it possible for a variable or external procedure that has the same
name as the specific name of an intrinsic function listed in section
13.13 of the Fortran 95 standard and not marked with a bullet to be
used as an actual argument?

For example, consider the following program:

  module SCREEN
    type :: COLOR
      integer :: RED, GREEN, BLUE
    end type COLOR
  contains
    subroutine SET_BACKGROUND ( WHAT )
      type(color), intent(in) :: WHAT
      ! Call to set the background color
    end subroutine SET_BACKGROUND
  end module SCREEN

  program TEST_SCREEN
    use SCREEN
    real, external :: DIM
    character(len=15) :: SIGN
    real :: SIN
    type(color) :: TAN = color(210,180,140)
    call color_intensity ( dim )
    call biblical ( sign )
    call cardinal ( sin )
    call set_background ( tan )
  end program TEST_SCREEN

Notice that the actual arguments have the names of specific intrinsic
functions listed in section 13.13 of the Fortran 95 standard, but
they do not appear in an INTRINSIC statement, nor are they given the
INTRINSIC attribute in a type declaration statement, as required by
the penultimate normative paragraph of 12.3.2.3 of the Fortran 95
standard [198:7-9].

ANSWER:

The answer to the question in the first paragraph is yes.

Fortran has no reserved words. In the scope of the above main program,
none of the names DIM, SIGN, SIN and TAN are names of intrinsic
procedures. The paragraph referenced reads:

   If the specific name of an intrinsic function (13.13) is used as an
   actual argument, the name shall either appear in an INTRINSIC
   statement or be given the INTRINSIC attribute in a type declaration
   statement in the scoping unit.

and tells us that SIN does not refer to the intrinsic procedure. The
names DIM, SIGN, and TAN can be identified from their declarations
not to be intrinsic procedures. Since none of the names are those of
intrinsic procedures, the paragraph does not affect their use as the
names of actual arguments. The edit makes the meaning clearer.

EDITS:

Page 198, Subclause 12.3.2.3, replace lines 7-9 of page 198 [198:7-9]
by
  'If a specific intrinsic function (13.13) is used as an actual
   argument, it shall have been explicitly declared to have the
   INTRINSIC attribute.'

SUBMITTED BY: Van Snyder

HISTORY: 00-249   m154 Submitted
         01-136r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000089
TITLE: Rules allowing duplicate names
KEYWORDS: generic, duplicate names
DEFECT TYPE: Clarification
STATUS: Passed by J3 letter ballot

QUESTION:

Under what conditions can a name in class (1) as described in 14.1.2
be used in more than one declaration?

The second complete paragraph after the list in 14.1.2, immediately
before note 14.2 [276:5-7 in 97-007r2] begins:

``Within a scoping unit, a name that identifies a local entity of one
class shall not be used to identify another local entity of the same
class, except in the case of generic names (12.3.2.1).''

Is the intent here that a generic name may be used only to identify
another generic interface, or that a generic name may be used to
identify any other entity in class (1)?

ANSWER:

The rules are laid out in 12.3.2.1, which is referenced. The
exceptional case is that a procedure is permitted to have the same
specific and generic name.

EDITS: None

SUBMITTED BY: Van Snyder

HISTORY: 00-246   m154 Submitted
         01-137r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000090
TITLE: What do ``Prior Specification'' and ``defined previously''
       mean?
KEYWORDS: initialization, prior specification, defined previously
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION 1

What is a ``prior specification?''

The last normative paragraph of section 7.1.6.1 of the Fortran 95
standard, immediately before note 7.14 [94:38-41 in 97-007r2] states:

``If an initialization expression includes a reference to an inquiry
function for a type parameter or an array bound of an object
specified in the same <specification-part>, the type parameter or
array bound shall be specified in a prior specification of the
<specification-part>.  The prior specification may be to the left of
the inquiry function in the same statement.''

The first two sentences of the last normative paragraph of section
7.1.6.2 of the Fortran 95 standard, immediately before note 7.16
[96:32-35 in 97-007r2] are similar, but refer to specification
expressions.

Unfortunately, there is no definition of ``prior specification.''
Consider:

1.  INTEGER :: P(complicated_expression_for_lower_bound_1:   &
               & complicated_expression_for_upper_bound_1,   &
               & complicated_expression_for_lower_bound_2:   &
               & complicated_expression_for_upper_bound_2) = &
               & RESHAPE( (/ 11, 21, 12, 22 /), SHAPE(P) )

(Notice the reference to P in the <initialization>.)

Some processors reason ``the `specification' of P is only the
specification of its name, kind, rank and array bounds, and therefore
is `prior' by the time the <initialization> is encountered,'' and
accept this.

Others reason ``the `specification' of P is the syntax term
<entity-decl> defined by syntax rule R504 on page 47, which includes
the <initialization>, and it is therefore not `prior' until the
<initialization> is completely specified,'' and do not accept this.

By way of further examples, which of the following are standard
conforming?

2.  INTEGER(selected_int_kind(4)) :: A(KIND(A))
3.  INTEGER :: A(2,2*SIZE(A,1)+1)
4.  CHARACTER :: C(10)*(SIZE(C,1))
5.  INTEGER :: P(10) = LBOUND(P,1)

The paragraphs cited above are silent concerning inquiry functions
that are not for type parameters or array bounds.  These include
BIT_SIZE, DIGITS, EPSILON, MAXEXPONENT, MINEXPONENT, PRECISION,
RADIX, RANGE and TINY.  The results of all of these are derived,
however, from the types and kind type parameters of their arguments.

Are the objects about which these functions inquire required to be
specified in a prior specification of the <specification-part>, and
is that specification allowed to be in the same statement so long as
it is to the left of the inquiry function of which it is an argument?

Which of the following are standard conforming?

6.  INTEGER :: B = BIT_SIZE(B)
7.  INTEGER :: B(BIT_SIZE(B))
8.  INTEGER :: D = DIGITS(D)
9.  INTEGER :: D(DIGITS(D))
10. REAL :: X = EPSILON(X)

One could construct obvious similar examples for the remainder of
inquiry functions that do not inquire about type parameters or array
bounds.

QUESTION 2

The second normative paragraph in subclause 5.1.2.1 [52:27-28 in
97-007r2] states "Any named constant that appears in the
initialization expression shall have been defined previously in the
same type declaration statement...."  The third normative paragraph
after syntax rule R531 in subclause 5.2.9 [61:4-7 in 97-007r2] is
similar.

Does "defined previously" mean that all of the properties of the
named constant shall have been defined previously, or that a
referenced property of it shall have been defined previously?  E.g.
if the KIND is needed, is it necessary for the value to have been
defined?

ANSWER 1

    A prior specification refers to a specification in a previous
    <entity-decl> or in a previous statement.  None of the examples
    are legal.  Edits are included to clarify this.

ANSWER 2

    In the referenced text (5.1.2.1), "Any named constant that
    appears ... shall have been defined previously" mean that all of
    the properties of the named constant shall have been defined
    previously;  therefore, if the KIND of a named constant is
    needed, is it necessary for the value of that named constant to
    have been defined previously also.

EDITS:

    Page 94, Subclause 7.1.6.1. In the first line of the last
    paragraph of page 94 [94:38], replace 'for a type parameter' by
    'that depends on a type parameter'.

    Page 94, Subclause 7.1.6.1, replace the last sentence of page
    94 [94:40-41] by 'The prior specification may be to the left of
    the inquiry function in the same statement, but shall not be
    within the same <entity-decl>.'

    Page 96, Subclause 7.1.6.2. In the first line of the last
    paragraph of the subclause [96:32], replace 'for a type
    parameter' by 'that depends on a type parameter'.

    Page 96, Subclause 7.1.6.2, replace the second sentence of the
    last paragraph of the subclause [96:34-35] by 'The prior
    specification may be to the left of the inquiry function in the
    same statement, but shall not be within the same
    <entity-decl>.'

SUBMITTED BY: Van Snyder

HISTORY: 00-229   m154 Submitted
         00-324   m155 Amended
         01-138r1 m156 Passed by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000091
TITLE: Definition of "present" is defective
KEYWORDS: present, dummy argument
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

Subclause 12.4.1.5 begins with a definition of the term "present":

"A dummy argument is present in an instance of a subprogram if it is
associated with an actual argument and the actual argument either is a
dummy argument that is present in the invoking subprogram or is not a
dummy argument of the invoking subprogram."

This seems to be defective in that if the actual argument is a dummy
argument that is accessed by host association, it is not a dummy
argument OF the invoking subprogram, and therefore although it may be
"not present" in the procedure of which it is a dummy argument, it is
nonetheless "present" in an internal procedure of that procedure.

Consider:

  module M
  contains
    subroutine S1 ( A )
      integer, optional :: A
      call S11
    contains
      subroutine S11
        call S12 ( A )
      end subroutine S11
      subroutine S12 ( B )
        integer, optional :: B
        if ( present(B) ) print *, 'B is present'
      end subroutine S12
    end subroutine S1
  end module M

  program P
    use M, only: S1
    call S1
  end program P

Should this print "B is present" as implied by the above analysis?

ANSWER:

No, the program should not print anything.

DISCUSSION:

The lack of consideration of host association in the cited text is
accidental; an edit is supplied to correct this oversight.

EDITS:

[202:43-45] Replace the first sentence of 12.4.1.5 by
    "A dummy argument is not <<present>> if it is
      (1) not associated with an actual argument, or
      (2) is associated with an actual argument that is
          (a) a dummy argument that is not present or
          (b) an entity that is host-associated with a dummy argument
              that is not present.
     Otherwise, it is present."

[299:4-6] Delete the glossary entry for <<present>>

SUBMITTED BY: Van Snyder

HISTORY: 01-134   m156 Submitted
         01-134r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000092
TITLE: Values of the PAD= Specifier in the INQUIRE Statement
KEYWORDS: PAD=, INQUIRE
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

The normative text of the Fortran 90 and Fortran 95 standards
(9.6.1.22) specifies that the PAD= specifier in the INQUIRE statement
returns the value YES if there is no connection or if the connection
is for unformatted input/output.

This behavior is different from the results of almost every other
specifier for the INQUIRE statement if the property being inquired
about is unknown or undefined.  For those specifiers, the value
returned in the specifier's variable is either UNKNOWN or UNDEFINED.

Is the specified behavior of the PAD= specifier for an unformatted
file or an unconnected unit intentional?

ANSWER:

No, this specification is in error.  Edits are supplied to correct
this defect.

DISCUSSION:

The concept of padding input records does not make any sense if the
unit is connected for unformatted input/output or if the unit is not
connected.  A return value of YES does not reflect what is really
going on.  A return value of UNDEFINED is more appropriate in these
situations.

The normative text for this section in Fortran 95 is unchanged from
Fortran 90, so correcting this defect is an incompatibility with
Fortran 90.

EDITS:

  [3:32+] Add the following list item to the list in section 1.5.1,
          "Fortran 90 compatibility".

          (3) The PAD= specifier in the INQUIRE statement in this
              standard returns the value 'UNDEFINED' if there is no
              connection or the connection is for unformatted
              input/output.  The previous standard specified 'YES'.

  [159:40-41] Replace the second sentence of the paragraph in section
              9.6.1.22 with the following.

              The <scalar-default-char-variable> in the PAD=
              specifier is assigned the value YES if the connection
              of the file to the unit included the PAD= specifier and
              its value was YES or if there was no PAD= specifier.
              If there is no connection or if the connection is not
              for formatted input/output, the
              <scalar-default-char-variable> is assigned the value
              UNDEFINED.

  [325:30] Change the entry in the table to:

           +--------+-----------+------------------------+-----------+
           | PAD=   | UNDEFINED | YES, NO, or UNDEFINED  | UNDEFINED |
           +--------+-----------+------------------------+-----------+

SUBMITTED BY: Craig T. Dedo

HISTORY: 01-172   m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000093
TITLE: Allocatable arrays as actual arguments
KEYWORDS: Allocatable array, actual argument
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

There does not seem to be any requirement that an allocatable array be
allocated for it to be used as an actual argument.  Consider

    PROGRAM P
        ALLOCATABLE A(:,:)
        CALL S(A)
    CONTAINS
        SUBROUTINE S(X)
            DIMENSION X(:,:)
            PRINT *,SHAPE(X)
        END SUBROUTINE
    END

Is this a standard-conforming program?  If so, what does it print?

ANSWER:

No, this is not intended to be a standard-conforming program.  An
allocatable array must be allocated for it to be used as an actual
argument, except where otherwise specified in the standard (e.g. for
the ALLOCATED intrinsic function.  An edit is supplied to clarify
this intent.

EDITS:

[80:34] In item (1) in the list in clause 6.3.1.2, change "; it" to
        ".  It shall not be supplied as an actual argument except to
         certain intrinsic inquiry functions.  It"

SUBMITTED BY: Malcolm Cohen

HISTORY: 01-184   m156 Passed unanimously at J3 meeting
         01-224r1 m157 Passed by J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-06
TITLE: Type declaration statements
KEYWORDS: Object name, Type declaration
DEFECT TYPE: Erratum
STATUS: Passed by J3 letter ballot

QUESTION:

JP-6)
  5.1 Type declaration statements

  As for the 16th and 19th constraint after R506:

  the 16th [48:25]:
  "Constraint: The function-name shall be the name of an external
   function, an intrinsic function, a function dummy procedure, or a
   statement function."

  Because the syntactic class `object-name' is only defined as a
  `name' in the standard, the following constraint should be added
  here:
  Constraint: The object-name shall be the name of a data object.
  [48:26+]

  After that, in the 19th [48:31]:
  "Constraint: initialization shall not appear if object-name is dummy
   argument, a dummy argument, a function result, an object in a named
   common block unless the type declaration is in a block data program
   unit, an object in blank common, an allocatable array, an external
   name, an intrinsic name, or an automatic object."

  In the above, `a function result,' should be removed.

  If we can not add the constraint above, `a statement function'
  should be added in the 19th constraint.

DISCUSSION:

There is a typographical error in the quoted 19th constraint in the
question in that "dummy argument" appears twice.

ANSWER:

Yes, we agree that the constraint above should be added.
However, the 19th constraint should not be modified since
a function result is a data object that cannot be initialized.

EDITS:

  [48:26+] Add:
           "Constraint: The object-name shall be the name of a data
            object."

SUBMITTED BY: Japan

HISTORY: 99-208        Submitted
         99-221        Classed as Fortran 95 Interpretation.
         WG5-N1411     draft answer
         01-151r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Passed by J3 letter ballot
----------------------------------------------------------------------

**********************************************************************

NUMBER: 000023
TITLE: Termination of the previous record by a WRITE statement
KEYWORDS: Nonadvancing, Record termination, WRITE
DEFECT TYPE: Clarification
STATUS: J3 consideration in progress

QUESTION:

Suppose a sequential formatted file is positioned within a record as
a result of a nonadvancing READ.

1. If the next operation performed on the file is a WRITE, can the
   current record be terminated at its current position before the
   next record is written?  Section 9.2.1.3.2 appears to preclude the
   record from being terminated, but at least one Fortran 90
   implementation does terminate the record in such an instance.

2. If the next operation is a nonadvancing WRITE and the number of
   characters written does not extend to the end of the current
   record, are the remaining characters at the end of the record
   preserved?

ANSWER:

1. No.  If the current record were to be terminated, the file
   position would be changed.  Section 9.2.1.3.2 [136:37-39] states:
   "For sequential access on input, if there is a current record, the
   file position is not changed.  Otherwise, the file is positioned
   at the beginning of the next record and this record becomes the
   current record."

2. Yes, the remaining characters in the record are preserved.  The
   record read by the non-advancing READ is the current record and
   file position is within that current record.  The WRITE overwrites
   characters starting at the current file position but all the
   characters in the current record are preserved.  For example:

        WRITE (1, '(A3)') 'ABCDEFGHI'
        REWIND (1)
        READ (1, '(A3)', ADVANCE='NO') THREE_CHARS
        WRITE (1, '(A3)', ADVANCE='NO') 'XXX'
        CLOSE (1)

   would create a file with the single record 'ABCXXXGHI'.

EDITS: None

SUBMITTED BY: Robert Corbett

HISTORY: 98-155   m145 Submitted (part 1)
         WG5/N1410     Draft answer
         01-151r1 m156 Passed unanimously by J3 meeting
         01-224r1 m157 Failed J3 letter ballot

----------------------------------------------------------------------


                                                J3/06-131

Date: 31-jan-2006
To:   J3
From: Bill Long
Subject: Edits for BITS
References: Feature J3-047, J3/05-188, J3/05-274
--------------------------------------------------------------

Following are a draft ofthe edits to implement the J3-047 
feature, BITS type, as amended by paper J3/05-274.


Note 1. < and > are used to delimit italic font. << and >> are 
used to delimit bold font.

Note 2. All page and line numbers refer to j3/04-007.


EDITS

.....................................................................
[xiii] Introduction, the list of new Fortran 2008 features should 
include

  A BITS data type for non-numeric programming, enhanced handling of
  BOZ constants, simplified interfaces, and standardization of common
  extensions and intrinsics.

.....................................................................
In section 1.6 Compatibility, retain paragraph 3:5-9 regarding new 
intrinsic procedure names. There are new intrinsics introduced in 
this proposal. 

In addition, add to a section on incompatibility with Fortran 2003:

[3:10-]

  This standard specifies a new intrinsic type, BITS, which will
  conflict with a user defined type of the same name.

  This standard specifies a new intrinsic operator, .XOR., which
  will conflict with a user defined operator of the same name.

.....................................................................
[15:39] Replace the second sentence of 2.4.1.1 Intrinsic type with:

The intrinsic types are integer, real, complex, character, logical,
and bits.

.....................................................................
[16:2-3] Replace the end of the first sentence in the second 
paragraph of 2.4.1.1 Intrinsic types that begins with ", and the
representation..." with:

, the representation methods for the character and logical types
(4.4.4, 4.4.5), and the number of bits for the bits type (4.4.6).

.....................................................................
[26:28+] Add a new rule to '3.2.3 Operators'  to make .XOR. a
kind of <equiv-op>:

               <<or>>  .XOR.

.....................................................................
[33:5] At the end of the second paragraph of 'Section 4: Types',
replace "character, and logical." with 
"character, logical, and bits."

.....................................................................
[33:19] At the end if the second sentence of '4.1.1 Set of values', 
replace "character, and real." with: "character, real, and bits."

.....................................................................
[35:29] In 4.4 Intrinsic types, replace the list of non-numeric types
with:

   nonnumeric types:       character, logical, and bits

.....................................................................
[36:7+] Add a new type entry in 4.4 Intrinsic types, to 
R403 <intrinsic-type-spec>:

    <<or>> BITS [<kind-selector>]

.....................................................................
[37:1-18] Move the description of <boz> constants out of 
4.4.1 Integer type to new section 4.4.6 Bits type - edits [44:17+].

.....................................................................
[37:19-25] Delete description of boz constants (replaced with new
text in [44:17+]) and remove constraint C410 in '4.4.1 Integer type'.

.....................................................................
[44:17+] Add a new subsection:

4.4.6 Bits type

The <<bits type>> has a set of values composed of ordered
sequences of bits. The number of bits in the sequence is specified
by the kind type parameter, KIND, which shall be greater than or
equal to zero. A processor shall provide bits kinds with kind values
in the range zero through four times NUMERIC_STORAGE_SIZE (13.8.2.7).

The type specifier for the bits type uses the keyword BITS.

If the kind type paratmeter is not specified for a bits variable, 
the default kind value is NUMERIC_STORAGE_SIZE, and the type 
specified is default bits.

If the kind parameter is not specified for a BITS literal constant,
the kind value is assumed from the form of the constant.  If the
constant is a <binary-constant> the kind value is the number of
<digit> characters. If the constant is an <octal-constant> the kind
value is three times the number of <digit> characters. If the constant
is a <hex-constant> the kind value is four times the number of
<hex-digit> characters.

Any bits value may be represented as a <boz-literal-constant>, or a
concatenation of multiple <boz-literal-constant>s.

***Note to editor: Insert the text from [37:1-18] here.

The digits of octal constants represent triples of bits, and the
digits of hexadecimal constants represent quartets of bits, according
to their numerical representations as binary integers, with leading
zero bits where needed. 

A trailing <kind-param> is allowed for a BOZ constant. If the
<kind-param> specified has a value greater than the kind assumed from
the number of <digit>s or <hex-digit>s in the constant, the constant
is padded on the left with enough 0 bits to create a constant of kind
<kind-param>.  If the <kind-param> specified has a value smaller than
the kind assumed from the number of <digit>s or <hex-digit>s in the
constant, bits on the left are removed to create a constant of kind
<kind-param>.

Note 4:15a: 
Though the processor is required to provide bit kinds up to four
times NUMERIC_STORAGE_SIZE, it is expected that the actual size limit
is much larger, based on system capacity constraints. Use of BITS
objects with KIND values equal to small integer multiples of
NUMERIC_STORAGE_SIZE should result in more aggressive optimization.
[end Note]

.....................................................................
[76:5+] In '5.1.1.2 Class' in the discussion of type compatibility,
add a new paragraph:

An entity of type bits is <<bits type compatible>> with an entity of
type bits, integer, real, complex, or logical if and only if both
entities return the same value when supplied as arguments to the
inquiry intrinsic function COMPATIBLE_BITS_KIND. 

.....................................................................
[76:7-9] In '5.1.1.2 Class', replace the paragraph defining TKR
compatible with:

An entity is type, kind, and rank compatible, or <<TKR compatible>>,
with another entity if the first entity is type compatible with
the second and the kind type parameters of the first entity have the
same values as corresponding kind type parameters of the second, or
the two entities are bits type compatible, and both entities have
the same rank.

.....................................................................
[89:20-22] Delete this paragraph from '5.2.5 DATA statement', 
referring to <boz-literal-constants> in DATA statements.

.....................................................................
[119:2] In '7.1.1.4 Level-3 expressions' replace "character 
operator <concat-op>" with "character operator and bits 
concatenation operator <concat-op>".
 
.....................................................................
[120:2] In '7.1.1.5 Level-5 expressions' replace "the logical 
operators" with "the logical and bits operators".

.....................................................................
[120:12+] In '7.1.1.6 Level-5 expressions', extend rule R721 for
<equiv-op> to include .XOR.:

        <<or>> .XOR.

.....................................................................
[121:7+] In 'Table 7.1: Type of operands and results for intrinsic
operators', replace boxes 3-7 with (redundant headings supplied for
clarity only):

Intrinsic operator          Type of  Type of       Type of
     <op>                    <x1>    <x2>         [<x1>] <op> <x2>
----------------------------------------------------------------
      //                      C       C              C
                              B       B              B
----------------------------------------------------------------
                              I      I,R,Z,B       L,L,L,L
   .EQ. .NE.                  R      I,R,Z,B       L,L,L,L
    ==, /=                    Z      I,R,Z,B       L,L,L,L
                              B      I,R,Z,B       L,L,L,L
                              C         C             L
----------------------------------------------------------------
                              I      I,R,B         L,L,L
.GT.,.GE.,.LT.,.LE.           R      I,R,B         L,L,L
 >, >=, <, <=                 B      I,R,B         L,L,L
                              C        C             L
----------------------------------------------------------------
      .NOT.                            L,B           L,B
----------------------------------------------------------------
.AND.,.OR.,.XOR.,.EQV,        L        L             L
.NEQV.                        B        B,I           B,B
                              I        B,I           B,B

.....................................................................
[121:7+] In the Note at the bottom of 'Table 7.1: Type of operands
and results for intrinsic operatiors', replace the first sentence
with"

The symbols I, R, Z, C, L, and B stand for the types integer, real,
complex, character, logical, and bits respectively.

.....................................................................
[121:16+] After the 4th paragraph of '7.1.2 Intrinsic operations'
add a new paragraph:

A <<bits intrinsic operation>> is an intrinsic operation for which at
least one of the operands is of type bits. For bits intrinsic
operations where the <intrinsic-operator> is not the <<bits
concatenation operator>> (//), the two operands may be of different
types or different kind type parameters. If one operand, <x>, is not
of type bits, that operand is converted to a value of type bits and
kind type parameter COMPATIBLE_BITS_KIND(<x>), and the new value takes
the place of <x> as an operand.  If the resulting operands have
different kind type parameters, the operand with the smaller kind type
parameter is converted to a bits value with the kind type parameter of
the other operand before the operation is performed. The kind type
parameter of the result is that of the operand with the larger kind
type parameter. For a bits intrinsic operation where the
<intrinsic-operator> is the bits concatention opertor, the kind type
parameter of the result is the sum of the kind type parameters of the
operands.

.....................................................................
[121:17-20] In '7.1.2 Intrinsic operations' replace the first 
sentence of the 5th paragraph with:

A <<character intrinsic operation>>, <<relational intrinsic 
operation>>, and <<logical intrinsic operation>> are similarly
defined in terms of a <<character intrinsic opertor>> ( // in a 
context where the operands are of type character), relational
intrinsic operators (.EQ.,.NE.,.GT.,.GE.,.LT.,.LE.,==, /=, >, >=,
<, and <=), and logical intrinsic operators (.AND.,.OR.,.XOR.,.NOT.,
.EQV., and .NEQV. is a context where the operands are of type
logical), respectively.

.....................................................................
[121:23-25] In '7.1.2 Intrinsic operations' add a qualification to
the first sentence and append a new sentence, so that the resulting
paragraph is:

A <<numeric relational intrinsic operation>> is a relational 
intrinsic operation where both operands are of numeric type. A 
<<character relational intrinsic operation>> is a relational 
intrinsic operation where the operands are of type character. A
<<bits relational intrinsic operation>> is a relational intrinsic
operation where one or both of the operands is of type bits.

.....................................................................
[123:24+] In '7.1.4 Type, type parameters, and shape of an
expression', add a syntax term for a bits expression:

R728a   <bits-expr>           <<is>> <expr>

C709a (R728a) <bits-expr> shall be of type bits.

.....................................................................
[124:44+] In '7.1.4.2 Type, type parameters, and shape of the result
of an expression', add a new item in the list after item 5:

(5a) For an expression <x1> // <x2> where both operands are of type
bits, the kind type parameter of the result is the sum of the kind
type parameters of the operands.  For an expression <x1> <op> <x2>
where both operands are of type bits and <op> is not // or a
relational intrinsic operator, if the operands have the same type kind
parameters, the kind type parameter of the expression is the same as
that of each operand; otherwise the kind type parameter of the
expression is the larger of the kind type parameters of the operands.
For an expression <x1> <op> <x2> where <op> is not // or a relational
intrinsic operator, and one of the operands is of type bits and the
other operand is not of type bits, the kind type parameter of the
expression is the larger of the kind type of the operand of type bits
and COMPATIBLE_BITS_KIND(<x>) where <x> is the operand that is not of
type bits.

.....................................................................
[125:41] In the list of a specification inquiry in '7.1.6
Specification expression', replace item (4) with:

(4) the kind inquiry functions KIND and COMPATIBLE_BITS_KIND,

.....................................................................
[132:9+] Add a new subsection to '7.1.8 Evaluation of operations':

7.1.8.6a Evaluation of bits intrinsic operations

The rules given in 7.2.5 specify the interpretation of bits 
intrinsic operations. Once the interpretation of an expression has 
been established in accordance with those rules, the processor may
evaluate any other expression that is computationally equivalent,
provided that the integrity of parentheses in any expression is
not violated.

Note 7.23a
For example, for the variables B1, B2, and B3 of type logical, the
processor may choose to evaluate the expression

  B1 .xor. B2 .xor. B3

as

  B1 .xor. (B2 .xor. B3)

[end Note]

Two expressions of type bits are computationally equivalent if their
values are equal for all possible values of their primaries.

.....................................................................
[132:18] In the second sentence of '7.2 Interpretation of operations'
replace "character, relational, and logical" with "character, 
relational, logical, and bits".

.....................................................................
[135:22-] At the end of '7.2.3 Relational intrinsic operations', 
add two new paragraphs:

A bits relational intrinsic operation is interpreted as having the
logical value true if the values of the operands satisfy the relation
specified by the operator. A bits relational intrinsic operation is
interpreted as having the logical value false of the values of the
operands do not satisfy the relation specified by the operator.

For a bits relational intrinsic operation where the operands are both
of type bits and of the same kind type parameter, <x1> and <x2> are
equal if, at each bit position, their corresponding bits are the same,
or they both have kind type parameter value of zero; otherwise they
are unequal. If <x1> and <x2> are unequal, and the leftmost unequal
corresponding bit of <x1> is 1 and <x2> is 0 then <x1> is considered
to be greater than <x2>; otherwise <x1> is considered to be less than
<x2>.  If both <x1> and <x2> are of type bits but have unequal kind
type parameters, the operand with the smaller kind type parameter is
treated as if it were padded on the left with the number of 0 bits
required to make the number of bits in each operand the same. If one
of the operands is not of type bits, that operand, <x>, is converted
to type bits with a kind type parameter of COMPATIBLE_BITS_KIND(<x>)
before the operation is evaluated.

.....................................................................
[135:28+] In Table 7.5 in '7.2.4 Logical intrinsic operations' add 
a row following the entry for .NEQV. at the bottom of the page:

.XOR.  Logical nonquivalence     <x1> .XOR. <x2>  True if either <x1>
                                                  or <x2> is true,
                                                  but not both.

.....................................................................
[136:2-] After Table 7.6 in '7.2.4 Logical intrinsic operations'
add a new paragraph:

The values for the logical intrinsic operation <x1> .XOR. <x2> are
identical to those for <x1> .NEQV. <x2>.

.....................................................................
[136:2-] At the end of section '7.2 Interpretation of operations',
add a new subsection:

7.2.5 Bits intrinsic operations

Bit operations are used to express bitwise operations on sequences of
bits, or to concatenate such sequences. Evaluation of a bits opertion
produces a result of type bits. The permitted types of operands of the
bits intrinsic operations are specified in 7.1.2.

The bits operators and their interpretation when used to form an
expression are given in Table 7.6a, where <x1> denotes the operand of
type bits to the left of the operator and <x2> of type bits denotes
the operand to the right of the operator. If one of the operands of
is not of type bits, or they are of unequal kind type, they are
converted as described in 7.1.2 before the operation is performed.

   Table 7.6a Interpretaion of the bits intrinsic operators
---------------------------------------------------------------------
Operator  Representing    Use of operator  Interpretation
---------------------------------------------------------------------
  //      concatenation    <x1> // <x2>   concatenate <x1> with <x2>
.NOT.     bitwise not      .NOT. <x2>     bitwise not of <x2>
.AND.     bitwise and      <x1> .AND. <x2> bitwise and of <x1> and
                                                     <x2>
.OR.      bitwise or       <x1> .OR. <x2>  bitwise or of <x1> and
                                                     <x2>
.XOR.     bitwise          <x1> .XOR. <x2> bitwise exclusive or of
          exclusive or                       <x1> and <x2>
.NEQV.    bitwise          <x1> .NEQV. <x2> bitwise nonequivalence
          nonequivalence                    of <x1> and <x2>
.EQV.     bitwise          <x1> .EQV. <x2>  bitwise equivalence of
          equivalence                       <x1> and <x2>
--------------------------------------------------------------------

The result of the bits concatenation operator // is a bits value
whose kind type parameter is the sum of the kind type parameters
of the operands. The leftmost KIND(<x1>) bits of the result is the
value of <x1> and the righmost KIND(<x2>) bits of the result is
the value of <x2>. 

For the bits intrinsic operators other than //, the result value is
computed separately for each pair of bits at corresponding positions
in each operand.  The value of each bit operation, for bits denoted
<b1> and <b2> are given in Table 7.6b.

Table 7.6b The values of bitwise operations involving bits intrinsic
           operators
--------------------------------------------------------------------
<b1> <b2> .NOT.<b2> <b1>.AND.<b2> <b1>.OR.<b2> <b1>.XOR.<b2> 
 0    0      1            0             0            0
 0    1      0            0             1            1
 1    0      1            0             1            1
 1    1      0            1             1            0
--------------------------------------------------------------------

The values for the operation <b1> .NEQV. <b2> are the same as for
the operation <b1> .XOR. <b2>. The values for the operation
<b1> .EQV. <b2> are the same as for the operation
.NOT. (<b1> .XOR. <b2>).

.....................................................................
[136:5+] In 'Table 7.7 Categories of operations and relative
precedence', in the column labeled "Category of operation" replace
"Logical" with "Logical or Bits" four times. In the second to last
row of the same table, replace ".EQV. or .NEQV." with ".EQV., .NEQV., 
or .XOR.".

.....................................................................
[139:2] In 'Table 7.8 Type conformance for the intrinsic assignment
statement', modify the entries for integer, real, complex, and
logical, and add an entry for bits as follows:


Type of <variable>                   Type of <expr>

    integer                          integer, real, complex, bits
     real                            integer, real, complex, bits
    complex                          integer, real, complex, bits
     bits                      integer, real, complex, bits, logical 
    logical                          logical, bits

.....................................................................
[139:6-7] In the paragraph following Table 7.8, before the last
sentence, insert a new sentence:

A <<bits intrinsic assignment statement>> is an intrinsic 
assignment statement for which either <variable> or <expr> is of
type bits.

.....................................................................
[141:13+] In '7.4.1.3 Interpretation of intrinsic assignments' add
four new paragraphs and a Note:

For a bits intrinsic assignment statement where <variable> and <expr>
are both of type bits and have the same type kind parameter value, the
resulting value in <variable> is the same as that of <expr>. If
<variable> has a larger type kind parameter value than <expr>, the
lower KIND(<expr>) bits of the resulting value in <variable> are the
same as those of <expr> and the upper KIND(<variable>) - KIND(<expr>)
bits are 0. If the <variable> has a smaller type kind parameter value
that <expr>, the lower KIND(<variable>) bits of <expr> are the
resulting value in <variable>. Conversion of the bits value of a
variable, E, to a bits value with a different kind type parameter has
the effect of the bits intrinsic assignment V = E, where KIND(V) is
the kind type parameter of the converted value.

For a bits intrinsic assignment statement where the type of <expr> is
not bits, the value of <expr> is first converted to a bits value,
with a kind type parameter value of COMPATIBLE_BITS_KIND(X) where
X is a variable with the same type and type kind parameter as <expr>.
The bit sequence of the resulting bits value is the same as that of
the internal representation of <expr>. 

For a bits intrinsic assignment statement where the type of <variable>
is not bits, the value of <expr> is first converted to a bits value
with a kind type parameter value of COMPATIBLE_BITS_KIND(X) where X is
a variable with the same type and kind type parameter as
<variable>. Following the assignment, the internal representation of
<variable> has the same sequence of bits as the converted value of
<expr>.

If the <variable> in a bits intrinsic assignment is not of type
bits, the seqeunce of bits in <expr>, after conversion to the kind
compatible with <variable>, shall represent a valid value for the
type and type kind parameters of <variable>.

Note 7.38a: Bits assignment is not always the same as the result of
the TRANSFER intrinsic. The TRANSFER operation is based on the memory
image of the data, while bits assignment is based on the data values.
For example, if S is a 32-bit integer array of size 8, and R is a
64-bit bits array of size 8, R = TRANSFER(S,R) will result in the
values of S packed into the first 4 elements of R.  The way in which
this packing is done will be different on little endian and big endian
machines.  The bits assignment, R = S, will result in all 8 elements
of R being defined, where R(i) contains the bits from S(i) in the
right 32 bits, and 0 in the left 32 bits.  Bits assignment does not
depend on which endian the processor's memory system uses.  
[end Note]

.....................................................................
[143:14] In C716 in section '7.4.2 Pointer assignment' replace the
last phrase "and the corresponding kind type parameters shall be
equal" to "and the corresponding kind type parameters shall be
equal, or <data-target> and <data-pointer-target> shall be bits
type compatible (5.1.1.2).
 
.....................................................................
[144:21] In '7.4.2.1 Data pointer assignment' replace the end of the
first sentence of the 4th paragraph "as the corresponding type
parameters of <data-target." with "as the corresponding type
parameters of <data-target>, or <data-pointer-object> and 
<data-target> shall be bits type compatible (5.1.1.2)."

.....................................................................
[233:19-] After note 10.17 in section '10.6.3 Character editing'
add a new section:

10.6.3a Bits editing

The I<w>, I<w.m>, B<w>, B<w.m>, O<w>, O<w.m>, Z<w>, and Z<w.m> edit
descriptors indicate that the field to be edited occupies <w> 
positions, except when <w> is zero. When <w> is zero, the processor
selects the field width. On input, <w> shall not be zero. The
specified input/output list item shall be of type bits. The G edit
descriptor also may be used to edit bits data (10.6.4.4).

On input, m has no effect.

In the input field for the I edit descriptor, the character string
shall be an <int-literal-constant> (R406), except for the 
intrepretation of blanks. For the B, O, and Z edit descriptors, the
character string shall consist of binary, octal, or hexadecimal
digits (as in R412, R413, R414) in the respective input field. The
lower-case hexadecimal digits a through f in a hexadecimal input
field are equivalent to the corresponding upper-case hexadecimal
digits.

The output field for the I<w> edit descriptor consists of zero or
more leading blanks, followed by an optional plus sign, followed
by the internal value, as interpreted as a non-negative integer, 
as a <digit-string> without leading zeros. The interpretation of
a bits value as a non-negative integer is described in 13.3.

Note 10.17a
The <digit-string> always consists of at least one digit.
[end Note]

The output field for the B<w>, O<w>, and Z<w> descriptors consists
of zero or more leading blanks followed by the internal value in
a form identical to the digits of a binary, octasl, or hexadecimal
constant, respectively, with the same value and without leading
zeros.

Note 10.17b
A binary, octal, or hexadecimal constant always consists of at 
least one digit.
[end Note]

The output field for the I<w.m>, B<w.m>, O<w.m>, and Z<w.m> edit
descriptor is the same as for the I<w>, B<w>, O<w>, and Z<w> edit
descriptor, except that the <digit-string> consists of at least
<m> digits. If necessary, sufficient leading zeros are included to
achieve the minimum of <m> digits. The value of <m> shall not
exceed the value of <w>, except when <w> is zero. If <m> is zero
and the internal value consists of all zero bits, the output field
consists of only blank characters. When <m> and <w> are both zero,
and the internal value consists of all zero bits, one blank
character is produced.

.....................................................................
[234:18+] After subsection 10.6.4.3, add a new subsection:

10.6.4.4 Generalized bits editing

When used to specify the input/output of bits data, the G<w.d> and
G<w.d>E<e> edit descriptors follow the rules for the Zw edit
descriptor (10.6.1.1), except that <w> shall not be zero.

.....................................................................
[237:42-43] Replace the first sentence of the third paragraph of
'10.7.6 BN annd BZ editing' with:

The blank interpretation mode affects only numeric editing (10.6.1),
bits editing (10.6.3a), generalized numeric editing (10.6.4.1), and
generalized bits editing (10.6.4.4) on input.

.....................................................................
[240:20+] At the end of '10.9.1 List-directed input' add a new
paragraph:

When the effective item is of type bits, the value on the input
record is interpreted as if a Z<w> edit descriptor with a
suitable value of <w> were used.

.....................................................................
[242:24+] At the end of '10.9.2 List-directed output' add a new
paragraph:

Bits output constants are produced with the effect of a Z<w> edit
descriptor.  A reasonable processor-dependent value of <w> is
used for each of the bits constants output.

.....................................................................
[243:36] In the first sentence of '10.10.1.2' Namelist input values'
replace "list items of types logical, integer, and character" with
"list items of types logical, integer, character, and bits".

.....................................................................
[245:10+] At the end of '10.10.1.3 Namelist group object list items'
add a new paragraph:

When the next effective list item is of type bits, the value in the
input record is interpreted as if a Z<w> edit descriptor with a
suitable value of <w> were used.

.....................................................................
[247:22+] At the end of '10.10.2.1 Namelist output editing" add a
new paragraph:

Bits output constants are produced with the effect of a Z<w> edit
descriptor.  A reasonable processor-dependent value of <w> is
used for each of the bits constants output.

.....................................................................
[268:21] In the first sentence of '12.4.1.2 Actual arguments 
associated with dummy data objects', replace "it shall be type
compatible (5.1.1.2) with" with "it shall be type compatible or
bits type compatible (5.1.1.2) with".

.....................................................................
[269:1] Replace the beginning of the first sentence of the second
paragraph of '12.4.1.2 Actual arguments associated with dummy
data objects' "The type parameter values" with "Unless the actual
argument and the corresponding dummy argument are bits type
compatible, the type parameter values"

.....................................................................
[269:15-16] Replace the ends of each of the first two sentences in
this paragraph "and ranks shall agree" with "and ranks shall agree,
or the actual argument and the dummy argument shall be bits type
compatible and their ranks shall agree"

.....................................................................
[292:20-24] Replace the first paragraph of '13.3 Bit model' with:

The bit manipulation procedures are 23 elemental functions and one
elemental subroutine. Logical operations on bits are provided by
the elemental functions IOR, IAND, NOT, IEOR, and MERGE_BITS, and
the transformational functions IALL, IANY, and IPARITY; shift
operations are provided by the elemental functions ISHFT, ISHFTC,
SHIFTA, SHIFTL, SHIFTR, DSHIFTL, and DSHIFTR; bit subfields may be
referenced by the elemental function IBITS and by the elemental
subroutine MVBITS; single-bit processing is provided by the 
elemental functions BTEST, IBSET, and IBCLR; characterization of
bit sequences are provided by the elemental functions POPCNT, POPPAR, 
LEADZ, and TRAILZ.

.....................................................................
[292:25] In the first sentence of the second paragraph of '13.3 Bit
model' replace "a bit is defined to be" with:

a bit in the bit model for an integer is defined to be

.....................................................................
[292:28+] Add a new paragraph following the second paragraph of
'13.3 Bit model':

Using the notation of the formula above, the value of a bits object 
of kind <z-1> is represented as the ordered sequence of bits with
<w_k> the bit at position <k>.  The rightmost bit is <w_0> and the 
leftmost bit is <w_{z-1}>. Such a bits object may be interpreted as a
nonnegative integer with the value <j>.

.....................................................................
[295:29-] In the list of '13.5.4 Kind functions' add a new entry:

COMPATIBLE_BITS_KIND(X)   Bits kind type parameter compatible with
                          the argument

.....................................................................
[295:29+] In the list of '13.5.4 Kind functions' add a new entry:

SELECTED_BITS_KIND(N)     Bits kind type parameter, given number
                          of bits

.....................................................................
[295:36-] In the list of '13.5.5 Miscellaneous type conversion
functions' add a new entry:

BITS(A [,KIND])           Conversion to type bits

.....................................................................
[296:20-31] In the list of '13.5.9 Bit manipulation procedures', add
the following at the correct alphabetical locations:

DSHIFTL (I, J, SHIFT)     Double left shift

DSHIFTR (I, J, SHIFT)     Double right shift

MERGE_BITS (I, J, MASK)   Merge bits under mask

SHIFTA (I, SHIFT)         Arithmetic right shift

SHIFTL (I, SHIFT)         Left shift

SHIFTR (I, SHIFT)         Right shift

.....................................................................
[296:31+] After '13.5.9 Bit manipulation procedures', add a two new
subsections:

13.5.9a Bit reduction functions

LEADZ (I [,KIND])         Number of leading zero bits
 
POPCNT (I [,KIND])        Number of one bits

POPPAR (I [,KIND])        Parity of one bits

TRAILZ (I [,KIND])        Number of trailing zero bits


13.5.9b Bit construction functions

MASKL (I [,KIND])         Left justified bit mask

MASKR (I [,KIND])         Right justified bit mask

.....................................................................
[297:4-11] In the list of '13.5.12 Array reduction functions', add
the following at the correct alphabetical locations:

IALL (ARRAY, DIM [,MASK]) or       Bitwise AND of array elements
    IALL (ARRAY [,MASK])

IANY (ARRAY, DIM [,MASK]) or       Bitwise OR of array elements
    IANY (ARRAY [,MASK])

IPARITY (ARRAY, DIM, [,MASK]) or   Bitwise exclusive OR of elements
    IPARITY (ARRAY [,MASK])

PARITY (MASK [,DIM])               True if an odd number of values 
                                   is true

.....................................................................
Modify the description of the ACHAR function (13.7.2):
 
[300:29] Change the description of the argument I to:

"shall be of type integer or bits. If I is of type bits, it is 
interpreted as a non-negative integer as described in 13.3.

[301:6] Append to the current Example text:

ACHAR(z'41') has the value 'A'. 


.....................................................................
[306:13+] Add a new intrinsic function, BITS:

13.7.15a  BITS (A [, KIND])

<<Description.>>  Convert to bits type.

<<Class.>> Elemental function.

<<Arguments.>>

A    shall be of type integer, real, complex, logical, or bits.

KIND shall be a scalar initialization expression.

<<Result Characteristics.>>  Bits. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default bits type.

<<Result Value.>> The result value is that with which R becomes
defined as a result of the intrinisc assignment R = A, for a bits
variable R with the kind type parameter specified.
  
<<Examples.>> BITS(z"abcd",32) has the value z"0000abcd". BITS(-1)
has the value z"ffffffff" for an implementation where the default
integer representation is 32-bit two's-complement.  BITS(.true.,5)
has the value b"00001" for an implementation that represents the 
logical value true by setting the low order bit of the internal value
and clearing the other bits.  BITS(Inf) has the value z"7f800000" if
the value of Inf is an IEEE 32-bit real Infinity and the default
bits kind is 32.

.....................................................................
[306:14-21] Replace the definition of BIT_SIZE (13.7.16):

13.7.16 BIT_SIZE(I)

<<Description.>> Returns the number of bits.

<<Class.>> Inquiry function.

<<Arguments.>> I shall be of type integer or bits. It may be a scalar
or an array.

<<Result Characteristics.>> If I is of type integer the result has 
is a scalar integer with the same kind type parameter as I. If I is of 
type bits, the result is of type default integer.

<<Result Value.>> If I is of type integer, the result has the value
of the number of bits <z> of the model integer defined for bit
manipulation contexts in 13.3.  If I is of type bits, the result
value is KIND(I).
  
<<Example.>> BIT_SIZE(1) has the value 32 if <z> of the model is 32.
BIT_SIZE(z"ffff") has the value 16.

.....................................................................
Modify the definition of BTEST (13.7.17)

[306:26] Change the description of the I argument to: "shall be of
type integer or bits."

[307:1+] Append to the current Example text:

BTEST(b"01000",3) has the value true.

.....................................................................
Modify the definition of CHAR (13.7.19)

[307:17] Change the description of the argument I to:

shall be of type integer or bits. If I is of type bits, it is 
interpreted as a non-negative integer as described in 13.3. The
value of I shall be in the range 0 <= I <= <n>-1, where <n> is
the number of characters in the collating sequence associated 
with the specified kind type parameter.

[307:26] Append to the current Example text:

CHAR(z'41') has the value 'A' on a processor using the ASCII
collating sequence. 

.....................................................................
Modify the definition of CMPLX (13.7.20)

[307:31] In the descrption of the X argument, replace "or complex, or
a <boz-literal-constant> with "complex, or bits".

[308:1] On the description of the Y argument, replace "integer or
real, or a <boz-literal-constant>" with "integer, real, or bits".

.....................................................................
[308:20+] Add a new intrinsic function, COMPATIBLE_BITS_KIND:

13.7.21a COMPATIBLE_BITS_KIND (X)

<<Description.>> Return bits compatible kind

<<Class.>> Inquiry function.

<<Arguments.>> Shall be of type bits, integer, real, complex, or
logical.

<<Result Characteristics.>> Default integer scalar.

<<Result Value.>> If X is of type bits, the result value is
KIND(X). If X is of type default integer, default real, or default
logical, the result value is NUMERIC_STORAGE_SIZE (13.8.2.7). If
X is of type double precision or default complex, the result is
2*NUMERIC_STORAGE_SIZE. If X is of type complex with the same 
kind type parameter as that of double precision, the result value
is 4*NUMERIC_STORAGE_SIZE.  If X is of type non-default integer,
the result value is BIT_SIZE(X). If X is of a non-default logical
or non-default non-integer numeric type, the result value is the
number of bits of storage used by the processor to represent
scalar objects of that type and kind.
  
<<Example.>> The value of COMPATIBLE_BITS_KIND(0) is 32 if the value
of NUMERIC_STORAGE_SIZE is 32.

.....................................................................
Modify the definition of CO_MAXLOC (13.7.25d) in feature UK-001.
***Note to editor: This edit is a modification of the edits for 
[309:32+] in the paper for co-arrays, UK-001.

[309:32+] In the description of the ARRAY argument for the CO_MAXLOC
function, replace "of type integer, real, or character" with
"of type integer, real, bits, or character".

.....................................................................
Modify the definition of CO_MAXVAL (13.7.25e) in feature UK-001.
***Note to editor: This edit is a modification of the edits for 
[309:32+] in the paper for co-arrays, UK-001.

[309:32+] In the description of the ARRAY argument for the CO_MAXVAL
function, replace "of type integer, real, or character" with
"of type integer, real, bits, or character".

.....................................................................
Modify the definition of CO_MINLOC (13.7.25f) in feature UK-001.
***Note to editor: This edit is a modification of the edits for 
[309:32+] in the paper for co-arrays, UK-001.

[309:32+] In the description of the ARRAY argument for the CO_MINLOC
function, replace "of type integer, real, or character" with
"of type integer, real, bits, or character".

.....................................................................
Modify the definition of CO_MINVAL (13.7.25g) in feature UK-001.
***Note to editor: This edit is a modification of the edits for 
[309:32+] in the paper for co-arrays, UK-001.

[309:32+] In the description of the ARRAY argument for the CO_MINVAL
function, replace "of type integer, real, or character" with
"of type integer, real, bits, or character".

.....................................................................
Modify the definition of DBLE (13.7.29)

[312:21] In the description of the argument A, replace "or complex
or a <boz-literal-constant>" with "complex, or bits".

.....................................................................
[314:11+] Add two new intrinsic functions, DSHIFTL and DSHIFTR:

13.7.33a DSHIFTL (I, J, SHIFT)

<<Description.>>  Performs a double left shift.

<<Class.>> Elemental function.

<<Arguments.>>

I         shall be of type integer or bits.

J         shall be of same type and kind as I.

SHIFT     shall be of type integer in the range 0 through
          BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result has the value 
IOR(SHIFTL(I,SHIFT), SHIFTR(J, BIT_SIZE(J)-SHIFT)). This is equivalent
to concatenating I and J, shifting the combined value left SHIFT bits,
and returning the left half of the result.  If SHIFT is zero, the
result is I. If I and J are the same, the result value is the same
as a left circular shift of I.  The model for the interpretation of
an integer value as a sequence of bits is in 13.3.
  
<<Example.>> DSHIFTL(z"01234567", z"89abcdef", 8) has the value
z"23456789".

13.7.33b DSHIFTR (I, J, SHIFT)

<<Description.>> Performs a double right shift.

<<Class.>> Elemental function.

<<Arguments.>>

I         shall be of type integer or bits.

J         shall be of same type and kind as I.

SHIFT     shall be of type integer in the range 0 through
          BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result has the value
IOR(SHIFTL(I, BIT_SIZE(I)-SHIFT), SHIFTR(J, SHIFT)). This is equivalent
to concatenating I and J, shifting the combined value right SHIFT bits,
and returning the right half of the result. If SHIFT is zero, the
result is J. If I and J are the same, the result value is the same
as a right circular shift of J. The model for the interpretation of
an integer value as a sequence of bits is in 13.3.
  
<<Example.>> DSHIFTR(z"01234567", z"89abcdef", 8) has the result
z"6789abcd".

.....................................................................
Modify the definition of HUGE (13.7.44)

[319:11-12] In the Description, replace "number" with "value" and
"numbers" with "values".

[319:14] In the Argument, replace "of type integer or real" with
"of type integer, real, or bits".

[319:18] Add a new sentence at the end of the Result Value: "If X
is of type bits, the result value has all of its bits set to 1."

.....................................................................
[320:14+] Add a new intrinsic function, IALL:

13.7.45a IALL (ARRAY ,DIM [, MASK]) or
         IALL (ARRAY, [MASK] )

<<Description.>> Performs a bitwise AND reduction.

<<Class.>> Transformational function.

<<Arguments.>>

ARRAY           shall be of type integer or bits. It shall not 
                be scalar.

DIM (optional)  shall be a scalar and of type integer with a value
                in the range 1 <= DIM <= <n> where <n> is the rank
                of ARRAY. The corresponding actual argument shall 
                not be an optional dummy argument.

MASK (optional) shall be of type logical and shall be conformable
                with ARRAY.

<<Result Characteristics.>> The result is of the same type and kind 
type parameter as ARRAY. It is scalar if DIM is absent or
if ARRAY has rank one; otherwise, the result is an array of rank
<n> - 1 and shape (<d_1, d_2, ..., d_{DIM-1},d_{DIM+1}, ..., d_n>)
where (<d_1, d_2, ..., d_n>) is the shape of ARRAY.

<<Result Value.>>

The value of IALL_size_zero_value is HUGE(ARRAY) if ARRAY is of type
bits, and is an implementation dependent integer value <x> with the
property that IAND(I,<x>) = I for all integers of the same kind
parameter as ARRAY if ARRAY is of type integer.

<Case (i)>:   The result of IALL(ARRAY) is the IAND reduction of
              all the elements of ARRAY. If ARRAY has size zero the
	      result value is IALL_size_zero_value.

<Case (ii)>:  The result if IALL(ARRAY, MASK=MASK) is the IAND
              reduction of all the elements of ARRAY corresponding
	      to true elememts of MASK; if MASK contains no true
	      elements the result value is IALL_size_zero_value.

<Case (iii)>: If ARRAY has rank one, IALL(ARRAY, DIM [,MASK] has 
	      the value IALL(ARRAY [,MASK]). Otherwise, the value of
      element (<s_1, s_2, ..., s_{DIM-1}, s_{DIM+1}, ..., s_n>)
      of IALL(ARRAY, DIM [,MASK])  is equal to 
      IALL(ARRAY(<s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>)
      [,MASK = MASK(s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>])

<<Examples.>> 

      IALL( [b"1110", b"1101", b"1011"] ) has the value b"1000".

      IALL( [b"1110", b"1101", b"1011"], MASK=[.true.,.false.,.true])
      has the value b"1010".

.....................................................................
Modify the description of the IAND function (13.7.46):

[320:18-21] Replace the Arguments and Result Characteristics section
with:

<<Arguments.>>

I    shall be of type integer or bits.

J    shall be of type integer or bits. If I and J have the same
     type they shall have the same type kind parameter value. If
     I and J have different types, BIT_SIZE(J) shall be
     equal to BIT_SIZE(I).

<<Result Characteristics.>>  If I and J have the same type, the
result characteristics are those of I. Otherwise, the result
characteristics are those of the argument with integer type.

[320:25] Replace "Example" with "Examples" and append:

IAND(z"12345678", z"0000ffff") has the value z"00005678".

.....................................................................
[320:25+] Add a new intrinsic function, IANY:

13.7.46a IANY (ARRAY ,DIM [, MASK]) or
         IANY (ARRAY, [MASK] )

<<Description.>> Performs a bitwise OR reduction.

<<Class.>> Transformational function.

<<Arguments.>>

ARRAY           shall be of type integer or bits. It shall not 
                be scalar.

DIM (optional)  shall be a scalar and of type integer with a value
                in the range 1 <= DIM <= <n> where <n> is the rank
                of ARRAY. The corresponding actual argument shall 
                not be an optional dummy argument.

MASK (optional) shall be of type logical and shall be conformable
                with ARRAY.

<<Result Characteristics.>> The result is of the same type and kind 
type parameter as ARRAY. It is scalar if DIM is absent or
if ARRAY has rank one; otherwise, the result is an array of rank
<n> - 1 and shape (<d_1, d_2, ..., d_{DIM-1},d_{DIM+1}, ..., d_n>)
where (<d_1, d_2, ..., d_n>) is the shape of ARRAY.

<<Result Value.>>

The value of IANY_size_zero_value is BITS(b'0',kind=KIND(ARRAY)) if
ARRAY is of type bits, and zero if ARRAY is of type integer.

<Case (i)>:   The result of IANY(ARRAY) is the IOR reduction of
              all the elements of ARRAY. If ARRAY has size zero the
	      result value is IANY_size_zero_value.

<Case (ii)>:  The result if IANY(ARRAY, MASK=MASK) is the IOR
              reduction of all the elements of ARRAY corresponding
	      to true elememts of MASK; if MASK contains no true
	      elements the result value is IANY_size_zero_value.

<Case (iii)>: If ARRAY has rank one, IANY(ARRAY, DIM [,MASK] has 
	      the value IANY(ARRAY [,MASK]). Otherwise, the value of
      element (<s_1, s_2, ..., s_{DIM-1}, s_{DIM+1}, ..., s_n>)
      of IANY(ARRAY, DIM [,MASK])  is equal to 
      IANY(ARRAY(<s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>)
      [,MASK = MASK(s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>])

<<Examples.>> 

      IANY( [b"1110", b"1101", b"1000"] ) has the value b"1111".

      IALL( [b"1110", b"1101", b"1000"], MASK=[.true.,.false.,.true])
      has the value b"1110".


.....................................................................
Modify the description of IBCLR (13.7.47):

[320:30] Replace the description of the argument I with "shall be
of type integer or bits".

[321:6] Append to the current Examples text:

IBCLR(b"11111",3) has the value b"10111".

.....................................................................
Modify the description of IBITS (13.7.48):

[321:11] Replace the description of the argument I with "shall be
of type integer or bits".

[321:18] Append to the current Examples text:

IBITS(z"abcd",4,8) has the value z"00bc".

.....................................................................
Modify the description of IBSET (13.7.49):

[321:23] Replace the description of the argument I with "shall be
of type integer or bits".

[321:29] Append to the current Examples text:

IBSET(b"00000",3) has the value b"01000".

.....................................................................
Modify the description of the IEOR function (13.7.51):

[322:16-19] Replace the Arguments and Result Characteristics sections
with:

<<Arguments.>>

I    shall be of type integer or bits.

J    shall be of type integer or bits. If I and J have the same
     type they shall have the same type kind parameter value. If
     I and J have different types, BIT_SIZE(J) shall be
     equal to BIT_SIZE(I).

<<Result Characteristics.>>  If I and J have the same type, the
result characteristics are those of I. Otherwise, the result
characteristics are those of the argument with integer type.

[322:23] Replace "Example" with "Examples" and append:

IEOR(z"12340000", z"1234ffff") has the value z"0000ffff".

.....................................................................
Modify the definition of INT (13.7.53)

[323:21] In the description of the A argument, replace "or complex,
or a <boz-literal-constant>." with "complex, or bits."

[323:31-33] Replace Result Value Case (iv) with:

If A is of type bits, the result value is that with which I becomes
defined as a result of the intrinsic assignment I = A, for an integer 
variable I with the kind type parameter specified.

.....................................................................
Modify the description of the IOR function (13.7.54):

[323:38-324:3] Replace the Arguments and Result Characteristics 
sections with:

<<Arguments.>>

I    shall be of type integer or bits.

J    shall be of type integer or bits. If I and J have the same
     type they shall have the same type kind parameter value. If
     I and J have different types, BIT_SIZE(J) shall be
     equal to BIT_SIZE(I).

<<Result Characteristics.>>  If I and J have the same type, the
result characteristics are those of I. Otherwise, the result
characteristics are those of the argument with integer type.

[324:7] Replace "Example" with "Examples" and append:

IAND(z"12345678", z"0000ffff") has the value z"1234ffff".

.....................................................................
[324:7+] Add a new intrinsic function, IPARITY:

13.7.54a IPARITY (ARRAY ,DIM [, MASK]) or
         IPARITY (ARRAY, [MASK] )

<<Description.>> Performs a bitwise exclusive OR reduction.

<<Class.>> Transformational function.

<<Arguments.>>

ARRAY           shall be of type integer or bits. It shall not 
                be scalar.

DIM (optional)  shall be a scalar and of type integer with a value
                in the range 1 <= DIM <= <n> where <n> is the rank
                of ARRAY. The corresponding actual argument shall 
                not be an optional dummy argument.

MASK (optional) shall be of type logical and shall be conformable
                with ARRAY.

<<Result Characteristics.>> The result is of the same type and kind 
type parameter as ARRAY. It is scalar if DIM is absent or
if ARRAY has rank one; otherwise, the result is an array of rank
<n> - 1 and shape (<d_1, d_2, ..., d_{DIM-1},d_{DIM+1}, ..., d_n>)
where (<d_1, d_2, ..., d_n>) is the shape of ARRAY.

<<Result Value.>>

The value of IPARITY_size_zero_value is BITS(b'0',kind=KIND(ARRAY)) if
ARRAY is of type bits, and zero if ARRAY is of type integer.

<Case (i)>:   The result of IPARITY(ARRAY) is the IEOR reduction of
              all the elements of ARRAY. If ARRAY has size zero the
	      result value is IPARITY_size_zero_value.

<Case (ii)>:  The result if IPARITY(ARRAY, MASK=MASK) is the IEOR
              reduction of all the elements of ARRAY corresponding
	      to true elememts of MASK; if MASK contains no true
	      elements the result value is IPARITY_size_zero_value.

<Case (iii)>: If ARRAY has rank one, IPARITY(ARRAY, DIM [,MASK] has 
	      the value IPARITY(ARRAY [,MASK]). Otherwise, the value
      of element (<s_1, s_2, ..., s_{DIM-1}, s_{DIM+1}, ..., s_n>)
      of IPARITY(ARRAY, DIM [,MASK])  is equal to 
      IPARITY(ARRAY(<s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>)
      [,MASK = MASK(s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>])

<<Examples.>> 

      IPARITY( [b"1110", b"1101", b"1000"] ) has the value b"1011".

      IPARITY( [b"1110", b"1101", b"1000"], 
      MASK=[.true.,.false.,.true]) has the value b"0110".

.....................................................................
Modify the definition of ISHFT (13.7.55)

[324:12] Replace the description of the I argument with "shall be
of type integer or bits."

[324:20] Append to the current example text:

ISHFT (b"00000011",1) has the value b"00000110".

.....................................................................
Modify the definition of ISHFTC (13.7.56)

[324:25] Replace the description of the I argument with "shall be
of type integer or bits."

[325:7] Append to the current example text:

ISHFTC (z"abcd",4,8) has the value z"abdc".

.....................................................................
[326:16+] Add a new intrinsic function, LEADZ:

13.7.60a LEADZ (I [,KIND])

<<Description.>> Count the number of leading zero bits.

<<Class.>> Elemental function.

<<Arguments.>>

I                  shall be of type integer or bits.

KIND (optional)    shall be a scalar initialization expression.

<<Result Characteristics.>>  Integer. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default integer type.

<<Result Value.>> If all of the bits of I are zero, the result value
is BIT_SIZE(I). Otherwise, the result value is BITSIZE(I)-1 minus
the position of the leftmost 1 bit in I, where the rightmost bit 
position is 0.
The model for the interpretation of an integer value as a sequence
of bits is in 13.3.
  
<<Example.>> LEADZ(b"001101000") has the value 2.

.....................................................................
Modify the definition of LOGICAL (13.7.69)

[329:23] Replace the Description text with:

Converts between kinds of logical or from bits to logical.

[329:26] In the description of the L argument, replace "of type
logical" with "of type logical or bits".

[346:16] Replace the  Result Value text with:

If L is of type logical, the result value is that of L. If L is of 
type bits, the result value is that with which R becomes
defined as a result of the intrinsic assignment R = L, for a logical 
variable R with the kind type parameter specified.

.....................................................................
[330:1+] Add two new intrinsic functions, MASKL and MASKR:

13.7.69a MASKL (I, [,KIND])

<<Description.>> Generate a left justified mask.

<<Class.>> Transformational function.

<<Arguments.>> 

I               shall be of type integer and in the range
                0 <= I <= M where M has the value of the kind type
                parameter of the result.

KIND (optional) shall be a scalar integer initialization expression.

<<Result Characteristics.>>  Bits. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default bits type.

<<Result Value.>> The result value has its leftmost I bits set to 1
                  and the remaining bits set to 0.
  
<<Example.>> MASKL(12) has the value z"fff00000" if the default
bits kind type parameter value is 32. 


13.7.69b MASKR (I, [,KIND])

<<Description.>> Generate a right justified mask.

<<Class.>> Transformational function.

<<Arguments.>> 


I               shall be of type integer and in the range
                0 <= I <= M where M has the value of the kind type
                parameter of the result.

KIND (optional) shall be a scalar integer initialization expression.

<<Result Characteristics.>>  Bits. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default bits type.

<<Result Value.>> The result value has its rightmost I bits set to 1
                  and the remaining bits set to 0.
  
<<Example.>> MASKR(12) has the value z"00000fff" if the default
bits kind type parameter value is 32. 

.....................................................................
Modify the definition of MAX (13.7.71)

[331:6] In the description of the Arguments, replace "integer, real,
or" with "integer, real, bits, or"

[331:17+] Append to the end of the current Examples text:

MAX(b"10000",b"01111") has the value b"10000".

.....................................................................
Modify the definition of MAXLOC (13.7.73)

[331:32] In the description of the ARRAY Argument, replace "integer, 
real, or" with "integer, real, bits, or"

.....................................................................
Modify the definition of MAXVAL (13.7.74)

[333:2] In the description of the ARRAY Argument, replace "integer, 
real, or" with "integer, real, bits, or"

.....................................................................
[334:7+] Add a new intrinsic function, MERGE_BITS:

13.7.75a MERGE_BITS (I, J, MASK)

<<Description.>> Merge bits under mask.

<<Class.>> Elemental function.

<<Arguments.>>

I       shall be of type bits or integer.

J       shall have the same type and type parameters as I.

MASK    shall be of type bits. If I is of type bits, MASK shall have
        the same kind type parameter value as I. If I is of type
	integer, KIND(MASK) shall be equal to BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result value is IOR(IAND(I,MASK),
                  IAND(J,NOT(MASK))).  
  
<<Example.>> MERGE_BITS(z"01234567",z"89abcdef",z"ffff0000") has
             the value z"0123cdef".

.....................................................................
Modify the definition of MIN (13.7.76)

[334:11] In the description of the Arguments, replace "integer, real,
or" with "integer, real, bits, or"

[331:17+] Append to the end of the current Examples text:

MIN(b"10000",b"01111") has the value b"01111".

.....................................................................
Modify the definition of MINLOC (13.7.78)

[335:3] In the description of the ARRAY Argument, replace "integer, 
real, or" with "integer, real, bits, or"

.....................................................................
Modify the definition of MINVAL (13.7.79)

[336:9] In the description of the ARRAY Argument, replace "integer, 
real, or" with "integer, real, bits, or"

.....................................................................
Modify the definition of MVBITS (13.7.83)

[338:26] In the description of the FROM argument, replace "shall be
of type integer." with "shall be of type integer or bits."

[339:1] In the first 2 lines of the description of the TO argument,
replace "shall be a variable of type integer with the same kind type
parameter value as FROM" with "shall be a variable with the same type 
and type kind parameter value as FROM"

[339:4] Append to the end of the current example text:

If TO has the initial value b"000000111111", the value of TO after
the statement CALL MVBITS(b"000000000011", 0, 2, TO, 8) is
b"001100111111".

.....................................................................
Modify the definition of NOT (13.7.87):

[340:20] Replace the Argument description with:

I shall be of type integer or bits.

[340:22] Replace "The result is" at the beginning of the Result
Value description with:

If I is of type integer, the result is

[340:24] After the last sentence of the Result Value description, 
add a new sentence:

If I is of type bits, the result is (.not. I).

[340:26] At the end of the Example text, add a new sentence:

NOT(z"ffff0000") has the value z"0000ffff".

.....................................................................
[342:16+] Add three new intrinsic functions, PARITY, POPCNT, and
POPPAR:

13.7.89a PARITY (MASK [,DIM])

<<Description.>> Determine whether an odd number of values are true
in MASK along dimension DIM.

<<Class.>> Transformational function.

<<Arguments.>>

MASK            shall be of type logical. It shall not be a scalar.

DIM (optional)  shall be a scalar and of type integer with a value
                in the range 1 <= DIM <= <n> where <n> is the rank
                of MASK. The corresponding actual argument shall 
                not be an optional dummy argument.

<<Result Characteristics.>> The result is of type logical with the
same kind type parameter as MASK. It is scalar if DIM is absent or
if MASK has rank one; otherwise, the result is an array of rank
<n> - 1 and shape (<d_1, d_2, ..., d_{DIM-1},d_{DIM+1}, ..., d_n>)
where (<d_1, d_2, ..., d_n>) is the shape of MASK.

<<Result Value.>>
  
<Case (i)>:   The result of PARITY(MASK) is the .NEQV. reduction of
              all the elements of MASK. If MASK has size zero, the 
              result has the value false. 

<Case (ii)>:  If MASK has rank one, PARITY(MASK,DIM) has a value
              equal to that of PARITY(MASK). Otherwise, the value of
              element (<s_1, s_2, ..., s_{DIM-1}, s_{DIM+1}, ..., s_n>)
              of PARITY(MASK,DIM) is equal to 
         PARITY(MASK(<s_1, s_2, ..., s_{DIM-1},:, s_{DIM+1}, ..., s_n>))

<<Examples.>> 

<Case (i)>:   The value of PARITY([T,T,T,F]) is true if T has the value
              true and F has the value false.

                                | T T F |
<Case (ii)>:  If B is the array | T T T |, where T has the value true
              and F has the value false, the PARITY(B,DIM=1) is
              [F F T] and PARITY(B, DIM=2) is [F T].



13.7.89b POPCNT (I [,KIND])

<<Description.>> Return the number of one bits.

<<Class.>> Elemental function.

<<Arguments.>>

I                  shall be of type integer or bits.

KIND (optional)    shall be a scalar initialization expression.

<<Result Characteristics.>>  Integer. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default integer type.

<<Result Value.>>  If I is of type integer, the result value is 
the number of one bits in the sequence of bits of I. The model for 
the interpretation of an integer value as a seqeunce  of bits is 
in 13.3. If I is of type bits, the result value is the number of 
one bits in I.
  
<<Examples.>> POPCNT([1,2,3,4,5,6]) has the value [1,1,2,1,2,2].
POPCNT(z"ffff0000") has the value 16. If B is of type bits,
POPCNT(HUGE(B)) has the same value as KIND(B).


13.7.89c POPPAR (I [,KIND])

<<Description.>> Return the bit-wise parity.

<<Class.>> Elemental function.

<<Arguments.>> 

I                  shall be of type integer or bits.

KIND (optional)    shall be a scalar initialization expression.

<<Result Characteristics.>>  Integer. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default integer type.

<<Result Value.>> POPPAR(I) has the value 1 if POPCNT(I) is odd,
and 0 of POPCNT(I) is even.
  
<<Examples.>> POPPAR([1,2,3,4,5,6]) has the value [1,1,0,1,0,0].
POPPAR(z"ffff0000") has the value 0. 

.....................................................................
Modify the definition of RANDOM_NUMBER (13.7.94) as:

[344:8-9] Replace the Desciption text with:

Returns one pseudorandom value or an array of pseudorandom values.

[344:11-13] Replace the Argument text with:

HARVEST shall be of type real or bits. It is an INTENT(OUT) 
argument. It may be a scalar or an array variable. If it is
of type real, it is assigned psuedorandom numbers from a uniform
distribution in the interval 0 <= <x> < 1.  If it is of type
bits, it is assigned pseudorandom values with each of the 
KIND(HARVEST) bits of each value having a 0.5 probability of 
being 1.

[344:15+] Add a new statement to the example code:

     BITS  B

[344:19+] Add a new statement and comment to the example code:

     CALL RANDOM_NUMBER(B)
     ! B contains a uniformly random collection of 0 and 1 bits.

.....................................................................
Modify the definition of REAL (13.7.97):

[346:1] In the description of the A argument, replace "or complex,
or a <boz-literal-constant>." with "complex, or bits."

[346:5-6] In Case (i) of the Result Characteristics, replace "If A is
of type integer or real" with "If A is of type integer, real, or bits"
twice.

[346:11-13] Delete all of Result Characteristics Case (iii).

[346:16] Add a sentence to the end of Result Value Case (i):

If A is of type bits, the result value is that with which R becomes
defined as a result of the intrinsic assignment R = A, for a real 
variable R with the kind type parameter specified.

[346:19-22] Delete all of Result Value Case (iii).

.....................................................................
[349:6+] Add a new intrinsic function, SELECTED_BITS_KIND:

13.7.103a SELECTED_BITS_KIND (N)

<<Description.>> Returns a value of the kind parameter of a bits type
with N bits.

<<Class.>> Transformational function.

<<Argument.>> N shall be scalar and of type integer.

<<Result Characteristics.>> Default integer scalar.

<<Result Value.>> The result value is N if the processor supports
a bits type with a kind type parameter equal to N; otherwise the
result value is -1.
  
<<Example.>> If the NUMERIC_STORAGE_SIZE value for the processor
is 32, SELECT_BITS_KIND(32) has the value 32.  

.....................................................................
[351:19+] Add three new intrinsic functions, SHIFTA, SHIFTL, and
SHIFTR:

13.7.108a SHIFTA (I, SHIFT)

<<Description.>> Performs an arithmetic right shift.

<<Class.>> Elemental function.

<<Arguments.>>

I       shall be of type integer or bits.

SHIFT   shall be of type integer with a value in the range
        0 through BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result has the value obtained by shifting
the bits of I to the right SHIFT bits and replicating the 
leftmost bit of I in the left SHIFT bits. If SHIFT is zero the result 
is I. Bits shifted out from the right are lost.
The model for the interpretation of an integer value as a sequence
of bits is in 13.3.
  
<<Example.>> SHIFTA(b"10000",2) has the value b"11100".


13.7.108b SHIFTL (I, SHIFT)

<<Description.>> Performs a left shift.

<<Class.>> Elemental function.

<<Arguments.>>

I       shall be of type integer or bits.

SHIFT   shall be of type integer with a value in the range
        0 through BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result has the value obtained by shifting
the bits of I to the left SHIFT bits. If SHIFT is zero the result 
is I. Bits shifted out from the left are lost. Zeros are shifted
in from the right.
The model for the interpretation of an integer value as a sequence
of bits is in 13.3.
  
<<Example.>> SHIFTL(b"00001",2) has the value b"00100".


13.7.108c SHIFTR (I, SHIFT)

<<Description.>> Performs a right shift.

<<Class.>> Elemental function.

<<Arguments.>>

I       shall be of type integer or bits.

SHIFT   shall be of type integer with a value in the range
        0 through BIT_SIZE(I).

<<Result Characteristics.>> Same as I.

<<Result Value.>> The result has the value obtained by shifting
the bits of I to the right SHIFT bits. If SHIFT is zero the result 
is I. Bits shifted out from the right are lost.
The model for the interpretation of an integer value as a sequence
of bits is in 13.3.
  
<<Example.>> SHIFTR(b"10000",2) has the value b"00100".

.....................................................................
[356:10+] Add a new intrinsic function, TRAILZ:

13.7.120a TRAILZ (I [,KIND])

<<Description.>> Count the number of trailing zero bits.

<<Class.>> Elemental function.

<<Arguments.>>

I                  shall be of type integer or bits.

KIND (optional)    shall be a scalar initialization expression.

<<Result Characteristics.>>  Integer. If KIND is present, the kind
type parameter is that specified by the value of KIND; otherwise,
the kind type parameter is that of the default integer type.

<<Result Value.>> If all of the bits of I are zero, the result value
is BIT_SIZE(I). Otherwise, the result value is the position of the
rightmost 1 bit in I, where the rightmost bit position is 0.
The model for the interpretation of an integer value as a sequence
of bits is in 13.3.
  
<<Example.>> TRAILZ(8) has the value 3. TRAILZ(b"101101000") has
the value 3.

.....................................................................
[391:25+] Add a new paragraph after the second paragraph in 
'15.1.1 Named constants and derived types in the module':

The value of C_UINT shall be a valid value for a bits kind parameter
of the processor. The values of	C_USHORT, C_ULONG, C_ULONG_LONG,
C_USIGNED_CHAR, C_UINT8_T, C_UINT16_T, C_UINT32_T, C_UINT64_T,
C_UINT_LEAST8_T, C_UINT_LEAST16_T, C_UINT_LEAST32_T, 
C_UINT_LEAST64_T, C_UINT_FAST8_T, C_UINT_FAST16_T, C_UINT_FAST32_T,
C_UINT_FAST64_T, C_UINTMAX_T, C_UINTPTR_T, C_FLOAT_BITS,  
C_DOUBLE_BITS, C_LONG_DOUBLE_BITS, C_FLOAT_COMPLEX_BITS,
C_DOUBLE_COMPLEX_BITS, C_LONG_DOUBLE_COMPLEX_BITS, and C_BOOL_BITS
shall each be a valid value for a bits kind type parameter on the 
processor or shall be -1 if the companion C processor defines the 
corresponding C type and there is no interoperating Fortran processor 
kind or -2 if the C processor does not define the corresponding C 
type.

.....................................................................
[396:14+] Within Table 15.2, 'Interoperability between Fortran and
C types', add a new section after the row containing "C_INTPTR_T":

-----------------------------------------------------------------
           | C_UINT                      | unsigned int or int
           | C_USHORT                    | unsigned short or short
           | C_ULONG                     | unsigned long or long
           | C_ULONG_LONG                | unsigned long long or
           |                             | long long
           | C_USIGNED_CHAR              | unsigned char or 
           |                             | signed char
           | C_UINT8_T                   | uint8_t or int8_t
           | C_UINT16_T                  | uint16_t or int16_t
           | C_UINT32_T                  | uint32_t or int32_t
  BITS     | C_UINT64_T                  | uint64_t or int64_t
           | C_UINT_LEAST8_T             | uint_least8_t or
           |                             |  int_least8_t
           | C_UINT_LEAST16_T            | uint_least16_t or
           |                             |  int_least16_t
           | C_UINT_LEAST32_T            | uint_least32_t or
           |                             |  int_least32_t
           | C_UINT_LEAST64_T            | uint_least64_t or
           |                             |  int_least64_t
           | C_UINT_FAST8_T              | uint_fast8_t or
           |                             |  int_fast8_t
           | C_UINT_FAST16_T             | uint_fast16_t or
           |                             |  int_fast16_t
           | C_UINT_FAST32_T             | uint_fast32_t or
           |                             |  int_fast32_t
           | C_UINT_FAST64_T             | uint_fast64_t or
           |                             |  int_fast64_t
           | C_UINTMAX_T                 | uintmax_t or intmax_t
           | C_UINTPTR_T                 | uintptr_t or intptr_t
           | C_FLOAT_BITS                | float
           | C_DOUBLE_BITS               | double
           | C_LONG_DOUBLE_BITS          | long double
           | C_FLOAT_COMPLEX_BITS        | float _Complex
           | C_DOUBLE_COMPLEX_BITS       | double _Complex
           | C_LONG_DOUBLE_COMPLEX_BITS  | long double _Complex
           | C_BOOL_BITS                 | _Bool

.....................................................................
[397:1-] After Note 15.9 at the end of '15.2.1 Inteoperability of
intrinsic types' add a new Note:

Note 15.9a
If a variable of type bits is the actual argument corresponding to
an unsigned integer parameter of a C function and is interoperable
with that parameter, or the unsigned integer result of a C function 
is assigned to a variable of type bits that is interoperable with 
the function result, the I format can be used to output the correct
form of the unsigned integer value. 
[end Note]
 
.....................................................................
[416:8] In item 1 of the list in '16.4.3.1 Storage sequence' replace
"default real, or default logical" with "default real, default
logical, or default bits".

.....................................................................
[416:11+] After item 2 of the list in '16.4.3.1 Storage sequence'
add a new list item:

(2a) A nonpointer scalar object of type bits with a kind type
parameter that is an integer multiple, N, of the size of a numeric
storage unit occupies N contiguous numeric storage units. The
ordering of these consecutive numeric storage units is processor
dependent.

.....................................................................
[416:28+] Add a new paragraph and Note at the end of '16.4.3.1
Storage sequence':

Two objects for which the intrinsic function COMPATIBLE_BITS_KIND
returns the same value occupy the same amount of storage.

Note 16.13a: 
A nonpointer nonallocatable scalar BITS object with a KIND value
that is not an integer multiple of the bit size of a numeric storage
unit may be stored in a memory region larger than the minimum required
to represent the value. This allows for data alignments that may be
needed for efficient execution. Each element of a BITS array has the
same padding in memory as a scalar BITS object of the same
kind. Padding is not allowed for BITS objects with a KIND value that
is an integer multiple of the bit size of a numeric storage unit.

As an example, an integer kind might be provided with a range of -128
through +127, requiring 8 bits to represent values on a system using
an integer radix of 2. The compatible bits kind of an object of this
integer kind is 8.  If the implementation uses 32 bits of storage for
this kind of integer (including 24 bits of pad) then the
implementation shall also use 32 bits of storage for a BITS(8)
object. In that case, an array of type BITS(8) and size 10 would
occupy 40 bytes of memory.  
[end Note]

.....................................................................
